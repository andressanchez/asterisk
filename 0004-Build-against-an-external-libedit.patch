From 53cfcfc09c5e1cd3969d2c295696bac93cf84923 Mon Sep 17 00:00:00 2001
From: "Jeffrey C. Ollie" <jeff@ocjtech.us>
Date: Fri, 14 Oct 2011 10:39:29 -0500
Subject: [PATCH 4/6] Build against an external libedit.

The Asterisk tarball includes a very old copy of the editline library
that manages command line history and editing.  Fedora (and several
other distributions) highly discourage this practice because if there
are security problems (or even just severe bugs) in the library it can
be very difficult to track down all instances of the library.  This
patch adds the option of building/linking against an external copy of
the libedit library.
---
 build_tools/menuselect-deps.in    |    1 +
 configure.ac                      |   43 +-
 main/Makefile                     |   22 +-
 main/asterisk.c                   |   24 +-
 main/cli.c                        |    3 +-
 main/editline/CHANGES             |   42 -
 main/editline/INSTALL             |   64 -
 main/editline/Makefile.in         |  234 ----
 main/editline/PLATFORMS           |   13 -
 main/editline/README              |   11 -
 main/editline/TEST/test.c         |  268 ----
 main/editline/chared.c            |  695 -----------
 main/editline/chared.h            |  159 ---
 main/editline/common.c            |  951 --------------
 main/editline/config.guess        | 1449 ----------------------
 main/editline/config.h.in         |   21 -
 main/editline/config.sub          | 1412 ---------------------
 main/editline/configure           | 2464 -------------------------------------
 main/editline/configure.in        |  278 -----
 main/editline/editline.3          |  646 ----------
 main/editline/editrc.5            |  491 --------
 main/editline/el.c                |  509 --------
 main/editline/el.h                |  145 ---
 main/editline/emacs.c             |  488 --------
 main/editline/hist.c              |  197 ---
 main/editline/hist.h              |   80 --
 main/editline/histedit.h          |  197 ---
 main/editline/history.c           |  875 -------------
 main/editline/install-sh          |  250 ----
 main/editline/key.c               |  687 -----------
 main/editline/key.h               |   79 --
 main/editline/makelist.in         |  254 ----
 main/editline/map.c               | 1418 ---------------------
 main/editline/map.h               |   79 --
 main/editline/np/fgetln.c         |   88 --
 main/editline/np/strlcat.c        |   75 --
 main/editline/np/strlcpy.c        |   75 --
 main/editline/np/unvis.c          |  322 -----
 main/editline/np/vis.c            |  348 ------
 main/editline/np/vis.h            |   96 --
 main/editline/parse.c             |  259 ----
 main/editline/parse.h             |   52 -
 main/editline/prompt.c            |  174 ---
 main/editline/prompt.h            |   62 -
 main/editline/read.c              |  558 ---------
 main/editline/read.h              |   55 -
 main/editline/readline.c          | 1665 -------------------------
 main/editline/readline/readline.h |  118 --
 main/editline/refresh.c           | 1104 -----------------
 main/editline/refresh.h           |   63 -
 main/editline/search.c            |  649 ----------
 main/editline/search.h            |   70 --
 main/editline/sig.c               |  198 ---
 main/editline/sig.h               |   72 --
 main/editline/sys.h               |  135 --
 main/editline/term.c              | 1587 ------------------------
 main/editline/term.h              |  124 --
 main/editline/tokenizer.c         |  397 ------
 main/editline/tokenizer.h         |   54 -
 main/editline/tty.c               | 1182 ------------------
 main/editline/tty.h               |  484 --------
 main/editline/vi.c                |  941 --------------
 makeopts.in                       |    6 +-
 63 files changed, 43 insertions(+), 25519 deletions(-)
 delete mode 100644 main/editline/CHANGES
 delete mode 100644 main/editline/INSTALL
 delete mode 100644 main/editline/Makefile.in
 delete mode 100644 main/editline/PLATFORMS
 delete mode 100644 main/editline/README
 delete mode 100644 main/editline/TEST/test.c
 delete mode 100644 main/editline/chared.c
 delete mode 100644 main/editline/chared.h
 delete mode 100644 main/editline/common.c
 delete mode 100755 main/editline/config.guess
 delete mode 100644 main/editline/config.h.in
 delete mode 100755 main/editline/config.sub
 delete mode 100755 main/editline/configure
 delete mode 100644 main/editline/configure.in
 delete mode 100644 main/editline/editline.3
 delete mode 100644 main/editline/editrc.5
 delete mode 100644 main/editline/el.c
 delete mode 100644 main/editline/el.h
 delete mode 100644 main/editline/emacs.c
 delete mode 100644 main/editline/hist.c
 delete mode 100644 main/editline/hist.h
 delete mode 100644 main/editline/histedit.h
 delete mode 100644 main/editline/history.c
 delete mode 100755 main/editline/install-sh
 delete mode 100644 main/editline/key.c
 delete mode 100644 main/editline/key.h
 delete mode 100644 main/editline/makelist.in
 delete mode 100644 main/editline/map.c
 delete mode 100644 main/editline/map.h
 delete mode 100644 main/editline/np/fgetln.c
 delete mode 100644 main/editline/np/strlcat.c
 delete mode 100644 main/editline/np/strlcpy.c
 delete mode 100644 main/editline/np/unvis.c
 delete mode 100644 main/editline/np/vis.c
 delete mode 100644 main/editline/np/vis.h
 delete mode 100644 main/editline/parse.c
 delete mode 100644 main/editline/parse.h
 delete mode 100644 main/editline/prompt.c
 delete mode 100644 main/editline/prompt.h
 delete mode 100644 main/editline/read.c
 delete mode 100644 main/editline/read.h
 delete mode 100644 main/editline/readline.c
 delete mode 100644 main/editline/readline/readline.h
 delete mode 100644 main/editline/refresh.c
 delete mode 100644 main/editline/refresh.h
 delete mode 100644 main/editline/search.c
 delete mode 100644 main/editline/search.h
 delete mode 100644 main/editline/sig.c
 delete mode 100644 main/editline/sig.h
 delete mode 100644 main/editline/sys.h
 delete mode 100644 main/editline/term.c
 delete mode 100644 main/editline/term.h
 delete mode 100644 main/editline/tokenizer.c
 delete mode 100644 main/editline/tokenizer.h
 delete mode 100644 main/editline/tty.c
 delete mode 100644 main/editline/tty.h
 delete mode 100644 main/editline/vi.c

diff --git a/build_tools/menuselect-deps.in b/build_tools/menuselect-deps.in
index 35573c3..4425204 100644
--- a/build_tools/menuselect-deps.in
+++ b/build_tools/menuselect-deps.in
@@ -26,6 +26,7 @@ JACK=@PBX_JACK@
 KQUEUE=@PBX_KQUEUE@
 LDAP=@PBX_LDAP@
 LIBXML2=@PBX_LIBXML2@
+LIBEDIT=@PBX_LIBEDIT@
 LTDL=@PBX_LTDL@
 LUA=@PBX_LUA@
 MISDN=@PBX_MISDN@
diff --git a/configure.ac b/configure.ac
index 4b6eed6..e3276578 100644
--- a/configure.ac
+++ b/configure.ac
@@ -394,6 +394,7 @@ AST_EXT_LIB_SETUP([JACK], [Jack Audio Connection Kit], [jack])
 AST_EXT_LIB_SETUP([KQUEUE], [kqueue support], [kqueue])
 AST_EXT_LIB_SETUP([LDAP], [OpenLDAP], [ldap])
 AST_LIBCURL_CHECK_CONFIG([], [7.10.1])
+AST_EXT_LIB_SETUP([LIBEDIT], [NetBSD Editline library], [libedit])
 AST_EXT_LIB_SETUP([LIBXML2], [LibXML2], [libxml2])
 AST_EXT_LIB_SETUP([LTDL], [libtool], [ltdl])
 AST_EXT_LIB_SETUP([LUA], [Lua], [lua])
@@ -452,26 +453,6 @@ AC_HEADER_STDC
 AC_HEADER_SYS_WAIT
 AC_CHECK_HEADERS([arpa/inet.h fcntl.h inttypes.h libintl.h limits.h locale.h malloc.h netdb.h netinet/in.h stddef.h stdint.h stdlib.h string.h strings.h sys/event.h sys/file.h sys/ioctl.h sys/param.h sys/socket.h sys/time.h syslog.h termios.h unistd.h utime.h arpa/nameser.h sys/io.h])
 
-# Any one of these 4 packages support a mandatory requirement, so we want to check on them as early as possible.
-AST_EXT_LIB_CHECK([TERMCAP], [termcap], [tgetent], [])
-AST_EXT_LIB_CHECK([TINFO], [tinfo], [tgetent], [])
-AST_EXT_LIB_CHECK([CURSES], [curses], [initscr], [curses.h])
-AST_EXT_LIB_CHECK([NCURSES], [ncurses], [initscr], [curses.h])
-
-EDITLINE_LIB=""
-if test "x$TERMCAP_LIB" != "x" ; then
-  EDITLINE_LIB="$TERMCAP_LIB"
-elif test "x$TINFO_LIB" != "x" ; then
-  EDITLINE_LIB="$TINFO_LIB"
-elif test "x$CURSES_LIB" != "x" ; then
-  EDITLINE_LIB="$CURSES_LIB"
-elif test "x$NCURSES_LIB" != "x" ; then
-  EDITLINE_LIB="$NCURSES_LIB"
-else
-  AC_MSG_ERROR([*** termcap support not found (on modern systems, this typically means the ncurses development package is missing)])
-fi
-AC_SUBST(EDITLINE_LIB)
-
 # Another mandatory item (unless it's explicitly disabled)
 AC_ARG_ENABLE([xmldoc],
 	[AS_HELP_STRING([--disable-xmldoc],
@@ -2171,6 +2152,28 @@ AC_SUBST(PBX_GTK2)
 AC_SUBST(GTK2_INCLUDE)
 AC_SUBST(GTK2_LIB)
 
+PBX_LIBEDIT=0
+LIBEDIT_INCLUDE=
+LIBEDIT_LIB=
+if test  "${USE_LIBEDIT}" != "no"; then
+   AC_CHECK_TOOL(PKGCONFIG, pkg-config, no)
+   if test "${PKGCONFIG}" != "no"; then
+      if ${PKGCONFIG} --exists libedit; then
+         LIBEDIT_INCLUDE=$(${PKGCONFIG} libedit --cflags)
+         LIBEDIT_LIB=$(${PKGCONFIG} libedit --libs)
+         PBX_LIBEDIT=1
+         AC_DEFINE([HAVE_LIBEDIT], 1, [Define if your system has the NetBSD Editline libraries.])
+      fi
+   fi
+fi
+AC_SUBST(PBX_LIBEDIT)
+AC_SUBST(LIBEDIT_INCLUDE)
+AC_SUBST(LIBEDIT_LIB)
+if test "${PBX_LIBEDIT}" != 1; then
+   AC_MSG_NOTICE(*** The NetBSD Editline development package is missing.)
+   exit 1
+fi
+
 # build a GENERIC_ODBC result based on the presence of either UnixODBC (preferred)
 # or iODBC
 
diff --git a/main/Makefile b/main/Makefile
index 728b805..5482c13 100644
--- a/main/Makefile
+++ b/main/Makefile
@@ -42,9 +42,9 @@ ifneq ($(findstring $(OSARCH), linux-gnu uclinux linux-uclibc linux-gnueabi kfre
   ifneq (x$(CAP_LIB),x)
     AST_LIBS+=$(CAP_LIB)
   endif
-  AST_LIBS+=-lpthread $(EDITLINE_LIB) -lm -lresolv
+  AST_LIBS+=-lpthread -lm -lresolv
 else
-  AST_LIBS+=$(EDITLINE_LIB) -lm
+  AST_LIBS+=-lm
 endif
 
 ifneq ($(findstring BETTER_BACKTRACES,$(MENUSELECT_CFLAGS)),)
@@ -81,11 +81,11 @@ ifneq ($(findstring $(OSARCH), mingw32 cygwin ),)
   ASTLINK+= -shared -Wl,--out-implib,libasterisk.a
 endif
 ifeq ($(OSARCH),NetBSD)
-  AST_LIBS+=-lpthread -lcrypto -lm -L/usr/pkg/lib $(EDITLINE_LIB)
+  AST_LIBS+=-lpthread -lcrypto -lm -L/usr/pkg/lib
 endif
 
 ifeq ($(OSARCH),OpenBSD)
-  AST_LIBS+=-lcrypto -lpthread -lm $(EDITLINE_LIB)
+  AST_LIBS+=-lcrypto -lpthread -lm
 endif
 
 ifeq ($(OSARCH),SunOS)
@@ -109,10 +109,6 @@ endif
 .PHONY: CHECK_SUBDIR
 CHECK_SUBDIR:	# do nothing, just make sure that we recurse in the subdir/
 
-editline/libedit.a: CHECK_SUBDIR
-	cd editline && test -f config.h || CFLAGS="$(PTHREAD_CFLAGS) $(subst $(ASTTOPDIR),../../,$(_ASTCFLAGS:-Werror=) $(ASTCFLAGS))" LDFLAGS="$(_ASTLDFLAGS) $(ASTLDFLAGS)" ./configure --build=$(BUILD_PLATFORM) --host=$(HOST_PLATFORM) --with-ncurses=$(NCURSES_DIR) --with-curses=$(CURSES_DIR) --with-termcap=$(TERMCAP_DIR) --with-tinfo=$(TINFO_DIR)
-	$(MAKE) -C editline libedit.a
-
 ifneq ($(findstring REBUILD_PARSERS,$(MENUSELECT_CFLAGS)),)
 ast_expr2.c ast_expr2.h: ast_expr2.y
 else
@@ -143,6 +139,7 @@ testexpr2: ast_expr2f.c ast_expr2.c ast_expr2.h
 	rm ast_expr2.o ast_expr2f.o 
 
 db.o: _ASTCFLAGS+=$(SQLITE3_INCLUDE)
+cli.o: ASTCFLAGS+=$(LIBEDIT_INCLUDE)
 
 ifneq ($(findstring ENABLE_UPLOADS,$(MENUSELECT_CFLAGS)),)
 http.o: _ASTCFLAGS+=$(GMIME_INCLUDE)
@@ -178,13 +175,13 @@ endif
 
 $(OBJS): _ASTCFLAGS+=-DAST_MODULE=\"core\"
 
-$(MAIN_TGT): $(OBJS) editline/libedit.a $(AST_EMBED_LDSCRIPTS)
+$(MAIN_TGT): $(OBJS) $(AST_EMBED_LDSCRIPTS)
 	@$(CC) -c -o buildinfo.o $(_ASTCFLAGS) buildinfo.c $(ASTCFLAGS)
-	$(ECHO_PREFIX) echo "   [LD] $(OBJS) editline/libedit.a $(AST_EMBED_LDSCRIPTS) -> $@"
+	$(ECHO_PREFIX) echo "   [LD] $(OBJS) $(AST_EMBED_LDSCRIPTS) -> $@"
 ifneq ($(findstring chan_h323,$(MENUSELECT_CHANNELS)),)
-	$(CMD_PREFIX) $(CC) $(STATIC_BUILD) -o $@ $(ASTLINK) $(AST_EMBED_LDFLAGS) $(_ASTLDFLAGS) $(ASTLDFLAGS) $(OBJS) editline/libedit.a $(AST_EMBED_LDSCRIPTS) buildinfo.o $(AST_LIBS) $(AST_EMBED_LIBS) $(GMIMELDFLAGS)
+	$(CMD_PREFIX) $(CC) $(STATIC_BUILD) -o $@ $(ASTLINK) $(AST_EMBED_LDFLAGS) $(_ASTLDFLAGS) $(ASTLDFLAGS) $(OBJS) $(AST_EMBED_LDSCRIPTS) buildinfo.o $(AST_LIBS) $(AST_EMBED_LIBS) $(GMIMELDFLAGS) $(LIBEDIT_LIB)
 else
-	$(CMD_PREFIX) $(CXX) $(STATIC_BUILD) -o $@ $(ASTLINK) $(AST_EMBED_LDFLAGS) $(_ASTLDFLAGS) $(ASTLDFLAGS) $(H323LDFLAGS) $(OBJS) editline/libedit.a $(AST_EMBED_LDSCRIPTS) buildinfo.o $(AST_LIBS) $(AST_EMBED_LIBS) $(H323LDLIBS) $(GMIMELDFLAGS)
+	$(CMD_PREFIX) $(CXX) $(STATIC_BUILD) -o $@ $(ASTLINK) $(AST_EMBED_LDFLAGS) $(_ASTLDFLAGS) $(ASTLDFLAGS) $(H323LDFLAGS) $(OBJS) $(AST_EMBED_LDSCRIPTS) buildinfo.o $(AST_LIBS) $(AST_EMBED_LIBS) $(H323LDLIBS) $(GMIMELDFLAGS) $(LIBEDIT_LIB)
 endif
 
 ifeq ($(GNU_LD),1)
@@ -196,6 +193,5 @@ endif
 clean::
 	rm -f asterisk
 	rm -f asterisk.exports
-	@if [ -f editline/Makefile ]; then $(MAKE) -C editline distclean ; fi
 	@$(MAKE) -C stdtime clean
 	rm -f libresample/src/*.o
diff --git a/main/asterisk.c b/main/asterisk.c
index 16f3efa..f41d788 100644
--- a/main/asterisk.c
+++ b/main/asterisk.c
@@ -107,6 +107,8 @@ int daemon(int, int);  /* defined in libresolv of all places */
 #endif /* HAVE_CAP */
 #endif /* linux */
 
+#include <histedit.h>
+
 #include "asterisk/paths.h"	/* we define here the variables so better agree on the prototype */
 #include "asterisk/network.h"
 #include "asterisk/cli.h"
@@ -131,7 +133,6 @@ int daemon(int, int);  /* defined in libresolv of all places */
 #include "asterisk/utils.h"
 #include "asterisk/file.h"
 #include "asterisk/io.h"
-#include "editline/histedit.h"
 #include "asterisk/config.h"
 #include "asterisk/ast_version.h"
 #include "asterisk/linkedlists.h"
@@ -2657,29 +2658,12 @@ static int ast_el_write_history(char *filename)
 
 static int ast_el_read_history(char *filename)
 {
-	char buf[MAX_HISTORY_COMMAND_LENGTH];
-	FILE *f;
-	int ret = -1;
+	HistEvent ev;
 
 	if (el_hist == NULL || el == NULL)
 		ast_el_initialize();
 
-	if ((f = fopen(filename, "r")) == NULL)
-		return ret;
-
-	while (!feof(f)) {
-		if (!fgets(buf, sizeof(buf), f))
-			break;
-		if (!strcmp(buf, "_HiStOrY_V2_\n"))
-			continue;
-		if (ast_all_zeros(buf))
-			continue;
-		if ((ret = ast_el_add_history(buf)) == -1)
-			break;
-	}
-	fclose(f);
-
-	return ret;
+	return (history(el_hist, &ev, H_LOAD, filename));
 }
 
 static void ast_remotecontrol(char *data)
diff --git a/main/cli.c b/main/cli.c
index 85f4473..7b6ae83 100644
--- a/main/cli.c
+++ b/main/cli.c
@@ -36,6 +36,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 #include <pwd.h>
 #include <grp.h>
 
+#include <readline.h>
+
 #include "asterisk/cli.h"
 #include "asterisk/linkedlists.h"
 #include "asterisk/module.h"
@@ -44,7 +46,6 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 #include "asterisk/utils.h"
 #include "asterisk/app.h"
 #include "asterisk/lock.h"
-#include "editline/readline/readline.h"
 #include "asterisk/threadstorage.h"
 #include "asterisk/translate.h"
 
diff --git a/main/editline/CHANGES b/main/editline/CHANGES
deleted file mode 100644
index c18b56c..0000000
--- a/main/editline/CHANGES
+++ /dev/null
@@ -1,42 +0,0 @@
-2002-02-25 : Christos Zoulas <christos@netbsd.org>
-	* Bring in constification fixes from NetBSD tree.
-	* Use NetBSD's vis, fgetln
-
-2002-02-10 : Jason Evans <jasone@freebsd.org>
-
-	* Makefile.in : Append "" arguments to for loops, to avoid syntax errors
-          with some shells that occur if there are no arguments to the for
-          loops.
-
-2002-02-09 : Jason Evans <jasone@freebsd.org>
-
-	* Install man pages in @prefix@/man/, rather than @prefix@/share/man.
-
-	* Fix the Darwin -install_name S_LDFLAGS argument to default to a prefix
-          of /usr/local if --prefix is not specified.
-
-2002-02-05 : Jason Evans <jasone@freebsd.org>
-
-	* Convert to using an autoconf-generated config.h, rather than passing
-	  -D_HAVE_<foo>=1 definitions on the command line.  Include sys.h in
-	  config.h, and include config.h in .c files rather than sys.h.
-
-	* Mangle function names for implementations in the np directory in order
-          to avoid namespace collisions with other code that may provide copies
-          of the same unimplemented functions.  For example:
-
-		#define	fgetln libedit_fgetln
-
-2002-02-03 : Jason Evans <jasone@freebsd.org>
-
-	* Add autoconf infrastructure, plus a generic Makefile that works with
-          at least BSD make, GNU make and Sun make.
-
-	* Port and/or test on FreeBSD 4.5, FreeBSD-current, NetBSD 1.5 (sparc64
-          and arm32), Apple OS X 10.1.2, Solaris 2.6, and Red Hat Linux 2.6.
-          Add the np directory, which contains implementations of non-portable
-          functions.
-
-	* Add the LIBEDIT_MAJOR and LIBEDIT_MINOR macros to histedit.h, since
-          there is otherwise no straightforward method of programmatically
-          detecting the library version.
diff --git a/main/editline/INSTALL b/main/editline/INSTALL
deleted file mode 100644
index 16fb6ff..0000000
--- a/main/editline/INSTALL
+++ /dev/null
@@ -1,64 +0,0 @@
-Building this distribution in many cases is as simple as typing the following
-while in the root directory of the source tree:
-
-	./configure
-	make
-
-To install, do the above, then type:
-
-	make install
-
-Additional build targets of finer granularity include:
-
-	lib_a
-	lib_s
-	install_hdr
-	install_lib
-	install_lib_a
-	install_lib_s
-	install_man
-	test
-
-Cleanup targets include:
-
-	clean
-	distclean
-
-Optionally, pass any of the following (not a definitive list) arguments to
-'configure':
-
---prefix=<install-root-dir>
-	Set the base directory in which to install.  For example:
-	
-		./configure --prefix=/usr/local
-
-	will cause files to be installed into /usr/local/bin, /usr/local/man,
-	/usr/local/include, /usr/local/lib, and /usr/local/share.
-
---disable-readline
-	By default, libedit is built and installed such that it works as a
-	drop-in replacement for the readline library.  This option turns that
-	behavior off.
-
---enable-debug
-	Build debugging code (for libedit development).
-
-Optionally, define environment variables, including (not exclusively):
-
-CFLAGS="?"
-	Pass these flags to the compiler.  You probably shouldn't define this
-	unless you know what you are doing.
-
-CPPFLAGS="?"
-	Pass these flags to the C preprocessor.  Note that CFLAGS is not passed
-	to 'cpp' when 'configure' is looking for include files, so you must use 
-	CPPFLAGS instead if you need to help 'configure' find header files.
-
-LD_LIBRARY_PATH="?"
-	'ld' uses this colon-separated list to find libraries.
-
-LDFLAGS="?"
-	Flags passed to 'gcc', which should normally be passed on to 'ld'.
-
-PATH="?"
-	'configure' uses this to find programs.
diff --git a/main/editline/Makefile.in b/main/editline/Makefile.in
deleted file mode 100644
index 112b68b..0000000
--- a/main/editline/Makefile.in
+++ /dev/null
@@ -1,234 +0,0 @@
-#
-# Generic Makefile for libedit.
-#
-
-OSTYPE=$(shell uname -s)
-define cyg_subst_sys
-	if uname -s | grep -i cygwin > /dev/null; then \
-	cat $@ | sed -e s/"sys\.h"/"config.h"/g > $@.copy; \
-	mv --force $@.copy $@; \
-	fi
-endef
-
-SHELL = /bin/sh
-
-CC = @CC@
-AR = @AR@
-RANLIB = @RANLIB@
-CPPFLAGS = @CPPFLAGS@ -I.
-CFLAGS = @CFLAGS@
-A_CFLAGS = @A_CFLAGS@
-S_CFLAGS = @S_CFLAGS@
-LDFLAGS = @LDFLAGS@
-S_LDFLAGS = @S_LDFLAGS@
-LIBS = @LIBS@
-
-INSTALL = @INSTALL@
-PREFIX = @prefix@
-
-ifeq ($(OSTYPE),SunOS)
-CFLAGS+=-DSOLARIS -I../../include/solaris-compat
-endif
-
-# .c files.
-ACSRCS = @ACSRCS@
-BCSRCS = @BCSRCS@
-CCSRCS = @CCSRCS@
-
-# Generated .c files.
-AGCSRCS = @AGCSRCS@
-BGCSRCS = @BGCSRCS@
-
-# .h files.
-HDRS = @HDRS@
-
-# Generated .h files.
-AGHDRS = @AGHDRS@
-BGHDRS = @BGHDRS@
-
-# Installed .h files.
-IHDRS = @IHDRS@
-IHDR_LINKS = @IHDR_LINKS@
-HDR_DIRS = @HDR_DIRS@
-
-# Man pages.
-MAN3 = @MAN3@
-MAN5 = @MAN5@
-MAN3_LINKS = @MAN3_LINKS@
-MAN_DIRS = @MAN_DIRS@
-
-# Library.
-LIB_DIRS = @LIB_DIRS@
-LIB_VER = @LIB_VER@
-LIB_A = @LIB_A@
-LIB_A_LINKS = @LIB_A_LINKS@
-LIB_S = @LIB_S@
-LIB_S_LINKS = @LIB_S_LINKS@
-
-# Test program.
-TEST = @TEST@
-TCSRCS = @TCSRCS@
-
-# Clear out all paths, then set just one (default path) for the main build
-# directory.
-.PATH :
-.PATH : .
-
-.SUFFIXES :
-.SUFFIXES : .c .o .o_a .o_s
-
-all :  lib_a lib_s
-
-lib_a : $(LIB_A)
-lib_s : $(LIB_S)
-
-test : $(TEST)
-
-install : install_hdr install_lib install_man
-
-install_hdr :
-	@for i in $(HDR_DIRS) ; do \
-		echo "$(INSTALL) -d $(PREFIX)/$$i/"; \
-		$(INSTALL) -d $(PREFIX)/$$i/; \
-	done
-	@for i in $(IHDRS); do \
-		echo "$(INSTALL) -m 0444 $$i $(PREFIX)/include/`dirname $$i`/"; \
-		$(INSTALL) -m 0444 $$i $(PREFIX)/include/`dirname $$i`/; \
-	done
-	@f=; \
-	for i in $(IHDR_LINKS) ""; do \
-		if test -z "$$f" ; then \
-			f=$$i; \
-		else \
-			echo "rm -f $(PREFIX)/include/$$i"; \
-			rm -f $(PREFIX)/include/$$i; \
-			echo "ln -s $$f $(PREFIX)/include/$$i"; \
-			ln -s $$f $(PREFIX)/include/$$i; \
-			f=; \
-		fi; \
-	done
-
-install_lib : install_lib_a install_lib_s
-
-install_lib_common :
-	@for i in $(LIB_DIRS) ; do \
-		echo "$(INSTALL) -d $(PREFIX)/$$i/"; \
-		$(INSTALL) -d $(PREFIX)/$$i/; \
-	done
-
-install_lib_a : $(LIB_A) install_lib_common
-	$(INSTALL) -m 0644 $(LIB_A) $(PREFIX)/lib/
-	@f=; \
-	for i in $(LIB_A_LINKS) ""; do \
-		if test -z "$$f" ; then \
-			f=$$i; \
-		else \
-			echo "rm -f $(PREFIX)/lib/$$i"; \
-			rm -f $(PREFIX)/lib/$$i; \
-			echo "ln -s $$f $(PREFIX)/lib/$$i"; \
-			ln -s $$f $(PREFIX)/lib/$$i; \
-			f=; \
-		fi; \
-	done
-
-install_lib_s : $(LIB_S) install_lib_common
-	$(INSTALL) -m 0755 $(LIB_S) $(PREFIX)/lib/
-	@f=; \
-	for i in $(LIB_S_LINKS) ""; do \
-		if test -z "$$f" ; then \
-			f=$$i; \
-		else \
-			echo "rm -f $(PREFIX)/lib/$$i"; \
-			rm -f $(PREFIX)/lib/$$i; \
-			echo "ln -s $$f $(PREFIX)/lib/$$i"; \
-			ln -s $$f $(PREFIX)/lib/$$i; \
-			f=; \
-		fi; \
-	done
-
-install_man :
-	@for i in $(MAN_DIRS) ; do \
-		echo "$(INSTALL) -d $(PREFIX)/$$i/"; \
-		$(INSTALL) -d $(PREFIX)/$$i/; \
-	done
-	@for i in $(MAN3); do \
-		echo $(INSTALL) -m 0444 $$i $(PREFIX)/man/man3/; \
-		$(INSTALL) -m 0444 $$i $(PREFIX)/man/man3/; \
-	done
-	@f=; \
-	for i in $(MAN3_LINKS) ""; do \
-		if test -z "$$f" ; then \
-			f=$$i; \
-		else \
-			echo "rm -f $(PREFIX)/man/man3/$$i"; \
-			rm -f $(PREFIX)/man/man3/$$i; \
-			echo "ln -s $$f $(PREFIX)/man/man3/$$i"; \
-			ln -s $$f $(PREFIX)/man/man3/$$i; \
-			f=; \
-		fi; \
-	done
-	@for i in $(MAN5); do\
-		echo $(INSTALL) -m 0444 $$i $(PREFIX)/man/man5/; \
-		$(INSTALL) -m 0444 $$i $(PREFIX)/man/man5/; \
-	done
-
-clean :
-	rm -f $(AGCSRCS) $(BGCSRCS) $(AGHDRS) $(BGHDRS) $(LIB_A) $(LIB_S)
-	rm -f $(BGCSRCS:.c=.o_a) $(CCSRCS:.c=.o_a)
-	rm -f $(BGCSRCS:.c=.o_s) $(CCSRCS:.c=.o_s)
-	rm -f $(TCSRCS:.c=.o) $(TEST)
-	rm -f *.s *.i
-
-distclean : clean
-	rm -f config.cache config.log config.status config.h makelist Makefile
-
-#
-# Internal targets and rules.
-#
-
-$(LIB_A) : $(BGCSRCS:.c=.o_a) $(CCSRCS:.c=.o_a)
-	$(AR) cru $@ $?
-	$(RANLIB) $@
-
-$(LIB_S) : $(BGCSRCS:.c=.o_s) $(CCSRCS:.c=.o_s)
-	$(CC) $(S_LDFLAGS) -o $@ $(BGCSRCS:.c=.o_s) $(CCSRCS:.c=.o_s) $(LIBS)
-
-$(TEST) : $(TCSRCS:.c=.o) $(LIB_A)
-	$(CC) -o $@ $(TCSRCS:.c=.o) $(LIB_A) $(LIBS)
-
-common.h : common.c
-	$(SHELL) makelist -h common.c > $@
-
-emacs.h : emacs.c
-	$(SHELL) makelist -h emacs.c> $@
-
-vi.h : vi.c
-	$(SHELL) makelist -h vi.c > $@
-
-fcns.h : $(AGHDRS)
-	$(SHELL) makelist -fh $(AGHDRS) > $@
-
-fcns.c : $(AGHDRS) fcns.h
-	$(SHELL) makelist -fc $(AGHDRS) > $@
-	$(cyg_subst_sys)
-
-help.h : $(ACSRCS)
-	$(SHELL) makelist -bh $(ACSRCS) > $@
-
-help.c : $(ACSRCS) help.h
-	$(SHELL) makelist -bc $(ACSRCS) > $@
-	$(cyg_subst_sys)
-
-editline.c : $(ACSRCS) $(BCSRCS) $(AGCSRCS)
-	$(SHELL) makelist -e $(ACSRCS) $(BCSRCS) $(AGCSRCS) > $@
-
-.c.o :
-	$(CC) -c $(A_CFLAGS) $(CFLAGS) $(CPPFLAGS) $< -o $@
-
-.c.o_a : $(AGHDRS) $(BGHDRS)
-	$(CC) -c $(A_CFLAGS) $(CFLAGS) $(CPPFLAGS) $< -o $@
-
-.c.o_s : $(AGHDRS) $(BGHDRS)
-	$(CC) -c $(S_CFLAGS) $(CFLAGS) $(CPPFLAGS) $< -o $@
-
-$(CCSRCS) : $(BGHDRS)
diff --git a/main/editline/PLATFORMS b/main/editline/PLATFORMS
deleted file mode 100644
index ea7c5bb..0000000
--- a/main/editline/PLATFORMS
+++ /dev/null
@@ -1,13 +0,0 @@
-This distribution of libedit is expected to work on at least the following
-platforms.  It may also work on additional platforms, but no explicit support
-for them is built into the configuration system.
-
-* Apple OS X 10.1.
-
-* FreeBSD 4.x.
-
-* NetBSD 1.5.
-
-* Red Hat Linux 7.2.
-
-* Sun Solaris 2.6.
diff --git a/main/editline/README b/main/editline/README
deleted file mode 100644
index 49a2a69..0000000
--- a/main/editline/README
+++ /dev/null
@@ -1,11 +0,0 @@
-libedit is a command line editing and history library.  It is designed to be
-used by interactive programs that allow the user to type commands at a terminal
-prompt.
-
-The following files may be of direct interest to the user:
-
-* CHANGES - Software change log.
-
-* INSTALL - Installation information.
-
-* PLATFORMS - Supported platforms and platform-specific information.
diff --git a/main/editline/TEST/test.c b/main/editline/TEST/test.c
deleted file mode 100644
index 3169a20..0000000
--- a/main/editline/TEST/test.c
+++ /dev/null
@@ -1,268 +0,0 @@
-/*	$NetBSD: test.c,v 1.9 2000/09/04 23:36:41 lukem Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#ifndef lint
-__COPYRIGHT("@(#) Copyright (c) 1992, 1993\n\
-	The Regents of the University of California.  All rights reserved.\n");
-#endif /* not lint */
-
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)test.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: test.c,v 1.9 2000/09/04 23:36:41 lukem Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * test.c: A little test program
- */
-#include <stdio.h>
-#include <string.h>
-#include <signal.h>
-#include <sys/wait.h>
-#include <ctype.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <dirent.h>
-
-#include "histedit.h"
-#include "tokenizer.h"
-
-static int continuation = 0;
-static EditLine *el = NULL;
-
-static	u_char	complete(EditLine *, int);
-	int	main(int, char **);
-static	char   *prompt(EditLine *);
-static	void	sig(int);
-
-static char *
-prompt(EditLine *el)
-{
-	static char a[] = "Edit$";
-	static char b[] = "Edit>";
-
-	return (continuation ? b : a);
-}
-
-static void
-sig(int i)
-{
-
-	(void) fprintf(stderr, "Got signal %d.\n", i);
-	el_reset(el);
-}
-
-static unsigned char
-complete(EditLine *el, int ch)
-{
-	DIR *dd = opendir(".");
-	struct dirent *dp;
-	const char* ptr;
-	const LineInfo *lf = el_line(el);
-	int len;
-
-	/*
-	 * Find the last word
-	 */
-	for (ptr = lf->cursor - 1; !isspace(*ptr) && ptr > lf->buffer; ptr--)
-		continue;
-	len = lf->cursor - ++ptr;
-
-	for (dp = readdir(dd); dp != NULL; dp = readdir(dd)) {
-		if (len > strlen(dp->d_name))
-			continue;
-		if (strncmp(dp->d_name, ptr, len) == 0) {
-			closedir(dd);
-			if (el_insertstr(el, &dp->d_name[len]) == -1)
-				return (CC_ERROR);
-			else
-				return (CC_REFRESH);
-		}
-	}
-
-	closedir(dd);
-	return (CC_ERROR);
-}
-
-int
-main(int argc, char *argv[])
-{
-	int num;
-	const char *buf;
-	Tokenizer *tok;
-#if 0
-	int lastevent = 0;
-#endif
-	int ncontinuation;
-	History *hist;
-	HistEvent ev;
-
-	(void) signal(SIGINT, sig);
-	(void) signal(SIGQUIT, sig);
-	(void) signal(SIGHUP, sig);
-	(void) signal(SIGTERM, sig);
-
-	hist = history_init();		/* Init the builtin history	*/
-					/* Remember 100 events		*/
-	history(hist, &ev, H_SETSIZE, 100);
-
-	tok  = tok_init(NULL);		/* Initialize the tokenizer	*/
-
-					/* Initialize editline		*/
-	el = el_init(*argv, stdin, stdout, stderr);
-
-	el_set(el, EL_EDITOR, "vi");	/* Default editor is vi		*/
-	el_set(el, EL_SIGNAL, 1);	/* Handle signals gracefully	*/
-	el_set(el, EL_PROMPT, prompt);	/* Set the prompt function	*/
-
-			/* Tell editline to use this history interface	*/
-	el_set(el, EL_HIST, history, hist);
-
-					/* Add a user-defined function	*/
-	el_set(el, EL_ADDFN, "ed-complete", "Complete argument", complete);
-
-					/* Bind tab to it 		*/
-	el_set(el, EL_BIND, "^I", "ed-complete", NULL);
-
-	/*
-	 * Bind j, k in vi command mode to previous and next line, instead
-	 * of previous and next history.
-	 */
-	el_set(el, EL_BIND, "-a", "k", "ed-prev-line", NULL);
-	el_set(el, EL_BIND, "-a", "j", "ed-next-line", NULL);
-
-	/*
-	 * Source the user's defaults file.
-	 */
-	el_source(el, NULL);
-
-	while ((buf = el_gets(el, &num)) != NULL && num != 0)  {
-		int ac;
-		const char **av;
-#ifdef DEBUG
-		(void) fprintf(stderr, "got %d %s", num, buf);
-#endif
-		if (!continuation && num == 1)
-			continue;
-
-		ncontinuation = tok_line(tok, buf, &ac, &av) > 0;
-#if 0
-		if (continuation) {
-			/*
-			 * Append to the right event in case the user
-			 * moved around in history.
-			 */
-			if (history(hist, &ev, H_SET, lastevent) == -1)
-				err(1, "%d: %s\n", lastevent, ev.str);
-			history(hist, &ev, H_ADD , buf);
-		} else {
-			history(hist, &ev, H_ENTER, buf);
-			lastevent = ev.num;
-		}
-#else
-				/* Simpler */
-		history(hist, &ev, continuation ? H_APPEND : H_ENTER, buf);
-#endif
-
-		continuation = ncontinuation;
-		ncontinuation = 0;
-
-		if (strcmp(av[0], "history") == 0) {
-			int rv;
-
-			switch (ac) {
-			case 1:
-				for (rv = history(hist, &ev, H_LAST); rv != -1;
-				    rv = history(hist, &ev, H_PREV))
-					(void) fprintf(stdout, "%4d %s",
-					    ev.num, ev.str);
-				break;
-
-			case 2:
-				if (strcmp(av[1], "clear") == 0)
-					 history(hist, &ev, H_CLEAR);
-				else
-					 goto badhist;
-				break;
-
-			case 3:
-				if (strcmp(av[1], "load") == 0)
-					 history(hist, &ev, H_LOAD, av[2]);
-				else if (strcmp(av[1], "save") == 0)
-					 history(hist, &ev, H_SAVE, av[2]);
-				break;
-
-			badhist:
-			default:
-				(void) fprintf(stderr,
-				    "Bad history arguments\n");
-				break;
-			}
-		} else if (el_parse(el, ac, av) == -1) {
-			switch (fork()) {
-			case 0:
-				execvp(av[0], (char *const *)av);
-				perror(av[0]);
-				_exit(1);
-				/*NOTREACHED*/
-				break;
-
-			case -1:
-				perror("fork");
-				break;
-
-			default:
-				if (wait(&num) == -1)
-					perror("wait");
-				(void) fprintf(stderr, "Exit %x\n", num);
-				break;
-			}
-		}
-
-		tok_reset(tok);
-	}
-
-	el_end(el);
-	tok_end(tok);
-	history_end(hist);
-
-	return (0);
-}
diff --git a/main/editline/chared.c b/main/editline/chared.c
deleted file mode 100644
index 8eaeb3b..0000000
--- a/main/editline/chared.c
+++ /dev/null
@@ -1,695 +0,0 @@
-/*	$NetBSD: chared.c,v 1.15 2002/03/18 16:00:50 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)chared.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: chared.c,v 1.15 2002/03/18 16:00:50 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * chared.c: Character editor utilities
- */
-#include <stdlib.h>
-#include "el.h"
-
-/* value to leave unused in line buffer */
-#define	EL_LEAVE	2
-
-/* cv_undo():
- *	Handle state for the vi undo command
- */
-protected void
-cv_undo(EditLine *el,int action, size_t size, char *ptr)
-{
-	c_undo_t *vu = &el->el_chared.c_undo;
-	vu->action = action;
-	vu->ptr    = ptr;
-	vu->isize  = size;
-	(void) memcpy(vu->buf, vu->ptr, size);
-#ifdef DEBUG_UNDO
-	(void) fprintf(el->el_errfile, "Undo buffer \"%s\" size = +%d -%d\n",
-	       vu->ptr, vu->isize, vu->dsize);
-#endif
-}
-
-
-/* c_insert():
- *	Insert num characters
- */
-protected void
-c_insert(EditLine *el, int num)
-{
-	char *cp;
-
-	if (el->el_line.lastchar + num >= el->el_line.limit)
-		return;			/* can't go past end of buffer */
-
-	if (el->el_line.cursor < el->el_line.lastchar) {
-		/* if I must move chars */
-		for (cp = el->el_line.lastchar; cp >= el->el_line.cursor; cp--)
-			cp[num] = *cp;
-	}
-	el->el_line.lastchar += num;
-}
-
-
-/* c_delafter():
- *	Delete num characters after the cursor
- */
-protected void
-c_delafter(EditLine *el, int num)
-{
-
-	if (el->el_line.cursor + num > el->el_line.lastchar)
-		num = el->el_line.lastchar - el->el_line.cursor;
-
-	if (num > 0) {
-		char *cp;
-
-		if (el->el_map.current != el->el_map.emacs)
-			cv_undo(el, INSERT, (size_t)num, el->el_line.cursor);
-
-		for (cp = el->el_line.cursor; cp <= el->el_line.lastchar; cp++)
-			*cp = cp[num];
-
-		el->el_line.lastchar -= num;
-	}
-}
-
-
-/* c_delbefore():
- *	Delete num characters before the cursor
- */
-protected void
-c_delbefore(EditLine *el, int num)
-{
-
-	if (el->el_line.cursor - num < el->el_line.buffer)
-		num = el->el_line.cursor - el->el_line.buffer;
-
-	if (num > 0) {
-		char *cp;
-
-		if (el->el_map.current != el->el_map.emacs)
-			cv_undo(el, INSERT, (size_t)num,
-			    el->el_line.cursor - num);
-
-		for (cp = el->el_line.cursor - num;
-		    cp <= el->el_line.lastchar;
-		    cp++)
-			*cp = cp[num];
-
-		el->el_line.lastchar -= num;
-	}
-}
-
-
-/* ce__isword():
- *	Return if p is part of a word according to emacs
- */
-protected int
-ce__isword(int p)
-{
-	return (isalpha(p) || isdigit(p) || strchr("*?_-.[]~=", p) != NULL);
-}
-
-
-/* cv__isword():
- *	Return if p is part of a word according to vi
- */
-protected int
-cv__isword(int p)
-{
-	return (!isspace(p));
-}
-
-
-/* c__prev_word():
- *	Find the previous word
- */
-protected char *
-c__prev_word(char *p, char *low, int n, int (*wtest)(int))
-{
-	p--;
-
-	while (n--) {
-		while ((p >= low) && !(*wtest)((unsigned char) *p))
-			p--;
-		while ((p >= low) && (*wtest)((unsigned char) *p))
-			p--;
-	}
-
-	/* cp now points to one character before the word */
-	p++;
-	if (p < low)
-		p = low;
-	/* cp now points where we want it */
-	return (p);
-}
-
-
-/* c__next_word():
- *	Find the next word
- */
-protected char *
-c__next_word(char *p, char *high, int n, int (*wtest)(int))
-{
-	while (n--) {
-		while ((p < high) && !(*wtest)((unsigned char) *p))
-			p++;
-		while ((p < high) && (*wtest)((unsigned char) *p))
-			p++;
-	}
-	if (p > high)
-		p = high;
-	/* p now points where we want it */
-	return (p);
-}
-
-/* cv_next_word():
- *	Find the next word vi style
- */
-protected char *
-cv_next_word(EditLine *el, char *p, char *high, int n, int (*wtest)(int))
-{
-	int test;
-
-	while (n--) {
-		test = (*wtest)((unsigned char) *p);
-		while ((p < high) && (*wtest)((unsigned char) *p) == test)
-			p++;
-		/*
-		 * vi historically deletes with cw only the word preserving the
-		 * trailing whitespace! This is not what 'w' does..
-		 */
-		if (el->el_chared.c_vcmd.action != (DELETE|INSERT))
-			while ((p < high) && isspace((unsigned char) *p))
-				p++;
-	}
-
-	/* p now points where we want it */
-	if (p > high)
-		return (high);
-	else
-		return (p);
-}
-
-
-/* cv_prev_word():
- *	Find the previous word vi style
- */
-protected char *
-cv_prev_word(EditLine *el, char *p, char *low, int n, int (*wtest)(int))
-{
-	int test;
-
-	while (n--) {
-		p--;
-		/*
-		 * vi historically deletes with cb only the word preserving the
-		 * leading whitespace! This is not what 'b' does..
-		 */
-		if (el->el_chared.c_vcmd.action != (DELETE|INSERT))
-			while ((p > low) && isspace((unsigned char) *p))
-				p--;
-		test = (*wtest)((unsigned char) *p);
-		while ((p >= low) && (*wtest)((unsigned char) *p) == test)
-			p--;
-		p++;
-		while (isspace((unsigned char) *p))
-			p++;
-	}
-
-	/* p now points where we want it */
-	if (p < low)
-		return (low);
-	else
-		return (p);
-}
-
-
-#ifdef notdef
-/* c__number():
- *	Ignore character p points to, return number appearing after that.
- * 	A '$' by itself means a big number; "$-" is for negative; '^' means 1.
- * 	Return p pointing to last char used.
- */
-protected char *
-c__number(
-    char *p,	/* character position */
-    int *num,	/* Return value	*/
-    int dval)	/* dval is the number to subtract from like $-3 */
-{
-	int i;
-	int sign = 1;
-
-	if (*++p == '^') {
-		*num = 1;
-		return (p);
-	}
-	if (*p == '$') {
-		if (*++p != '-') {
-			*num = 0x7fffffff;	/* Handle $ */
-			return (--p);
-		}
-		sign = -1;			/* Handle $- */
-		++p;
-	}
-	for (i = 0; isdigit((unsigned char) *p); i = 10 * i + *p++ - '0')
-		continue;
-	*num = (sign < 0 ? dval - i : i);
-	return (--p);
-}
-#endif
-
-/* cv_delfini():
- *	Finish vi delete action
- */
-protected void
-cv_delfini(EditLine *el)
-{
-	int size;
-	int oaction;
-
-	if (el->el_chared.c_vcmd.action & INSERT)
-		el->el_map.current = el->el_map.key;
-
-	oaction = el->el_chared.c_vcmd.action;
-	el->el_chared.c_vcmd.action = NOP;
-
-	if (el->el_chared.c_vcmd.pos == 0)
-		return;
-
-
-	if (el->el_line.cursor > el->el_chared.c_vcmd.pos) {
-		size = (int) (el->el_line.cursor - el->el_chared.c_vcmd.pos);
-		c_delbefore(el, size);
-		el->el_line.cursor = el->el_chared.c_vcmd.pos;
-		re_refresh_cursor(el);
-	} else if (el->el_line.cursor < el->el_chared.c_vcmd.pos) {
-		size = (int)(el->el_chared.c_vcmd.pos - el->el_line.cursor);
-		c_delafter(el, size);
-	} else {
-		size = 1;
-		c_delafter(el, size);
-	}
-	switch (oaction) {
-	case DELETE|INSERT:
-		el->el_chared.c_undo.action = DELETE|INSERT;
-		break;
-	case DELETE:
-		el->el_chared.c_undo.action = INSERT;
-		break;
-	case NOP:
-	case INSERT:
-	default:
-		EL_ABORT((el->el_errfile, "Bad oaction %d\n", oaction));
-		break;
-	}
-
-
-	el->el_chared.c_undo.ptr = el->el_line.cursor;
-	el->el_chared.c_undo.dsize = size;
-}
-
-
-#ifdef notdef
-/* ce__endword():
- *	Go to the end of this word according to emacs
- */
-protected char *
-ce__endword(char *p, char *high, int n)
-{
-	p++;
-
-	while (n--) {
-		while ((p < high) && isspace((unsigned char) *p))
-			p++;
-		while ((p < high) && !isspace((unsigned char) *p))
-			p++;
-	}
-
-	p--;
-	return (p);
-}
-#endif
-
-
-/* cv__endword():
- *	Go to the end of this word according to vi
- */
-protected char *
-cv__endword(char *p, char *high, int n)
-{
-	p++;
-
-	while (n--) {
-		while ((p < high) && isspace((unsigned char) *p))
-			p++;
-
-		if (isalnum((unsigned char) *p))
-			while ((p < high) && isalnum((unsigned char) *p))
-				p++;
-		else
-			while ((p < high) && !(isspace((unsigned char) *p) ||
-			    isalnum((unsigned char) *p)))
-				p++;
-	}
-	p--;
-	return (p);
-}
-
-/* ch_init():
- *	Initialize the character editor
- */
-protected int
-ch_init(EditLine *el)
-{
-	el->el_line.buffer		= (char *) el_malloc(EL_BUFSIZ);
-	if (el->el_line.buffer == NULL)
-		return (-1);
-
-	(void) memset(el->el_line.buffer, 0, EL_BUFSIZ);
-	el->el_line.cursor		= el->el_line.buffer;
-	el->el_line.lastchar		= el->el_line.buffer;
-	el->el_line.limit		= &el->el_line.buffer[EL_BUFSIZ - 2];
-
-	el->el_chared.c_undo.buf	= (char *) el_malloc(EL_BUFSIZ);
-	if (el->el_chared.c_undo.buf == NULL)
-		return (-1);
-	(void) memset(el->el_chared.c_undo.buf, 0, EL_BUFSIZ);
-	el->el_chared.c_undo.action	= NOP;
-	el->el_chared.c_undo.isize	= 0;
-	el->el_chared.c_undo.dsize	= 0;
-	el->el_chared.c_undo.ptr	= el->el_line.buffer;
-
-	el->el_chared.c_vcmd.action	= NOP;
-	el->el_chared.c_vcmd.pos	= el->el_line.buffer;
-	el->el_chared.c_vcmd.ins	= el->el_line.buffer;
-
-	el->el_chared.c_kill.buf	= (char *) el_malloc(EL_BUFSIZ);
-	if (el->el_chared.c_kill.buf == NULL)
-		return (-1);
-	(void) memset(el->el_chared.c_kill.buf, 0, EL_BUFSIZ);
-	el->el_chared.c_kill.mark	= el->el_line.buffer;
-	el->el_chared.c_kill.last	= el->el_chared.c_kill.buf;
-
-	el->el_map.current		= el->el_map.key;
-
-	el->el_state.inputmode		= MODE_INSERT; /* XXX: save a default */
-	el->el_state.doingarg		= 0;
-	el->el_state.metanext		= 0;
-	el->el_state.argument		= 1;
-	el->el_state.lastcmd		= ED_UNASSIGNED;
-
-	el->el_chared.c_macro.nline	= NULL;
-	el->el_chared.c_macro.level	= -1;
-	el->el_chared.c_macro.macro	= (char **) el_malloc(EL_MAXMACRO *
-	    sizeof(char *));
-	if (el->el_chared.c_macro.macro == NULL)
-		return (-1);
-	return (0);
-}
-
-/* ch_reset():
- *	Reset the character editor
- */
-protected void
-ch_reset(EditLine *el)
-{
-	el->el_line.cursor		= el->el_line.buffer;
-	el->el_line.lastchar		= el->el_line.buffer;
-
-	el->el_chared.c_undo.action	= NOP;
-	el->el_chared.c_undo.isize	= 0;
-	el->el_chared.c_undo.dsize	= 0;
-	el->el_chared.c_undo.ptr	= el->el_line.buffer;
-
-	el->el_chared.c_vcmd.action	= NOP;
-	el->el_chared.c_vcmd.pos	= el->el_line.buffer;
-	el->el_chared.c_vcmd.ins	= el->el_line.buffer;
-
-	el->el_chared.c_kill.mark	= el->el_line.buffer;
-
-	el->el_map.current		= el->el_map.key;
-
-	el->el_state.inputmode		= MODE_INSERT; /* XXX: save a default */
-	el->el_state.doingarg		= 0;
-	el->el_state.metanext		= 0;
-	el->el_state.argument		= 1;
-	el->el_state.lastcmd		= ED_UNASSIGNED;
-
-	el->el_chared.c_macro.level	= -1;
-
-	el->el_history.eventno		= 0;
-}
-
-/* ch_enlargebufs():
- *	Enlarge line buffer to be able to hold twice as much characters.
- *	Returns 1 if successful, 0 if not.
- */
-protected int
-ch_enlargebufs(el, addlen)
-	EditLine *el;
-	size_t addlen;
-{
-	size_t sz, newsz;
-	char *newbuffer, *oldbuf, *oldkbuf;
-
-	sz = el->el_line.limit - el->el_line.buffer + EL_LEAVE;
-	newsz = sz * 2;
-	/*
-	 * If newly required length is longer than current buffer, we need
-	 * to make the buffer big enough to hold both old and new stuff.
-	 */
-	if (addlen > sz) {
-		while(newsz - sz < addlen)
-			newsz *= 2;
-	}
-
-	/*
-	 * Reallocate line buffer.
-	 */
-	newbuffer = el_realloc(el->el_line.buffer, newsz);
-	if (!newbuffer)
-		return 0;
-
-	/* zero the newly added memory, leave old data in */
-	(void) memset(&newbuffer[sz], 0, newsz - sz);
-	    
-	oldbuf = el->el_line.buffer;
-
-	el->el_line.buffer = newbuffer;
-	el->el_line.cursor = newbuffer + (el->el_line.cursor - oldbuf);
-	el->el_line.lastchar = newbuffer + (el->el_line.lastchar - oldbuf);
-	el->el_line.limit  = &newbuffer[newsz - EL_LEAVE];
-
-	/*
-	 * Reallocate kill buffer.
-	 */
-	newbuffer = el_realloc(el->el_chared.c_kill.buf, newsz);
-	if (!newbuffer)
-		return 0;
-
-	/* zero the newly added memory, leave old data in */
-	(void) memset(&newbuffer[sz], 0, newsz - sz);
-
-	oldkbuf = el->el_chared.c_kill.buf;
-
-	el->el_chared.c_kill.buf = newbuffer;
-	el->el_chared.c_kill.last = newbuffer +
-					(el->el_chared.c_kill.last - oldkbuf);
-	el->el_chared.c_kill.mark = el->el_line.buffer +
-					(el->el_chared.c_kill.mark - oldbuf);
-
-	/*
-	 * Reallocate undo buffer.
-	 */
-	newbuffer = el_realloc(el->el_chared.c_undo.buf, newsz);
-	if (!newbuffer)
-		return 0;
-
-	/* zero the newly added memory, leave old data in */
-	(void) memset(&newbuffer[sz], 0, newsz - sz);
-
-	el->el_chared.c_undo.ptr = el->el_line.buffer +
-				    (el->el_chared.c_undo.ptr - oldbuf);
-	el->el_chared.c_undo.buf = newbuffer;
-	
-	if (!hist_enlargebuf(el, sz, newsz))
-		return 0;
-
-	return 1;
-}
-
-/* ch_end():
- *	Free the data structures used by the editor
- */
-protected void
-ch_end(EditLine *el)
-{
-	el_free((ptr_t) el->el_line.buffer);
-	el->el_line.buffer = NULL;
-	el->el_line.limit = NULL;
-	el_free((ptr_t) el->el_chared.c_undo.buf);
-	el->el_chared.c_undo.buf = NULL;
-	el_free((ptr_t) el->el_chared.c_kill.buf);
-	el->el_chared.c_kill.buf = NULL;
-	el_free((ptr_t) el->el_chared.c_macro.macro);
-	el->el_chared.c_macro.macro = NULL;
-	ch_reset(el);
-}
-
-
-/* el_insertstr():
- *	Insert string at cursorI
- */
-public int
-el_insertstr(EditLine *el, const char *s)
-{
-	size_t len;
-
-	if ((len = strlen(s)) == 0)
-		return (-1);
-	if (el->el_line.lastchar + len >= el->el_line.limit) {
-		if (!ch_enlargebufs(el, len))
-			return (-1);
-	}
-
-	c_insert(el, (int)len);
-	while (*s)
-		*el->el_line.cursor++ = *s++;
-	return (0);
-}
-
-
-/* el_deletestr():
- *	Delete num characters before the cursor
- */
-public void
-el_deletestr(EditLine *el, int n)
-{
-	if (n <= 0)
-		return;
-
-	if (el->el_line.cursor < &el->el_line.buffer[n])
-		return;
-
-	c_delbefore(el, n);		/* delete before dot */
-	el->el_line.cursor -= n;
-	if (el->el_line.cursor < el->el_line.buffer)
-		el->el_line.cursor = el->el_line.buffer;
-}
-
-/* c_gets():
- *	Get a string
- */
-protected int
-c_gets(EditLine *el, char *buf)
-{
-	char ch;
-	int len = 0;
-
-	for (ch = 0; ch == 0;) {
-		if (el_getc(el, &ch) != 1)
-			return (ed_end_of_file(el, 0));
-		switch (ch) {
-		case 0010:	/* Delete and backspace */
-		case 0177:
-			if (len > 1) {
-				*el->el_line.cursor-- = '\0';
-				el->el_line.lastchar = el->el_line.cursor;
-				buf[len--] = '\0';
-			} else {
-				el->el_line.buffer[0] = '\0';
-				el->el_line.lastchar = el->el_line.buffer;
-				el->el_line.cursor = el->el_line.buffer;
-				return (CC_REFRESH);
-			}
-			re_refresh(el);
-			ch = 0;
-			break;
-
-		case 0033:	/* ESC */
-		case '\r':	/* Newline */
-		case '\n':
-			break;
-
-		default:
-			if (len >= EL_BUFSIZ)
-				term_beep(el);
-			else {
-				buf[len++] = ch;
-				*el->el_line.cursor++ = ch;
-				el->el_line.lastchar = el->el_line.cursor;
-			}
-			re_refresh(el);
-			ch = 0;
-			break;
-		}
-	}
-	buf[len] = ch;
-	return (len);
-}
-
-
-/* c_hpos():
- *	Return the current horizontal position of the cursor
- */
-protected int
-c_hpos(EditLine *el)
-{
-	char *ptr;
-
-	/*
-	 * Find how many characters till the beginning of this line.
-	 */
-	if (el->el_line.cursor == el->el_line.buffer)
-		return (0);
-	else {
-		for (ptr = el->el_line.cursor - 1;
-		     ptr >= el->el_line.buffer && *ptr != '\n';
-		     ptr--)
-			continue;
-		return (el->el_line.cursor - ptr - 1);
-	}
-}
diff --git a/main/editline/chared.h b/main/editline/chared.h
deleted file mode 100644
index 403eca0..0000000
--- a/main/editline/chared.h
+++ /dev/null
@@ -1,159 +0,0 @@
-/*	$NetBSD: chared.h,v 1.8 2002/03/18 16:00:51 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)chared.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.chared.h: Character editor interface
- */
-#ifndef _h_el_chared
-#define	_h_el_chared
-
-#include <ctype.h>
-#include <string.h>
-
-#include "histedit.h"
-
-#define	EL_MAXMACRO	10
-
-/*
- * This is a issue of basic "vi" look-and-feel. Defining VI_MOVE works
- * like real vi: i.e. the transition from command<->insert modes moves
- * the cursor.
- *
- * On the other hand we really don't want to move the cursor, because
- * all the editing commands don't include the character under the cursor.
- * Probably the best fix is to make all the editing commands aware of
- * this fact.
- */
-#define	VI_MOVE
-
-
-typedef struct c_macro_t {
-	int	  level;
-	char	**macro;
-	char	 *nline;
-} c_macro_t;
-
-/*
- * Undo information for both vi and emacs
- */
-typedef struct c_undo_t {
-	int	 action;
-	size_t	 isize;
-	size_t	 dsize;
-	char	*ptr;
-	char	*buf;
-} c_undo_t;
-
-/*
- * Current action information for vi
- */
-typedef struct c_vcmd_t {
-	int	 action;
-	char	*pos;
-	char	*ins;
-} c_vcmd_t;
-
-/*
- * Kill buffer for emacs
- */
-typedef struct c_kill_t {
-	char	*buf;
-	char	*last;
-	char	*mark;
-} c_kill_t;
-
-/*
- * Note that we use both data structures because the user can bind
- * commands from both editors!
- */
-typedef struct el_chared_t {
-	c_undo_t	c_undo;
-	c_kill_t	c_kill;
-	c_vcmd_t	c_vcmd;
-	c_macro_t	c_macro;
-} el_chared_t;
-
-
-#define	STReof		"^D\b\b"
-#define	STRQQ		"\"\""
-
-#define	isglob(a)	(strchr("*[]?", (a)) != NULL)
-#define	isword(a)	(isprint(a))
-
-#define	NOP		0x00
-#define	DELETE		0x01
-#define	INSERT		0x02
-#define	CHANGE		0x04
-
-#define	CHAR_FWD	0
-#define	CHAR_BACK	1
-
-#define	MODE_INSERT	0
-#define	MODE_REPLACE	1
-#define	MODE_REPLACE_1	2
-
-#include "common.h"
-#include "vi.h"
-#include "emacs.h"
-#include "search.h"
-#include "fcns.h"
-
-
-protected int	 cv__isword(int);
-protected void	 cv_delfini(EditLine *);
-protected char	*cv__endword(char *, char *, int);
-protected int	 ce__isword(int);
-protected void	 cv_undo(EditLine *, int, size_t, char *);
-protected char	*cv_next_word(EditLine*, char *, char *, int, int (*)(int));
-protected char	*cv_prev_word(EditLine*, char *, char *, int, int (*)(int));
-protected char	*c__next_word(char *, char *, int, int (*)(int));
-protected char	*c__prev_word(char *, char *, int, int (*)(int));
-protected void	 c_insert(EditLine *, int);
-protected void	 c_delbefore(EditLine *, int);
-protected void	 c_delafter(EditLine *, int);
-protected int	 c_gets(EditLine *, char *);
-protected int	 c_hpos(EditLine *);
-
-protected int	 ch_init(EditLine *);
-protected void	 ch_reset(EditLine *);
-protected int	 ch_enlargebufs(EditLine *, size_t);
-protected void	 ch_end(EditLine *);
-
-#endif /* _h_el_chared */
diff --git a/main/editline/common.c b/main/editline/common.c
deleted file mode 100644
index c831e79..0000000
--- a/main/editline/common.c
+++ /dev/null
@@ -1,951 +0,0 @@
-/*	$NetBSD: common.c,v 1.11 2002/03/18 16:00:51 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)common.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: common.c,v 1.11 2002/03/18 16:00:51 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * common.c: Common Editor functions
- */
-#include "el.h"
-
-/* ed_end_of_file():
- *	Indicate end of file
- *	[^D]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_end_of_file(EditLine *el, int c)
-{
-
-	re_goto_bottom(el);
-	*el->el_line.lastchar = '\0';
-	return (CC_EOF);
-}
-
-
-/* ed_insert():
- *	Add character to the line
- *	Insert a character [bound to all insert keys]
- */
-protected el_action_t
-ed_insert(EditLine *el, int c)
-{
-	int i;
-
-	if (c == '\0')
-		return (CC_ERROR);
-
-	if (el->el_line.lastchar + el->el_state.argument >=
-	    el->el_line.limit) {
-		/* end of buffer space, try to allocate more */
-		if (!ch_enlargebufs(el, (size_t) el->el_state.argument))
-			return CC_ERROR;	/* error allocating more */
-	}
-
-	if (el->el_state.argument == 1) {
-		if (el->el_state.inputmode != MODE_INSERT) {
-			el->el_chared.c_undo.buf[el->el_chared.c_undo.isize++] =
-			    *el->el_line.cursor;
-			el->el_chared.c_undo.buf[el->el_chared.c_undo.isize] =
-			    '\0';
-			c_delafter(el, 1);
-		}
-		c_insert(el, 1);
-
-		*el->el_line.cursor++ = c;
-		el->el_state.doingarg = 0;	/* just in case */
-		re_fastaddc(el);		/* fast refresh for one char. */
-	} else {
-		if (el->el_state.inputmode != MODE_INSERT) {
-			for (i = 0; i < el->el_state.argument; i++)
-				el->el_chared.c_undo.buf[el->el_chared.c_undo.isize++] =
-				    el->el_line.cursor[i];
-
-			el->el_chared.c_undo.buf[el->el_chared.c_undo.isize] =
-			    '\0';
-			c_delafter(el, el->el_state.argument);
-		}
-		c_insert(el, el->el_state.argument);
-
-		while (el->el_state.argument--)
-			*el->el_line.cursor++ = c;
-		re_refresh(el);
-	}
-
-	if (el->el_state.inputmode == MODE_REPLACE_1)
-		(void) vi_command_mode(el, 0);
-
-	return (CC_NORM);
-}
-
-
-/* ed_delete_prev_word():
- *	Delete from beginning of current word to cursor
- *	[M-^?] [^W]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_delete_prev_word(EditLine *el, int c)
-{
-	char *cp, *p, *kp;
-
-	if (el->el_line.cursor == el->el_line.buffer)
-		return (CC_ERROR);
-
-	cp = c__prev_word(el->el_line.cursor, el->el_line.buffer,
-	    el->el_state.argument, ce__isword);
-
-	for (p = cp, kp = el->el_chared.c_kill.buf; p < el->el_line.cursor; p++)
-		*kp++ = *p;
-	el->el_chared.c_kill.last = kp;
-
-	c_delbefore(el, el->el_line.cursor - cp);	/* delete before dot */
-	el->el_line.cursor = cp;
-	if (el->el_line.cursor < el->el_line.buffer)
-		el->el_line.cursor = el->el_line.buffer; /* bounds check */
-	return (CC_REFRESH);
-}
-
-
-/* ed_delete_next_char():
- *	Delete character under cursor
- *	[^D] [x]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_delete_next_char(EditLine *el, int c)
-{
-#ifdef notdef			/* XXX */
-#define	EL	el->el_line
-	(void) fprintf(el->el_errlfile,
-	    "\nD(b: %x(%s)  c: %x(%s) last: %x(%s) limit: %x(%s)\n",
-	    EL.buffer, EL.buffer, EL.cursor, EL.cursor, EL.lastchar,
-	    EL.lastchar, EL.limit, EL.limit);
-#endif
-	if (el->el_line.cursor == el->el_line.lastchar) {
-			/* if I'm at the end */
-		if (el->el_map.type == MAP_VI) {
-			if (el->el_line.cursor == el->el_line.buffer) {
-				/* if I'm also at the beginning */
-#ifdef KSHVI
-				return (CC_ERROR);
-#else
-				term_overwrite(el, STReof, 4);
-					/* then do a EOF */
-				term__flush();
-				return (CC_EOF);
-#endif
-			} else {
-#ifdef KSHVI
-				el->el_line.cursor--;
-#else
-				return (CC_ERROR);
-#endif
-			}
-		} else {
-			if (el->el_line.cursor != el->el_line.buffer)
-				el->el_line.cursor--;
-			else
-				return (CC_ERROR);
-		}
-	}
-	c_delafter(el, el->el_state.argument);	/* delete after dot */
-	if (el->el_line.cursor >= el->el_line.lastchar &&
-	    el->el_line.cursor > el->el_line.buffer)
-			/* bounds check */
-		el->el_line.cursor = el->el_line.lastchar - 1;
-	return (CC_REFRESH);
-}
-
-
-/* ed_kill_line():
- *	Cut to the end of line
- *	[^K] [^K]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_kill_line(EditLine *el, int c)
-{
-	char *kp, *cp;
-
-	cp = el->el_line.cursor;
-	kp = el->el_chared.c_kill.buf;
-	while (cp < el->el_line.lastchar)
-		*kp++ = *cp++;	/* copy it */
-	el->el_chared.c_kill.last = kp;
-			/* zap! -- delete to end */
-	el->el_line.lastchar = el->el_line.cursor;
-	return (CC_REFRESH);
-}
-
-
-/* ed_move_to_end():
- *	Move cursor to the end of line
- *	[^E] [^E]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_move_to_end(EditLine *el, int c)
-{
-
-	el->el_line.cursor = el->el_line.lastchar;
-	if (el->el_map.type == MAP_VI) {
-#ifdef VI_MOVE
-		el->el_line.cursor--;
-#endif
-		if (el->el_chared.c_vcmd.action & DELETE) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-	}
-	return (CC_CURSOR);
-}
-
-
-/* ed_move_to_beg():
- *	Move cursor to the beginning of line
- *	[^A] [^A]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_move_to_beg(EditLine *el, int c)
-{
-
-	el->el_line.cursor = el->el_line.buffer;
-
-	if (el->el_map.type == MAP_VI) {
-			/* We want FIRST non space character */
-		while (isspace((unsigned char) *el->el_line.cursor))
-			el->el_line.cursor++;
-		if (el->el_chared.c_vcmd.action & DELETE) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-	}
-	return (CC_CURSOR);
-}
-
-
-/* ed_transpose_chars():
- *	Exchange the character to the left of the cursor with the one under it
- *	[^T] [^T]
- */
-protected el_action_t
-ed_transpose_chars(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor < el->el_line.lastchar) {
-		if (el->el_line.lastchar <= &el->el_line.buffer[1])
-			return (CC_ERROR);
-		else
-			el->el_line.cursor++;
-	}
-	if (el->el_line.cursor > &el->el_line.buffer[1]) {
-		/* must have at least two chars entered */
-		c = el->el_line.cursor[-2];
-		el->el_line.cursor[-2] = el->el_line.cursor[-1];
-		el->el_line.cursor[-1] = c;
-		return (CC_REFRESH);
-	} else
-		return (CC_ERROR);
-}
-
-
-/* ed_next_char():
- *	Move to the right one character
- *	[^F] [^F]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_next_char(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor >= el->el_line.lastchar)
-		return (CC_ERROR);
-
-	el->el_line.cursor += el->el_state.argument;
-	if (el->el_line.cursor > el->el_line.lastchar)
-		el->el_line.cursor = el->el_line.lastchar;
-
-	if (el->el_map.type == MAP_VI)
-		if (el->el_chared.c_vcmd.action & DELETE) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-	return (CC_CURSOR);
-}
-
-
-/* ed_prev_word():
- *	Move to the beginning of the current word
- *	[M-b] [b]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_prev_word(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor == el->el_line.buffer)
-		return (CC_ERROR);
-
-	el->el_line.cursor = c__prev_word(el->el_line.cursor,
-	    el->el_line.buffer,
-	    el->el_state.argument,
-	    ce__isword);
-
-	if (el->el_map.type == MAP_VI)
-		if (el->el_chared.c_vcmd.action & DELETE) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-	return (CC_CURSOR);
-}
-
-
-/* ed_prev_char():
- *	Move to the left one character
- *	[^B] [^B]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_prev_char(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor > el->el_line.buffer) {
-		el->el_line.cursor -= el->el_state.argument;
-		if (el->el_line.cursor < el->el_line.buffer)
-			el->el_line.cursor = el->el_line.buffer;
-
-		if (el->el_map.type == MAP_VI)
-			if (el->el_chared.c_vcmd.action & DELETE) {
-				cv_delfini(el);
-				return (CC_REFRESH);
-			}
-		return (CC_CURSOR);
-	} else
-		return (CC_ERROR);
-}
-
-
-/* ed_quoted_insert():
- *	Add the next character typed verbatim
- *	[^V] [^V]
- */
-protected el_action_t
-ed_quoted_insert(EditLine *el, int c)
-{
-	int num;
-	char tc;
-
-	tty_quotemode(el);
-	num = el_getc(el, &tc);
-	c = (unsigned char) tc;
-	tty_noquotemode(el);
-	if (num == 1)
-		return (ed_insert(el, c));
-	else
-		return (ed_end_of_file(el, 0));
-}
-
-
-/* ed_digit():
- *	Adds to argument or enters a digit
- */
-protected el_action_t
-ed_digit(EditLine *el, int c)
-{
-
-	if (!isdigit(c))
-		return (CC_ERROR);
-
-	if (el->el_state.doingarg) {
-			/* if doing an arg, add this in... */
-		if (el->el_state.lastcmd == EM_UNIVERSAL_ARGUMENT)
-			el->el_state.argument = c - '0';
-		else {
-			if (el->el_state.argument > 1000000)
-				return (CC_ERROR);
-			el->el_state.argument =
-			    (el->el_state.argument * 10) + (c - '0');
-		}
-		return (CC_ARGHACK);
-	} else {
-		if (el->el_line.lastchar + 1 >= el->el_line.limit) {
-			if (!ch_enlargebufs(el, 1))
-				return (CC_ERROR);
-		}
-
-		if (el->el_state.inputmode != MODE_INSERT) {
-			el->el_chared.c_undo.buf[el->el_chared.c_undo.isize++] =
-			    *el->el_line.cursor;
-			el->el_chared.c_undo.buf[el->el_chared.c_undo.isize] =
-			    '\0';
-			c_delafter(el, 1);
-		}
-		c_insert(el, 1);
-		*el->el_line.cursor++ = c;
-		el->el_state.doingarg = 0;
-		re_fastaddc(el);
-	}
-	return (CC_NORM);
-}
-
-
-/* ed_argument_digit():
- *	Digit that starts argument
- *	For ESC-n
- */
-protected el_action_t
-ed_argument_digit(EditLine *el, int c)
-{
-
-	if (!isdigit(c))
-		return (CC_ERROR);
-
-	if (el->el_state.doingarg) {
-		if (el->el_state.argument > 1000000)
-			return (CC_ERROR);
-		el->el_state.argument = (el->el_state.argument * 10) +
-		    (c - '0');
-	} else {		/* else starting an argument */
-		el->el_state.argument = c - '0';
-		el->el_state.doingarg = 1;
-	}
-	return (CC_ARGHACK);
-}
-
-
-/* ed_unassigned():
- *	Indicates unbound character
- *	Bound to keys that are not assigned
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_unassigned(EditLine *el, int c)
-{
-
-	term_beep(el);
-	term__flush();
-	return (CC_NORM);
-}
-
-
-/**
- ** TTY key handling.
- **/
-
-/* ed_tty_sigint():
- *	Tty interrupt character
- *	[^C]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_tty_sigint(EditLine *el, int c)
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_tty_dsusp():
- *	Tty delayed suspend character
- *	[^Y]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_tty_dsusp(EditLine *el, int c)
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_tty_flush_output():
- *	Tty flush output characters
- *	[^O]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_tty_flush_output(EditLine *el, int c)
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_tty_sigquit():
- *	Tty quit character
- *	[^\]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_tty_sigquit(EditLine *el, int c)
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_tty_sigtstp():
- *	Tty suspend character
- *	[^Z]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_tty_sigtstp(EditLine *el, int c)
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_tty_stop_output():
- *	Tty disallow output characters
- *	[^S]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_tty_stop_output(EditLine *el, int c)
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_tty_start_output():
- *	Tty allow output characters
- *	[^Q]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_tty_start_output(EditLine *el, int c)
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_newline():
- *	Execute command
- *	[^J]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_newline(EditLine *el, int c)
-{
-
-	re_goto_bottom(el);
-	*el->el_line.lastchar++ = '\n';
-	*el->el_line.lastchar = '\0';
-	if (el->el_map.type == MAP_VI)
-		el->el_chared.c_vcmd.ins = el->el_line.buffer;
-	return (CC_NEWLINE);
-}
-
-
-/* ed_delete_prev_char():
- *	Delete the character to the left of the cursor
- *	[^?]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_delete_prev_char(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor <= el->el_line.buffer)
-		return (CC_ERROR);
-
-	c_delbefore(el, el->el_state.argument);
-	el->el_line.cursor -= el->el_state.argument;
-	if (el->el_line.cursor < el->el_line.buffer)
-		el->el_line.cursor = el->el_line.buffer;
-	return (CC_REFRESH);
-}
-
-
-/* ed_clear_screen():
- *	Clear screen leaving current line at the top
- *	[^L]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_clear_screen(EditLine *el, int c)
-{
-
-	term_clear_screen(el);	/* clear the whole real screen */
-	re_clear_display(el);	/* reset everything */
-	return (CC_REFRESH);
-}
-
-
-/* ed_redisplay():
- *	Redisplay everything
- *	^R
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_redisplay(EditLine *el, int c)
-{
-
-	return (CC_REDISPLAY);
-}
-
-
-/* ed_start_over():
- *	Erase current line and start from scratch
- *	[^G]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_start_over(EditLine *el, int c)
-{
-
-	ch_reset(el);
-	return (CC_REFRESH);
-}
-
-
-/* ed_sequence_lead_in():
- *	First character in a bound sequence
- *	Placeholder for external keys
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_sequence_lead_in(EditLine *el, int c)
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_prev_history():
- *	Move to the previous history line
- *	[^P] [k]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_prev_history(EditLine *el, int c)
-{
-	char beep = 0;
-
-	el->el_chared.c_undo.action = NOP;
-	*el->el_line.lastchar = '\0';		/* just in case */
-
-	if (el->el_history.eventno == 0) {	/* save the current buffer
-						 * away */
-		(void) strncpy(el->el_history.buf, el->el_line.buffer,
-		    EL_BUFSIZ - 1);
-		el->el_history.last = el->el_history.buf +
-		    (el->el_line.lastchar - el->el_line.buffer);
-	}
-	el->el_history.eventno += el->el_state.argument;
-
-	if (hist_get(el) == CC_ERROR) {
-		beep = 1;
-		/* el->el_history.eventno was fixed by first call */
-		(void) hist_get(el);
-	}
-	re_refresh(el);
-	if (beep)
-		return (CC_ERROR);
-	else
-		return (CC_NORM);	/* was CC_UP_HIST */
-}
-
-
-/* ed_next_history():
- *	Move to the next history line
- *	[^N] [j]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_next_history(EditLine *el, int c)
-{
-
-	el->el_chared.c_undo.action = NOP;
-	*el->el_line.lastchar = '\0';	/* just in case */
-
-	el->el_history.eventno -= el->el_state.argument;
-
-	if (el->el_history.eventno < 0) {
-		el->el_history.eventno = 0;
-		return (CC_ERROR);/* make it beep */
-	}
-	return (hist_get(el));
-}
-
-
-/* ed_search_prev_history():
- *	Search previous in history for a line matching the current
- *	next search history [M-P] [K]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_search_prev_history(EditLine *el, int c)
-{
-	const char *hp;
-	int h;
-	bool_t found = 0;
-
-	el->el_chared.c_vcmd.action = NOP;
-	el->el_chared.c_undo.action = NOP;
-	*el->el_line.lastchar = '\0';	/* just in case */
-	if (el->el_history.eventno < 0) {
-#ifdef DEBUG_EDIT
-		(void) fprintf(el->el_errfile,
-		    "e_prev_search_hist(): eventno < 0;\n");
-#endif
-		el->el_history.eventno = 0;
-		return (CC_ERROR);
-	}
-	if (el->el_history.eventno == 0) {
-		(void) strncpy(el->el_history.buf, el->el_line.buffer,
-		    EL_BUFSIZ - 1);
-		el->el_history.last = el->el_history.buf +
-		    (el->el_line.lastchar - el->el_line.buffer);
-	}
-	if (el->el_history.ref == NULL)
-		return (CC_ERROR);
-
-	hp = HIST_FIRST(el);
-	if (hp == NULL)
-		return (CC_ERROR);
-
-	c_setpat(el);		/* Set search pattern !! */
-
-	for (h = 1; h <= el->el_history.eventno; h++)
-		hp = HIST_NEXT(el);
-
-	while (hp != NULL) {
-#ifdef SDEBUG
-		(void) fprintf(el->el_errfile, "Comparing with \"%s\"\n", hp);
-#endif
-		if ((strncmp(hp, el->el_line.buffer, (size_t)
-			    (el->el_line.lastchar - el->el_line.buffer)) ||
-			hp[el->el_line.lastchar - el->el_line.buffer]) &&
-		    c_hmatch(el, hp)) {
-			found++;
-			break;
-		}
-		h++;
-		hp = HIST_NEXT(el);
-	}
-
-	if (!found) {
-#ifdef SDEBUG
-		(void) fprintf(el->el_errfile, "not found\n");
-#endif
-		return (CC_ERROR);
-	}
-	el->el_history.eventno = h;
-
-	return (hist_get(el));
-}
-
-
-/* ed_search_next_history():
- *	Search next in history for a line matching the current
- *	[M-N] [J]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_search_next_history(EditLine *el, int c)
-{
-	const char *hp;
-	int h;
-	bool_t found = 0;
-
-	el->el_chared.c_vcmd.action = NOP;
-	el->el_chared.c_undo.action = NOP;
-	*el->el_line.lastchar = '\0';	/* just in case */
-
-	if (el->el_history.eventno == 0)
-		return (CC_ERROR);
-
-	if (el->el_history.ref == NULL)
-		return (CC_ERROR);
-
-	hp = HIST_FIRST(el);
-	if (hp == NULL)
-		return (CC_ERROR);
-
-	c_setpat(el);		/* Set search pattern !! */
-
-	for (h = 1; h < el->el_history.eventno && hp; h++) {
-#ifdef SDEBUG
-		(void) fprintf(el->el_errfile, "Comparing with \"%s\"\n", hp);
-#endif
-		if ((strncmp(hp, el->el_line.buffer, (size_t)
-			    (el->el_line.lastchar - el->el_line.buffer)) ||
-			hp[el->el_line.lastchar - el->el_line.buffer]) &&
-		    c_hmatch(el, hp))
-			found = h;
-		hp = HIST_NEXT(el);
-	}
-
-	if (!found) {		/* is it the current history number? */
-		if (!c_hmatch(el, el->el_history.buf)) {
-#ifdef SDEBUG
-			(void) fprintf(el->el_errfile, "not found\n");
-#endif
-			return (CC_ERROR);
-		}
-	}
-	el->el_history.eventno = found;
-
-	return (hist_get(el));
-}
-
-
-/* ed_prev_line():
- *	Move up one line
- *	Could be [k] [^p]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_prev_line(EditLine *el, int c)
-{
-	char *ptr;
-	int nchars = c_hpos(el);
-
-	/*
-         * Move to the line requested
-         */
-	if (*(ptr = el->el_line.cursor) == '\n')
-		ptr--;
-
-	for (; ptr >= el->el_line.buffer; ptr--)
-		if (*ptr == '\n' && --el->el_state.argument <= 0)
-			break;
-
-	if (el->el_state.argument > 0)
-		return (CC_ERROR);
-
-	/*
-         * Move to the beginning of the line
-         */
-	for (ptr--; ptr >= el->el_line.buffer && *ptr != '\n'; ptr--)
-		continue;
-
-	/*
-         * Move to the character requested
-         */
-	for (ptr++;
-	    nchars-- > 0 && ptr < el->el_line.lastchar && *ptr != '\n';
-	    ptr++)
-		continue;
-
-	el->el_line.cursor = ptr;
-	return (CC_CURSOR);
-}
-
-
-/* ed_next_line():
- *	Move down one line
- *	Could be [j] [^n]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_next_line(EditLine *el, int c)
-{
-	char *ptr;
-	int nchars = c_hpos(el);
-
-	/*
-         * Move to the line requested
-         */
-	for (ptr = el->el_line.cursor; ptr < el->el_line.lastchar; ptr++)
-		if (*ptr == '\n' && --el->el_state.argument <= 0)
-			break;
-
-	if (el->el_state.argument > 0)
-		return (CC_ERROR);
-
-	/*
-         * Move to the character requested
-         */
-	for (ptr++;
-	    nchars-- > 0 && ptr < el->el_line.lastchar && *ptr != '\n';
-	    ptr++)
-		continue;
-
-	el->el_line.cursor = ptr;
-	return (CC_CURSOR);
-}
-
-
-/* ed_command():
- *	Editline extended command
- *	[M-X] [:]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_command(EditLine *el, int c)
-{
-	char tmpbuf[EL_BUFSIZ];
-	int tmplen;
-
-	el->el_line.buffer[0] = '\0';
-	el->el_line.lastchar = el->el_line.buffer;
-	el->el_line.cursor = el->el_line.buffer;
-
-	c_insert(el, 3);	/* prompt + ": " */
-	*el->el_line.cursor++ = '\n';
-	*el->el_line.cursor++ = ':';
-	*el->el_line.cursor++ = ' ';
-	re_refresh(el);
-
-	tmplen = c_gets(el, tmpbuf);
-	tmpbuf[tmplen] = '\0';
-
-	el->el_line.buffer[0] = '\0';
-	el->el_line.lastchar = el->el_line.buffer;
-	el->el_line.cursor = el->el_line.buffer;
-
-	if (parse_line(el, tmpbuf) == -1)
-		return (CC_ERROR);
-	else
-		return (CC_REFRESH);
-}
diff --git a/main/editline/config.guess b/main/editline/config.guess
deleted file mode 100755
index a6d8a94..0000000
--- a/main/editline/config.guess
+++ /dev/null
@@ -1,1449 +0,0 @@
-#! /bin/sh
-# Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
-
-timestamp='2004-06-24'
-
-# This file is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful, but
-# WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-#
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-# Originally written by Per Bothner <per@bothner.com>.
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
-#
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
-#
-# The plan is that this can be called by configure scripts if you
-# don't specify an explicit build system type.
-
-me=`echo "$0" | sed -e 's,.*/,,'`
-
-usage="\
-Usage: $0 [OPTION]
-
-Output the configuration name of the system \`$me' is run on.
-
-Operation modes:
-  -h, --help         print this help, then exit
-  -t, --time-stamp   print date of last modification, then exit
-  -v, --version      print version number, then exit
-
-Report bugs and patches to <config-patches@gnu.org>."
-
-version="\
-GNU config.guess ($timestamp)
-
-Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
-Free Software Foundation, Inc.
-
-This is free software; see the source for copying conditions.  There is NO
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
-
-help="
-Try \`$me --help' for more information."
-
-# Parse command line
-while test $# -gt 0 ; do
-  case $1 in
-    --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit 0 ;;
-    --version | -v )
-       echo "$version" ; exit 0 ;;
-    --help | --h* | -h )
-       echo "$usage"; exit 0 ;;
-    -- )     # Stop option processing
-       shift; break ;;
-    - )	# Use stdin as input.
-       break ;;
-    -* )
-       echo "$me: invalid option $1$help" >&2
-       exit 1 ;;
-    * )
-       break ;;
-  esac
-done
-
-if test $# != 0; then
-  echo "$me: too many arguments$help" >&2
-  exit 1
-fi
-
-trap 'exit 1' 1 2 15
-
-# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
-# compiler to aid in system detection is discouraged as it requires
-# temporary files to be created and, as you can see below, it is a
-# headache to deal with in a portable fashion.
-
-# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
-# use `HOST_CC' if defined, but it is deprecated.
-
-# Portable tmp directory creation inspired by the Autoconf team.
-
-set_cc_for_build='
-trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
-trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
-: ${TMPDIR=/tmp} ;
- { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
- { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
- { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
- { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
-dummy=$tmp/dummy ;
-tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
-case $CC_FOR_BUILD,$HOST_CC,$CC in
- ,,)    echo "int x;" > $dummy.c ;
-	for c in cc gcc c89 c99 ; do
-	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
-	     CC_FOR_BUILD="$c"; break ;
-	  fi ;
-	done ;
-	if test x"$CC_FOR_BUILD" = x ; then
-	  CC_FOR_BUILD=no_compiler_found ;
-	fi
-	;;
- ,,*)   CC_FOR_BUILD=$CC ;;
- ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac ;'
-
-# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
-# (ghazi@noc.rutgers.edu 1994-08-24)
-if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
-	PATH=$PATH:/.attbin ; export PATH
-fi
-
-UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
-UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
-UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
-UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
-
-# Note: order is significant - the case branches are not exclusive.
-
-case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
-    *:NetBSD:*:*)
-	# NetBSD (nbsd) targets should (where applicable) match one or
-	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
-	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
-	# switched to ELF, *-*-netbsd* would select the old
-	# object file format.  This provides both forward
-	# compatibility and a consistent mechanism for selecting the
-	# object file format.
-	#
-	# Note: NetBSD doesn't particularly care about the vendor
-	# portion of the name.  We always set it to "unknown".
-	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
-	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
-	case "${UNAME_MACHINE_ARCH}" in
-	    armeb) machine=armeb-unknown ;;
-	    arm*) machine=arm-unknown ;;
-	    sh3el) machine=shl-unknown ;;
-	    sh3eb) machine=sh-unknown ;;
-	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
-	esac
-	# The Operating System including object format, if it has switched
-	# to ELF recently, or will in the future.
-	case "${UNAME_MACHINE_ARCH}" in
-	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
-		eval $set_cc_for_build
-		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
-			| grep __ELF__ >/dev/null
-		then
-		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
-		    # Return netbsd for either.  FIX?
-		    os=netbsd
-		else
-		    os=netbsdelf
-		fi
-		;;
-	    *)
-	        os=netbsd
-		;;
-	esac
-	# The OS release
-	# Debian GNU/NetBSD machines have a different userland, and
-	# thus, need a distinct triplet. However, they do not need
-	# kernel version information, so it can be replaced with a
-	# suitable tag, in the style of linux-gnu.
-	case "${UNAME_VERSION}" in
-	    Debian*)
-		release='-gnu'
-		;;
-	    *)
-		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
-		;;
-	esac
-	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
-	# contains redundant information, the shorter form:
-	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "${machine}-${os}${release}"
-	exit 0 ;;
-    amd64:OpenBSD:*:*)
-	echo x86_64-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    amiga:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    arc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    cats:OpenBSD:*:*)
-	echo arm-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    hp300:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    luna88k:OpenBSD:*:*)
-    	echo m88k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mac68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    macppc:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme88k:OpenBSD:*:*)
-	echo m88k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvmeppc:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    pmax:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sgi:OpenBSD:*:*)
-	echo mipseb-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sun3:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    wgrisc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    *:OpenBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    *:ekkoBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
-	exit 0 ;;
-    macppc:MirBSD:*:*)
-	echo powerppc-unknown-mirbsd${UNAME_RELEASE}
-	exit 0 ;;
-    *:MirBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
-	exit 0 ;;
-    alpha:OSF1:*:*)
-	case $UNAME_RELEASE in
-	*4.0)
-		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
-		;;
-	*5.*)
-	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
-		;;
-	esac
-	# According to Compaq, /usr/sbin/psrinfo has been available on
-	# OSF/1 and Tru64 systems produced since 1995.  I hope that
-	# covers most systems running today.  This code pipes the CPU
-	# types through head -n 1, so we only detect the type of CPU 0.
-	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
-	case "$ALPHA_CPU_TYPE" in
-	    "EV4 (21064)")
-		UNAME_MACHINE="alpha" ;;
-	    "EV4.5 (21064)")
-		UNAME_MACHINE="alpha" ;;
-	    "LCA4 (21066/21068)")
-		UNAME_MACHINE="alpha" ;;
-	    "EV5 (21164)")
-		UNAME_MACHINE="alphaev5" ;;
-	    "EV5.6 (21164A)")
-		UNAME_MACHINE="alphaev56" ;;
-	    "EV5.6 (21164PC)")
-		UNAME_MACHINE="alphapca56" ;;
-	    "EV5.7 (21164PC)")
-		UNAME_MACHINE="alphapca57" ;;
-	    "EV6 (21264)")
-		UNAME_MACHINE="alphaev6" ;;
-	    "EV6.7 (21264A)")
-		UNAME_MACHINE="alphaev67" ;;
-	    "EV6.8CB (21264C)")
-		UNAME_MACHINE="alphaev68" ;;
-	    "EV6.8AL (21264B)")
-		UNAME_MACHINE="alphaev68" ;;
-	    "EV6.8CX (21264D)")
-		UNAME_MACHINE="alphaev68" ;;
-	    "EV6.9A (21264/EV69A)")
-		UNAME_MACHINE="alphaev69" ;;
-	    "EV7 (21364)")
-		UNAME_MACHINE="alphaev7" ;;
-	    "EV7.9 (21364A)")
-		UNAME_MACHINE="alphaev79" ;;
-	esac
-	# A Pn.n version is a patched version.
-	# A Vn.n version is a released version.
-	# A Tn.n version is a released field test version.
-	# A Xn.n version is an unreleased experimental baselevel.
-	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	exit 0 ;;
-    Alpha\ *:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# Should we change UNAME_MACHINE based on the output of uname instead
-	# of the specific Alpha model?
-	echo alpha-pc-interix
-	exit 0 ;;
-    21064:Windows_NT:50:3)
-	echo alpha-dec-winnt3.5
-	exit 0 ;;
-    Amiga*:UNIX_System_V:4.0:*)
-	echo m68k-unknown-sysv4
-	exit 0;;
-    *:[Aa]miga[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-amigaos
-	exit 0 ;;
-    *:[Mm]orph[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-morphos
-	exit 0 ;;
-    *:OS/390:*:*)
-	echo i370-ibm-openedition
-	exit 0 ;;
-    *:OS400:*:*)
-        echo powerpc-ibm-os400
-	exit 0 ;;
-    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
-	echo arm-acorn-riscix${UNAME_RELEASE}
-	exit 0;;
-    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
-	echo hppa1.1-hitachi-hiuxmpp
-	exit 0;;
-    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
-	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
-	if test "`(/bin/universe) 2>/dev/null`" = att ; then
-		echo pyramid-pyramid-sysv3
-	else
-		echo pyramid-pyramid-bsd
-	fi
-	exit 0 ;;
-    NILE*:*:*:dcosx)
-	echo pyramid-pyramid-svr4
-	exit 0 ;;
-    DRS?6000:unix:4.0:6*)
-	echo sparc-icl-nx6
-	exit 0 ;;
-    DRS?6000:UNIX_SV:4.2*:7*)
-	case `/usr/bin/uname -p` in
-	    sparc) echo sparc-icl-nx7 && exit 0 ;;
-	esac ;;
-    sun4H:SunOS:5.*:*)
-	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
-    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
-	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
-    i86pc:SunOS:5.*:*)
-	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
-    sun4*:SunOS:6*:*)
-	# According to config.sub, this is the proper way to canonicalize
-	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
-	# it's likely to be more like Solaris than SunOS4.
-	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
-    sun4*:SunOS:*:*)
-	case "`/usr/bin/arch -k`" in
-	    Series*|S4*)
-		UNAME_RELEASE=`uname -v`
-		;;
-	esac
-	# Japanese Language versions have a version number like `4.1.3-JL'.
-	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
-	exit 0 ;;
-    sun3*:SunOS:*:*)
-	echo m68k-sun-sunos${UNAME_RELEASE}
-	exit 0 ;;
-    sun*:*:4.2BSD:*)
-	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
-	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
-	case "`/bin/arch`" in
-	    sun3)
-		echo m68k-sun-sunos${UNAME_RELEASE}
-		;;
-	    sun4)
-		echo sparc-sun-sunos${UNAME_RELEASE}
-		;;
-	esac
-	exit 0 ;;
-    aushp:SunOS:*:*)
-	echo sparc-auspex-sunos${UNAME_RELEASE}
-	exit 0 ;;
-    # The situation for MiNT is a little confusing.  The machine name
-    # can be virtually everything (everything which is not
-    # "atarist" or "atariste" at least should have a processor
-    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
-    # to the lowercase version "mint" (or "freemint").  Finally
-    # the system name "TOS" denotes a system which is actually not
-    # MiNT.  But MiNT is downward compatible to TOS, so this should
-    # be no problem.
-    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit 0 ;;
-    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
-        exit 0 ;;
-    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit 0 ;;
-    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-        echo m68k-milan-mint${UNAME_RELEASE}
-        exit 0 ;;
-    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-        echo m68k-hades-mint${UNAME_RELEASE}
-        exit 0 ;;
-    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-        echo m68k-unknown-mint${UNAME_RELEASE}
-        exit 0 ;;
-    m68k:machten:*:*)
-	echo m68k-apple-machten${UNAME_RELEASE}
-	exit 0 ;;
-    powerpc:machten:*:*)
-	echo powerpc-apple-machten${UNAME_RELEASE}
-	exit 0 ;;
-    RISC*:Mach:*:*)
-	echo mips-dec-mach_bsd4.3
-	exit 0 ;;
-    RISC*:ULTRIX:*:*)
-	echo mips-dec-ultrix${UNAME_RELEASE}
-	exit 0 ;;
-    VAX*:ULTRIX*:*:*)
-	echo vax-dec-ultrix${UNAME_RELEASE}
-	exit 0 ;;
-    2020:CLIX:*:* | 2430:CLIX:*:*)
-	echo clipper-intergraph-clix${UNAME_RELEASE}
-	exit 0 ;;
-    mips:*:*:UMIPS | mips:*:*:RISCos)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-#ifdef __cplusplus
-#include <stdio.h>  /* for printf() prototype */
-	int main (int argc, char *argv[]) {
-#else
-	int main (argc, argv) int argc; char *argv[]; {
-#endif
-	#if defined (host_mips) && defined (MIPSEB)
-	#if defined (SYSTYPE_SYSV)
-	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
-	#endif
-	#if defined (SYSTYPE_SVR4)
-	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
-	#endif
-	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
-	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
-	#endif
-	#endif
-	  exit (-1);
-	}
-EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c \
-	  && $dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
-	  && exit 0
-	echo mips-mips-riscos${UNAME_RELEASE}
-	exit 0 ;;
-    Motorola:PowerMAX_OS:*:*)
-	echo powerpc-motorola-powermax
-	exit 0 ;;
-    Motorola:*:4.3:PL8-*)
-	echo powerpc-harris-powermax
-	exit 0 ;;
-    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
-	echo powerpc-harris-powermax
-	exit 0 ;;
-    Night_Hawk:Power_UNIX:*:*)
-	echo powerpc-harris-powerunix
-	exit 0 ;;
-    m88k:CX/UX:7*:*)
-	echo m88k-harris-cxux7
-	exit 0 ;;
-    m88k:*:4*:R4*)
-	echo m88k-motorola-sysv4
-	exit 0 ;;
-    m88k:*:3*:R3*)
-	echo m88k-motorola-sysv3
-	exit 0 ;;
-    AViiON:dgux:*:*)
-        # DG/UX returns AViiON for all architectures
-        UNAME_PROCESSOR=`/usr/bin/uname -p`
-	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
-	then
-	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
-	       [ ${TARGET_BINARY_INTERFACE}x = x ]
-	    then
-		echo m88k-dg-dgux${UNAME_RELEASE}
-	    else
-		echo m88k-dg-dguxbcs${UNAME_RELEASE}
-	    fi
-	else
-	    echo i586-dg-dgux${UNAME_RELEASE}
-	fi
- 	exit 0 ;;
-    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
-	echo m88k-dolphin-sysv3
-	exit 0 ;;
-    M88*:*:R3*:*)
-	# Delta 88k system running SVR3
-	echo m88k-motorola-sysv3
-	exit 0 ;;
-    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
-	echo m88k-tektronix-sysv3
-	exit 0 ;;
-    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
-	echo m68k-tektronix-bsd
-	exit 0 ;;
-    *:IRIX*:*:*)
-	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
-	exit 0 ;;
-    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
-	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
-	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
-    i*86:AIX:*:*)
-	echo i386-ibm-aix
-	exit 0 ;;
-    ia64:AIX:*:*)
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
-	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
-	fi
-	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
-	exit 0 ;;
-    *:AIX:2:3)
-	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
-		eval $set_cc_for_build
-		sed 's/^		//' << EOF >$dummy.c
-		#include <sys/systemcfg.h>
-
-		main()
-			{
-			if (!__power_pc())
-				exit(1);
-			puts("powerpc-ibm-aix3.2.5");
-			exit(0);
-			}
-EOF
-		$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
-		echo rs6000-ibm-aix3.2.5
-	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
-		echo rs6000-ibm-aix3.2.4
-	else
-		echo rs6000-ibm-aix3.2
-	fi
-	exit 0 ;;
-    *:AIX:*:[45])
-	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
-	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
-		IBM_ARCH=rs6000
-	else
-		IBM_ARCH=powerpc
-	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
-	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
-	fi
-	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
-	exit 0 ;;
-    *:AIX:*:*)
-	echo rs6000-ibm-aix
-	exit 0 ;;
-    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
-	echo romp-ibm-bsd4.4
-	exit 0 ;;
-    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
-	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
-	exit 0 ;;                           # report: romp-ibm BSD 4.3
-    *:BOSX:*:*)
-	echo rs6000-bull-bosx
-	exit 0 ;;
-    DPX/2?00:B.O.S.:*:*)
-	echo m68k-bull-sysv3
-	exit 0 ;;
-    9000/[34]??:4.3bsd:1.*:*)
-	echo m68k-hp-bsd
-	exit 0 ;;
-    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
-	echo m68k-hp-bsd4.4
-	exit 0 ;;
-    9000/[34678]??:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	case "${UNAME_MACHINE}" in
-	    9000/31? )            HP_ARCH=m68000 ;;
-	    9000/[34]?? )         HP_ARCH=m68k ;;
-	    9000/[678][0-9][0-9])
-		if [ -x /usr/bin/getconf ]; then
-		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
-                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
-                    case "${sc_cpu_version}" in
-                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
-                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
-                      532)                      # CPU_PA_RISC2_0
-                        case "${sc_kernel_bits}" in
-                          32) HP_ARCH="hppa2.0n" ;;
-                          64) HP_ARCH="hppa2.0w" ;;
-			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
-                        esac ;;
-                    esac
-		fi
-		if [ "${HP_ARCH}" = "" ]; then
-		    eval $set_cc_for_build
-		    sed 's/^              //' << EOF >$dummy.c
-
-              #define _HPUX_SOURCE
-              #include <stdlib.h>
-              #include <unistd.h>
-
-              int main ()
-              {
-              #if defined(_SC_KERNEL_BITS)
-                  long bits = sysconf(_SC_KERNEL_BITS);
-              #endif
-                  long cpu  = sysconf (_SC_CPU_VERSION);
-
-                  switch (cpu)
-              	{
-              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
-              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
-              	case CPU_PA_RISC2_0:
-              #if defined(_SC_KERNEL_BITS)
-              	    switch (bits)
-              		{
-              		case 64: puts ("hppa2.0w"); break;
-              		case 32: puts ("hppa2.0n"); break;
-              		default: puts ("hppa2.0"); break;
-              		} break;
-              #else  /* !defined(_SC_KERNEL_BITS) */
-              	    puts ("hppa2.0"); break;
-              #endif
-              	default: puts ("hppa1.0"); break;
-              	}
-                  exit (0);
-              }
-EOF
-		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
-		    test -z "$HP_ARCH" && HP_ARCH=hppa
-		fi ;;
-	esac
-	if [ ${HP_ARCH} = "hppa2.0w" ]
-	then
-	    # avoid double evaluation of $set_cc_for_build
-	    test -n "$CC_FOR_BUILD" || eval $set_cc_for_build
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E -) | grep __LP64__ >/dev/null
-	    then
-		HP_ARCH="hppa2.0w"
-	    else
-		HP_ARCH="hppa64"
-	    fi
-	fi
-	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
-	exit 0 ;;
-    ia64:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	echo ia64-hp-hpux${HPUX_REV}
-	exit 0 ;;
-    3050*:HI-UX:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#include <unistd.h>
-	int
-	main ()
-	{
-	  long cpu = sysconf (_SC_CPU_VERSION);
-	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
-	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
-	     results, however.  */
-	  if (CPU_IS_PA_RISC (cpu))
-	    {
-	      switch (cpu)
-		{
-		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
-		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
-		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
-		  default: puts ("hppa-hitachi-hiuxwe2"); break;
-		}
-	    }
-	  else if (CPU_IS_HP_MC68K (cpu))
-	    puts ("m68k-hitachi-hiuxwe2");
-	  else puts ("unknown-hitachi-hiuxwe2");
-	  exit (0);
-	}
-EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
-	echo unknown-hitachi-hiuxwe2
-	exit 0 ;;
-    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
-	echo hppa1.1-hp-bsd
-	exit 0 ;;
-    9000/8??:4.3bsd:*:*)
-	echo hppa1.0-hp-bsd
-	exit 0 ;;
-    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
-	echo hppa1.0-hp-mpeix
-	exit 0 ;;
-    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
-	echo hppa1.1-hp-osf
-	exit 0 ;;
-    hp8??:OSF1:*:*)
-	echo hppa1.0-hp-osf
-	exit 0 ;;
-    i*86:OSF1:*:*)
-	if [ -x /usr/sbin/sysversion ] ; then
-	    echo ${UNAME_MACHINE}-unknown-osf1mk
-	else
-	    echo ${UNAME_MACHINE}-unknown-osf1
-	fi
-	exit 0 ;;
-    parisc*:Lites*:*:*)
-	echo hppa1.1-hp-lites
-	exit 0 ;;
-    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
-	echo c1-convex-bsd
-        exit 0 ;;
-    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-        exit 0 ;;
-    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
-	echo c34-convex-bsd
-        exit 0 ;;
-    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
-	echo c38-convex-bsd
-        exit 0 ;;
-    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
-	echo c4-convex-bsd
-        exit 0 ;;
-    CRAY*Y-MP:*:*:*)
-	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
-    CRAY*[A-Z]90:*:*:*)
-	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
-	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
-	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
-	      -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
-    CRAY*TS:*:*:*)
-	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
-    CRAY*T3E:*:*:*)
-	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
-    CRAY*SV1:*:*:*)
-	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
-    *:UNICOS/mp:*:*)
-	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
-    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
-        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-        exit 0 ;;
-    5000:UNIX_System_V:4.*:*)
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
-        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-	exit 0 ;;
-    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
-	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
-	exit 0 ;;
-    sparc*:BSD/OS:*:*)
-	echo sparc-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
-    *:BSD/OS:*:*)
-	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
-    *:FreeBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
-	exit 0 ;;
-    i*:CYGWIN*:*)
-	echo ${UNAME_MACHINE}-pc-cygwin
-	exit 0 ;;
-    i*:MINGW*:*)
-	echo ${UNAME_MACHINE}-pc-mingw32
-	exit 0 ;;
-    i*:PW*:*)
-	echo ${UNAME_MACHINE}-pc-pw32
-	exit 0 ;;
-    x86:Interix*:[34]*)
-	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
-	exit 0 ;;
-    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
-	echo i${UNAME_MACHINE}-pc-mks
-	exit 0 ;;
-    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
-	# UNAME_MACHINE based on the output of uname instead of i386?
-	echo i586-pc-interix
-	exit 0 ;;
-    i*:UWIN*:*)
-	echo ${UNAME_MACHINE}-pc-uwin
-	exit 0 ;;
-    p*:CYGWIN*:*)
-	echo powerpcle-unknown-cygwin
-	exit 0 ;;
-    prep*:SunOS:5.*:*)
-	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
-    *:GNU:*:*)
-	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
-	exit 0 ;;
-    *:GNU/*:*:*)
-	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
-	exit 0 ;;
-    i*86:Minix:*:*)
-	echo ${UNAME_MACHINE}-pc-minix
-	exit 0 ;;
-    arm*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
-    cris:Linux:*:*)
-	echo cris-axis-linux-gnu
-	exit 0 ;;
-    ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
-    m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
-    m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
-    mips:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#undef CPU
-	#undef mips
-	#undef mipsel
-	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mipsel
-	#else
-	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips
-	#else
-	CPU=
-	#endif
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
-	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
-	;;
-    mips64:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#undef CPU
-	#undef mips64
-	#undef mips64el
-	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mips64el
-	#else
-	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips64
-	#else
-	CPU=
-	#endif
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
-	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
-	;;
-    ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
-	exit 0 ;;
-    ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
-	exit 0 ;;
-    alpha:Linux:*:*)
-	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
-	  EV5)   UNAME_MACHINE=alphaev5 ;;
-	  EV56)  UNAME_MACHINE=alphaev56 ;;
-	  PCA56) UNAME_MACHINE=alphapca56 ;;
-	  PCA57) UNAME_MACHINE=alphapca56 ;;
-	  EV6)   UNAME_MACHINE=alphaev6 ;;
-	  EV67)  UNAME_MACHINE=alphaev67 ;;
-	  EV68*) UNAME_MACHINE=alphaev68 ;;
-        esac
-	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
-	exit 0 ;;
-    parisc:Linux:*:* | hppa:Linux:*:*)
-	# Look for CPU level
-	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
-	esac
-	exit 0 ;;
-    parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
-	exit 0 ;;
-    s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
-	exit 0 ;;
-    sh64*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
-    sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
-    sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
-    x86_64:Linux:*:*)
-	echo x86_64-unknown-linux-gnu
-	exit 0 ;;
-    i*86:Linux:*:*)
-	# The BFD linker knows what the default object file format is, so
-	# first see if it will tell us. cd to the root directory to prevent
-	# problems with other programs or directories called `ld' in the path.
-	# Set LC_ALL=C to ensure ld outputs messages in English.
-	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
-			 | sed -ne '/supported targets:/!d
-				    s/[ 	][ 	]*/ /g
-				    s/.*supported targets: *//
-				    s/ .*//
-				    p'`
-        case "$ld_supported_targets" in
-	  elf32-i386)
-		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
-		;;
-	  a.out-i386-linux)
-		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
-		exit 0 ;;
-	  coff-i386)
-		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
-		exit 0 ;;
-	  "")
-		# Either a pre-BFD a.out linker (linux-gnuoldld) or
-		# one that does not give us useful --help.
-		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
-		exit 0 ;;
-	esac
-	# Determine whether the default compiler is a.out or elf
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#include <features.h>
-	#ifdef __ELF__
-	# ifdef __GLIBC__
-	#  if __GLIBC__ >= 2
-	LIBC=gnu
-	#  else
-	LIBC=gnulibc1
-	#  endif
-	# else
-	LIBC=gnulibc1
-	# endif
-	#else
-	#ifdef __INTEL_COMPILER
-	LIBC=gnu
-	#else
-	LIBC=gnuaout
-	#endif
-	#endif
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
-	test x"${LIBC}" != x && echo "${UNAME_MACHINE}-pc-linux-${LIBC}" && exit 0
-	test x"${TENTATIVE}" != x && echo "${TENTATIVE}" && exit 0
-	;;
-    i*86:DYNIX/ptx:4*:*)
-	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
-	# earlier versions are messed up and put the nodename in both
-	# sysname and nodename.
-	echo i386-sequent-sysv4
-	exit 0 ;;
-    i*86:UNIX_SV:4.2MP:2.*)
-        # Unixware is an offshoot of SVR4, but it has its own version
-        # number series starting with 2...
-        # I am not positive that other SVR4 systems won't match this,
-	# I just have to hope.  -- rms.
-        # Use sysv4.2uw... so that sysv4* matches it.
-	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
-	exit 0 ;;
-    i*86:OS/2:*:*)
-	# If we were able to find `uname', then EMX Unix compatibility
-	# is probably installed.
-	echo ${UNAME_MACHINE}-pc-os2-emx
-	exit 0 ;;
-    i*86:XTS-300:*:STOP)
-	echo ${UNAME_MACHINE}-unknown-stop
-	exit 0 ;;
-    i*86:atheos:*:*)
-	echo ${UNAME_MACHINE}-unknown-atheos
-	exit 0 ;;
-	i*86:syllable:*:*)
-	echo ${UNAME_MACHINE}-pc-syllable
-	exit 0 ;;
-    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
-	echo i386-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
-    i*86:*DOS:*:*)
-	echo ${UNAME_MACHINE}-pc-msdosdjgpp
-	exit 0 ;;
-    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
-	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
-	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
-		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
-	else
-		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
-	fi
-	exit 0 ;;
-    i*86:*:5:[78]*)
-	case `/bin/uname -X | grep "^Machine"` in
-	    *486*)	     UNAME_MACHINE=i486 ;;
-	    *Pentium)	     UNAME_MACHINE=i586 ;;
-	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
-	esac
-	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
-	exit 0 ;;
-    i*86:*:3.2:*)
-	if test -f /usr/options/cb.name; then
-		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
-		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
-	elif /bin/uname -X 2>/dev/null >/dev/null ; then
-		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
-		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
-		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
-			&& UNAME_MACHINE=i586
-		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
-			&& UNAME_MACHINE=i686
-		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
-			&& UNAME_MACHINE=i686
-		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
-	else
-		echo ${UNAME_MACHINE}-pc-sysv32
-	fi
-	exit 0 ;;
-    pc:*:*:*)
-	# Left here for compatibility:
-        # uname -m prints for DJGPP always 'pc', but it prints nothing about
-        # the processor, so we play safe by assuming i386.
-	echo i386-pc-msdosdjgpp
-        exit 0 ;;
-    Intel:Mach:3*:*)
-	echo i386-pc-mach3
-	exit 0 ;;
-    paragon:*:*:*)
-	echo i860-intel-osf1
-	exit 0 ;;
-    i860:*:4.*:*) # i860-SVR4
-	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
-	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
-	else # Add other i860-SVR4 vendors below as they are discovered.
-	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
-	fi
-	exit 0 ;;
-    mini*:CTIX:SYS*5:*)
-	# "miniframe"
-	echo m68010-convergent-sysv
-	exit 0 ;;
-    mc68k:UNIX:SYSTEM5:3.51m)
-	echo m68k-convergent-sysv
-	exit 0 ;;
-    M680?0:D-NIX:5.3:*)
-	echo m68k-diab-dnix
-	exit 0 ;;
-    M68*:*:R3V[5678]*:*)
-	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
-    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0)
-	OS_REL=''
-	test -r /etc/.relid \
-	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
-	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
-	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
-    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
-        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-          && echo i486-ncr-sysv4 && exit 0 ;;
-    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
-	echo m68k-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
-    mc68030:UNIX_System_V:4.*:*)
-	echo m68k-atari-sysv4
-	exit 0 ;;
-    TSUNAMI:LynxOS:2.*:*)
-	echo sparc-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
-    rs6000:LynxOS:2.*:*)
-	echo rs6000-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
-    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
-	echo powerpc-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
-    SM[BE]S:UNIX_SV:*:*)
-	echo mips-dde-sysv${UNAME_RELEASE}
-	exit 0 ;;
-    RM*:ReliantUNIX-*:*:*)
-	echo mips-sni-sysv4
-	exit 0 ;;
-    RM*:SINIX-*:*:*)
-	echo mips-sni-sysv4
-	exit 0 ;;
-    *:SINIX-*:*:*)
-	if uname -p 2>/dev/null >/dev/null ; then
-		UNAME_MACHINE=`(uname -p) 2>/dev/null`
-		echo ${UNAME_MACHINE}-sni-sysv4
-	else
-		echo ns32k-sni-sysv
-	fi
-	exit 0 ;;
-    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
-                      # says <Richard.M.Bartel@ccMail.Census.GOV>
-        echo i586-unisys-sysv4
-        exit 0 ;;
-    *:UNIX_System_V:4*:FTX*)
-	# From Gerald Hewes <hewes@openmarket.com>.
-	# How about differentiating between stratus architectures? -djm
-	echo hppa1.1-stratus-sysv4
-	exit 0 ;;
-    *:*:*:FTX*)
-	# From seanf@swdc.stratus.com.
-	echo i860-stratus-sysv4
-	exit 0 ;;
-    *:VOS:*:*)
-	# From Paul.Green@stratus.com.
-	echo hppa1.1-stratus-vos
-	exit 0 ;;
-    mc68*:A/UX:*:*)
-	echo m68k-apple-aux${UNAME_RELEASE}
-	exit 0 ;;
-    news*:NEWS-OS:6*:*)
-	echo mips-sony-newsos6
-	exit 0 ;;
-    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
-	if [ -d /usr/nec ]; then
-	        echo mips-nec-sysv${UNAME_RELEASE}
-	else
-	        echo mips-unknown-sysv${UNAME_RELEASE}
-	fi
-        exit 0 ;;
-    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
-	echo powerpc-be-beos
-	exit 0 ;;
-    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
-	echo powerpc-apple-beos
-	exit 0 ;;
-    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
-	echo i586-pc-beos
-	exit 0 ;;
-    SX-4:SUPER-UX:*:*)
-	echo sx4-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
-    SX-5:SUPER-UX:*:*)
-	echo sx5-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
-    SX-6:SUPER-UX:*:*)
-	echo sx6-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
-    Power*:Rhapsody:*:*)
-	echo powerpc-apple-rhapsody${UNAME_RELEASE}
-	exit 0 ;;
-    *:Rhapsody:*:*)
-	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
-	exit 0 ;;
-    *:Darwin:*:*)
-	case `uname -p` in
-	    *86) UNAME_PROCESSOR=i686 ;;
-	    powerpc) UNAME_PROCESSOR=powerpc ;;
-	esac
-	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
-	exit 0 ;;
-    *:procnto*:*:* | *:QNX:[0123456789]*:*)
-	UNAME_PROCESSOR=`uname -p`
-	if test "$UNAME_PROCESSOR" = "x86"; then
-		UNAME_PROCESSOR=i386
-		UNAME_MACHINE=pc
-	fi
-	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
-	exit 0 ;;
-    *:QNX:*:4*)
-	echo i386-pc-qnx
-	exit 0 ;;
-    NSR-?:NONSTOP_KERNEL:*:*)
-	echo nsr-tandem-nsk${UNAME_RELEASE}
-	exit 0 ;;
-    *:NonStop-UX:*:*)
-	echo mips-compaq-nonstopux
-	exit 0 ;;
-    BS2000:POSIX*:*:*)
-	echo bs2000-siemens-sysv
-	exit 0 ;;
-    DS/*:UNIX_System_V:*:*)
-	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
-	exit 0 ;;
-    *:Plan9:*:*)
-	# "uname -m" is not consistent, so use $cputype instead. 386
-	# is converted to i386 for consistency with other x86
-	# operating systems.
-	if test "$cputype" = "386"; then
-	    UNAME_MACHINE=i386
-	else
-	    UNAME_MACHINE="$cputype"
-	fi
-	echo ${UNAME_MACHINE}-unknown-plan9
-	exit 0 ;;
-    *:TOPS-10:*:*)
-	echo pdp10-unknown-tops10
-	exit 0 ;;
-    *:TENEX:*:*)
-	echo pdp10-unknown-tenex
-	exit 0 ;;
-    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
-	echo pdp10-dec-tops20
-	exit 0 ;;
-    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
-	echo pdp10-xkl-tops20
-	exit 0 ;;
-    *:TOPS-20:*:*)
-	echo pdp10-unknown-tops20
-	exit 0 ;;
-    *:ITS:*:*)
-	echo pdp10-unknown-its
-	exit 0 ;;
-    SEI:*:*:SEIUX)
-        echo mips-sei-seiux${UNAME_RELEASE}
-	exit 0 ;;
-    *:DragonFly:*:*)
-	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
-	exit 0 ;;
-    *:*VMS:*:*)
-    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
-	case "${UNAME_MACHINE}" in
-	    A*) echo alpha-dec-vms && exit 0 ;;
-	    I*) echo ia64-dec-vms && exit 0 ;;
-	    V*) echo vax-dec-vms && exit 0 ;;
-	esac
-esac
-
-#echo '(No uname command or uname output not recognized.)' 1>&2
-#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
-
-eval $set_cc_for_build
-cat >$dummy.c <<EOF
-#ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
-#endif
-main ()
-{
-#if defined (sony)
-#if defined (MIPSEB)
-  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
-     I don't know....  */
-  printf ("mips-sony-bsd\n"); exit (0);
-#else
-#include <sys/param.h>
-  printf ("m68k-sony-newsos%s\n",
-#ifdef NEWSOS4
-          "4"
-#else
-	  ""
-#endif
-         ); exit (0);
-#endif
-#endif
-
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
-#endif
-
-#if defined (NeXT)
-#if !defined (__ARCHITECTURE__)
-#define __ARCHITECTURE__ "m68k"
-#endif
-  int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  if (version < 4)
-    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
-  else
-    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
-  exit (0);
-#endif
-
-#if defined (MULTIMAX) || defined (n16)
-#if defined (UMAXV)
-  printf ("ns32k-encore-sysv\n"); exit (0);
-#else
-#if defined (CMU)
-  printf ("ns32k-encore-mach\n"); exit (0);
-#else
-  printf ("ns32k-encore-bsd\n"); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (__386BSD__)
-  printf ("i386-pc-bsd\n"); exit (0);
-#endif
-
-#if defined (sequent)
-#if defined (i386)
-  printf ("i386-sequent-dynix\n"); exit (0);
-#endif
-#if defined (ns32000)
-  printf ("ns32k-sequent-dynix\n"); exit (0);
-#endif
-#endif
-
-#if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
-
-#endif
-
-#if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
-#endif
-
-#if defined (alliant) && defined (i860)
-  printf ("i860-alliant-bsd\n"); exit (0);
-#endif
-
-  exit (1);
-}
-EOF
-
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && $dummy && exit 0
-
-# Apollos put the system type in the environment.
-
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
-
-# Convex versions that predate uname can use getsysinfo(1)
-
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit 0 ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-	exit 0 ;;
-    c34*)
-	echo c34-convex-bsd
-	exit 0 ;;
-    c38*)
-	echo c38-convex-bsd
-	exit 0 ;;
-    c4*)
-	echo c4-convex-bsd
-	exit 0 ;;
-    esac
-fi
-
-cat >&2 <<EOF
-$0: unable to guess system type
-
-This script, last modified $timestamp, has failed to recognize
-the operating system you are using. It is advised that you
-download the most up to date version of the config scripts from
-
-    ftp://ftp.gnu.org/pub/gnu/config/
-
-If the version you run ($0) is already up to date, please
-send the following data and any information you think might be
-pertinent to <config-patches@gnu.org> in order to provide the needed
-information to handle your system.
-
-config.guess timestamp = $timestamp
-
-uname -m = `(uname -m) 2>/dev/null || echo unknown`
-uname -r = `(uname -r) 2>/dev/null || echo unknown`
-uname -s = `(uname -s) 2>/dev/null || echo unknown`
-uname -v = `(uname -v) 2>/dev/null || echo unknown`
-
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
-/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
-
-hostinfo               = `(hostinfo) 2>/dev/null`
-/bin/universe          = `(/bin/universe) 2>/dev/null`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
-/bin/arch              = `(/bin/arch) 2>/dev/null`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
-
-UNAME_MACHINE = ${UNAME_MACHINE}
-UNAME_RELEASE = ${UNAME_RELEASE}
-UNAME_SYSTEM  = ${UNAME_SYSTEM}
-UNAME_VERSION = ${UNAME_VERSION}
-EOF
-
-exit 1
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "timestamp='"
-# time-stamp-format: "%:y-%02m-%02d"
-# time-stamp-end: "'"
-# End:
diff --git a/main/editline/config.h.in b/main/editline/config.h.in
deleted file mode 100644
index 151fb22..0000000
--- a/main/editline/config.h.in
+++ /dev/null
@@ -1,21 +0,0 @@
-#undef SUNOS
-#undef CYGWIN
-
-#undef HAVE_SYS_CDEFS_H
-#undef HAVE_TERMCAP_H
-#undef HAVE_CURSES_H
-#undef HAVE_NCURSES_H
-#undef HAVE_TERM_H
-#undef HAVE_VIS_H
-#undef HAVE_ISSETUGID
-
-#undef HAVE_STRLCAT
-#undef HAVE_STRLCPY
-#undef HAVE_FGETLN
-#undef HAVE_STRVIS
-#undef HAVE_STRUNVIS
-
-#include "sys.h"
-#ifdef CYGWIN
-# include "cygdef.h"
-#endif
diff --git a/main/editline/config.sub b/main/editline/config.sub
deleted file mode 100755
index 838237e..0000000
--- a/main/editline/config.sub
+++ /dev/null
@@ -1,1412 +0,0 @@
-#! /bin/sh
-# Configuration validation subroutine script.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
-#   Free Software Foundation, Inc.
-
-timestamp='2001-09-14'
-
-# This file is (in principle) common to ALL GNU software.
-# The presence of a machine in this file suggests that SOME GNU software
-# can handle that machine.  It does not imply ALL GNU software can.
-#
-# This file is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330,
-# Boston, MA 02111-1307, USA.
-
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-# Please send patches to <config-patches@gnu.org>.
-#
-# Configuration subroutine to validate and canonicalize a configuration type.
-# Supply the specified configuration type as an argument.
-# If it is invalid, we print an error message on stderr and exit with code 1.
-# Otherwise, we print the canonical config type on stdout and succeed.
-
-# This file is supposed to be the same for all GNU packages
-# and recognize all the CPU types, system types and aliases
-# that are meaningful with *any* GNU software.
-# Each package is responsible for reporting which valid configurations
-# it does not support.  The user should be able to distinguish
-# a failure to support a valid configuration from a meaningless
-# configuration.
-
-# The goal of this file is to map all the various variations of a given
-# machine specification into a single specification in the form:
-#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
-# or in some cases, the newer four-part form:
-#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
-# It is wrong to echo any other type of specification.
-
-me=`echo "$0" | sed -e 's,.*/,,'`
-
-usage="\
-Usage: $0 [OPTION] CPU-MFR-OPSYS
-       $0 [OPTION] ALIAS
-
-Canonicalize a configuration name.
-
-Operation modes:
-  -h, --help         print this help, then exit
-  -t, --time-stamp   print date of last modification, then exit
-  -v, --version      print version number, then exit
-
-Report bugs and patches to <config-patches@gnu.org>."
-
-version="\
-GNU config.sub ($timestamp)
-
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
-Free Software Foundation, Inc.
-
-This is free software; see the source for copying conditions.  There is NO
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
-
-help="
-Try \`$me --help' for more information."
-
-# Parse command line
-while test $# -gt 0 ; do
-  case $1 in
-    --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit 0 ;;
-    --version | -v )
-       echo "$version" ; exit 0 ;;
-    --help | --h* | -h )
-       echo "$usage"; exit 0 ;;
-    -- )     # Stop option processing
-       shift; break ;;
-    - )	# Use stdin as input.
-       break ;;
-    -* )
-       echo "$me: invalid option $1$help"
-       exit 1 ;;
-
-    *local*)
-       # First pass through any local machine types.
-       echo $1
-       exit 0;;
-
-    * )
-       break ;;
-  esac
-done
-
-case $# in
- 0) echo "$me: missing argument$help" >&2
-    exit 1;;
- 1) ;;
- *) echo "$me: too many arguments$help" >&2
-    exit 1;;
-esac
-
-# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
-# Here we must recognize all the valid KERNEL-OS combinations.
-maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
-case $maybe_os in
-  nto-qnx* | linux-gnu* | storm-chaos* | os2-emx* | windows32-*)
-    os=-$maybe_os
-    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
-    ;;
-  *)
-    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
-    if [ $basic_machine != $1 ]
-    then os=`echo $1 | sed 's/.*-/-/'`
-    else os=; fi
-    ;;
-esac
-
-### Let's recognize common machines as not being operating systems so
-### that things like config.sub decstation-3100 work.  We also
-### recognize some manufacturers as not being operating systems, so we
-### can provide default operating systems below.
-case $os in
-	-sun*os*)
-		# Prevent following clause from handling this invalid input.
-		;;
-	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
-	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
-	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
-	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
-	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
-	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis)
-		os=
-		basic_machine=$1
-		;;
-	-sim | -cisco | -oki | -wec | -winbond)
-		os=
-		basic_machine=$1
-		;;
-	-scout)
-		;;
-	-wrs)
-		os=-vxworks
-		basic_machine=$1
-		;;
-	-chorusos*)
-		os=-chorusos
-		basic_machine=$1
-		;;
- 	-chorusrdb)
- 		os=-chorusrdb
-		basic_machine=$1
- 		;;
-	-hiux*)
-		os=-hiuxwe2
-		;;
-	-sco5)
-		os=-sco3.2v5
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco4)
-		os=-sco3.2v4
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco3.2.[4-9]*)
-		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco3.2v[4-9]*)
-		# Don't forget version if it is 3.2v4 or newer.
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco*)
-		os=-sco3.2v2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-udk*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-isc)
-		os=-isc2.2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-clix*)
-		basic_machine=clipper-intergraph
-		;;
-	-isc*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-lynx*)
-		os=-lynxos
-		;;
-	-ptx*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
-		;;
-	-windowsnt*)
-		os=`echo $os | sed -e 's/windowsnt/winnt/'`
-		;;
-	-psos*)
-		os=-psos
-		;;
-	-mint | -mint[0-9]*)
-		basic_machine=m68k-atari
-		os=-mint
-		;;
-esac
-
-# Decode aliases for certain CPU-COMPANY combinations.
-case $basic_machine in
-	# Recognize the basic CPU types without company name.
-	# Some are omitted here because they have special meanings below.
-	1750a | 580 \
-	| a29k \
-	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
-	| c4x | clipper \
-	| d10v | d30v | dsp16xx \
-	| fr30 \
-	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
-	| i370 | i860 | i960 | ia64 \
-	| m32r | m68000 | m68k | m88k | mcore \
-	| mips16 | mips64 | mips64el | mips64orion | mips64orionel \
-	| mips64vr4100 | mips64vr4100el | mips64vr4300 \
-	| mips64vr4300el | mips64vr5000 | mips64vr5000el \
-	| mipsbe | mipseb | mipsel | mipsle | mipstx39 | mipstx39el \
-	| mipsisa32 \
-	| mn10200 | mn10300 \
-	| ns16k | ns32k \
-	| openrisc \
-	| pdp10 | pdp11 | pj | pjl \
-	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
-	| pyramid \
-	| s390 | s390x \
-	| sh | sh[34] | sh[34]eb | shbe | shle \
-	| sparc | sparc64 | sparclet | sparclite | sparcv9 | sparcv9b \
-	| stormy16 | strongarm \
-	| tahoe | thumb | tic80 | tron \
-	| v850 \
-	| we32k \
-	| x86 | xscale \
-	| z8k)
-		basic_machine=$basic_machine-unknown
-		;;
-	m6811 | m68hc11 | m6812 | m68hc12)
-		# Motorola 68HC11/12.
-		basic_machine=$basic_machine-unknown
-		os=-none
-		;;
-	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
-		;;
-
-	# We use `pc' rather than `unknown'
-	# because (1) that's what they normally are, and
-	# (2) the word "unknown" tends to confuse beginning users.
-	i*86 | x86_64)
-	  basic_machine=$basic_machine-pc
-	  ;;
-	# Object if more than one company name word.
-	*-*-*)
-		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
-		exit 1
-		;;
-	# Recognize the basic CPU types with company name.
-	580-* \
-	| a29k-* \
-	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
-	| alphapca5[67]-* | arc-* \
-	| arm-*  | armbe-* | armle-* | armv*-* \
-	| avr-* \
-	| bs2000-* \
-	| c[123]* | c30-* | [cjt]90-* | c54x-* \
-	| clipper-* | cray2-* | cydra-* \
-	| d10v-* | d30v-* \
-	| elxsi-* \
-	| f30[01]-* | f700-* | fr30-* | fx80-* \
-	| h8300-* | h8500-* \
-	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
-	| i*86-* | i860-* | i960-* | ia64-* \
-	| m32r-* \
-	| m68000-* | m680[01234]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | mcore-* \
-	| mips-* | mips16-* | mips64-* | mips64el-* | mips64orion-* \
-	| mips64orionel-* | mips64vr4100-* | mips64vr4100el-* \
-	| mips64vr4300-* | mips64vr4300el-* | mipsbe-* | mipseb-* \
-	| mipsle-* | mipsel-* | mipstx39-* | mipstx39el-* \
-	| none-* | np1-* | ns16k-* | ns32k-* \
-	| orion-* \
-	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
-	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
-	| pyramid-* \
-	| romp-* | rs6000-* \
-	| s390-* | s390x-* \
-	| sh-* | sh[34]-* | sh[34]eb-* | shbe-* | shle-* \
-	| sparc-* | sparc64-* | sparc86x-* | sparclite-* \
-	| sparcv9-* | sparcv9b-* | stormy16-* | strongarm-* | sv1-* \
-	| t3e-* | tahoe-* | thumb-* | tic30-* | tic54x-* | tic80-* | tron-* \
-	| v850-* | vax-* \
-	| we32k-* \
-	| x86-* | x86_64-* | xmp-* | xps100-* | xscale-* \
-	| ymp-* \
-	| z8k-*)
-		;;
-	# Recognize the various machine names and aliases which stand
-	# for a CPU type and a company and sometimes even an OS.
-	386bsd)
-		basic_machine=i386-unknown
-		os=-bsd
-		;;
-	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
-		basic_machine=m68000-att
-		;;
-	3b*)
-		basic_machine=we32k-att
-		;;
-	a29khif)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-	adobe68k)
-		basic_machine=m68010-adobe
-		os=-scout
-		;;
-	alliant | fx80)
-		basic_machine=fx80-alliant
-		;;
-	altos | altos3068)
-		basic_machine=m68k-altos
-		;;
-	am29k)
-		basic_machine=a29k-none
-		os=-bsd
-		;;
-	amdahl)
-		basic_machine=580-amdahl
-		os=-sysv
-		;;
-	amiga | amiga-*)
-		basic_machine=m68k-unknown
-		;;
-	amigaos | amigados)
-		basic_machine=m68k-unknown
-		os=-amigaos
-		;;
-	amigaunix | amix)
-		basic_machine=m68k-unknown
-		os=-sysv4
-		;;
-	apollo68)
-		basic_machine=m68k-apollo
-		os=-sysv
-		;;
-	apollo68bsd)
-		basic_machine=m68k-apollo
-		os=-bsd
-		;;
-	aux)
-		basic_machine=m68k-apple
-		os=-aux
-		;;
-	balance)
-		basic_machine=ns32k-sequent
-		os=-dynix
-		;;
-	convex-c1)
-		basic_machine=c1-convex
-		os=-bsd
-		;;
-	convex-c2)
-		basic_machine=c2-convex
-		os=-bsd
-		;;
-	convex-c32)
-		basic_machine=c32-convex
-		os=-bsd
-		;;
-	convex-c34)
-		basic_machine=c34-convex
-		os=-bsd
-		;;
-	convex-c38)
-		basic_machine=c38-convex
-		os=-bsd
-		;;
-	cray | ymp)
-		basic_machine=ymp-cray
-		os=-unicos
-		;;
-	cray2)
-		basic_machine=cray2-cray
-		os=-unicos
-		;;
-	[cjt]90)
-		basic_machine=${basic_machine}-cray
-		os=-unicos
-		;;
-	crds | unos)
-		basic_machine=m68k-crds
-		;;
-	cris | cris-* | etrax*)
-		basic_machine=cris-axis
-		;;
-	da30 | da30-*)
-		basic_machine=m68k-da30
-		;;
-	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
-		basic_machine=mips-dec
-		;;
-	delta | 3300 | motorola-3300 | motorola-delta \
-	      | 3300-motorola | delta-motorola)
-		basic_machine=m68k-motorola
-		;;
-	delta88)
-		basic_machine=m88k-motorola
-		os=-sysv3
-		;;
-	dpx20 | dpx20-*)
-		basic_machine=rs6000-bull
-		os=-bosx
-		;;
-	dpx2* | dpx2*-bull)
-		basic_machine=m68k-bull
-		os=-sysv3
-		;;
-	ebmon29k)
-		basic_machine=a29k-amd
-		os=-ebmon
-		;;
-	elxsi)
-		basic_machine=elxsi-elxsi
-		os=-bsd
-		;;
-	encore | umax | mmax)
-		basic_machine=ns32k-encore
-		;;
-	es1800 | OSE68k | ose68k | ose | OSE)
-		basic_machine=m68k-ericsson
-		os=-ose
-		;;
-	fx2800)
-		basic_machine=i860-alliant
-		;;
-	genix)
-		basic_machine=ns32k-ns
-		;;
-	gmicro)
-		basic_machine=tron-gmicro
-		os=-sysv
-		;;
-	go32)
-		basic_machine=i386-pc
-		os=-go32
-		;;
-	h3050r* | hiux*)
-		basic_machine=hppa1.1-hitachi
-		os=-hiuxwe2
-		;;
-	h8300hms)
-		basic_machine=h8300-hitachi
-		os=-hms
-		;;
-	h8300xray)
-		basic_machine=h8300-hitachi
-		os=-xray
-		;;
-	h8500hms)
-		basic_machine=h8500-hitachi
-		os=-hms
-		;;
-	harris)
-		basic_machine=m88k-harris
-		os=-sysv3
-		;;
-	hp300-*)
-		basic_machine=m68k-hp
-		;;
-	hp300bsd)
-		basic_machine=m68k-hp
-		os=-bsd
-		;;
-	hp300hpux)
-		basic_machine=m68k-hp
-		os=-hpux
-		;;
-	hp3k9[0-9][0-9] | hp9[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hp9k2[0-9][0-9] | hp9k31[0-9])
-		basic_machine=m68000-hp
-		;;
-	hp9k3[2-9][0-9])
-		basic_machine=m68k-hp
-		;;
-	hp9k6[0-9][0-9] | hp6[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hp9k7[0-79][0-9] | hp7[0-79][0-9])
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k78[0-9] | hp78[0-9])
-		# FIXME: really hppa2.0-hp
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
-		# FIXME: really hppa2.0-hp
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[0-9][13679] | hp8[0-9][13679])
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[0-9][0-9] | hp8[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hppa-next)
-		os=-nextstep3
-		;;
-	hppaosf)
-		basic_machine=hppa1.1-hp
-		os=-osf
-		;;
-	hppro)
-		basic_machine=hppa1.1-hp
-		os=-proelf
-		;;
-	i370-ibm* | ibm*)
-		basic_machine=i370-ibm
-		;;
-# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
-	i*86v32)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv32
-		;;
-	i*86v4*)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv4
-		;;
-	i*86v)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv
-		;;
-	i*86sol2)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-solaris2
-		;;
-	i386mach)
-		basic_machine=i386-mach
-		os=-mach
-		;;
-	i386-vsta | vsta)
-		basic_machine=i386-unknown
-		os=-vsta
-		;;
-	iris | iris4d)
-		basic_machine=mips-sgi
-		case $os in
-		    -irix*)
-			;;
-		    *)
-			os=-irix4
-			;;
-		esac
-		;;
-	isi68 | isi)
-		basic_machine=m68k-isi
-		os=-sysv
-		;;
-	m88k-omron*)
-		basic_machine=m88k-omron
-		;;
-	magnum | m3230)
-		basic_machine=mips-mips
-		os=-sysv
-		;;
-	merlin)
-		basic_machine=ns32k-utek
-		os=-sysv
-		;;
-	mingw32)
-		basic_machine=i386-pc
-		os=-mingw32
-		;;
-	miniframe)
-		basic_machine=m68000-convergent
-		;;
-	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
-		basic_machine=m68k-atari
-		os=-mint
-		;;
-	mipsel*-linux*)
-		basic_machine=mipsel-unknown
-		os=-linux-gnu
-		;;
-	mips*-linux*)
-		basic_machine=mips-unknown
-		os=-linux-gnu
-		;;
-	mips3*-*)
-		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
-		;;
-	mips3*)
-		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
-		;;
-	mmix*)
-		basic_machine=mmix-knuth
-		os=-mmixware
-		;;
-	monitor)
-		basic_machine=m68k-rom68k
-		os=-coff
-		;;
-	msdos)
-		basic_machine=i386-pc
-		os=-msdos
-		;;
-	mvs)
-		basic_machine=i370-ibm
-		os=-mvs
-		;;
-	ncr3000)
-		basic_machine=i486-ncr
-		os=-sysv4
-		;;
-	netbsd386)
-		basic_machine=i386-unknown
-		os=-netbsd
-		;;
-	netwinder)
-		basic_machine=armv4l-rebel
-		os=-linux
-		;;
-	news | news700 | news800 | news900)
-		basic_machine=m68k-sony
-		os=-newsos
-		;;
-	news1000)
-		basic_machine=m68030-sony
-		os=-newsos
-		;;
-	news-3600 | risc-news)
-		basic_machine=mips-sony
-		os=-newsos
-		;;
-	necv70)
-		basic_machine=v70-nec
-		os=-sysv
-		;;
-	next | m*-next )
-		basic_machine=m68k-next
-		case $os in
-		    -nextstep* )
-			;;
-		    -ns2*)
-		      os=-nextstep2
-			;;
-		    *)
-		      os=-nextstep3
-			;;
-		esac
-		;;
-	nh3000)
-		basic_machine=m68k-harris
-		os=-cxux
-		;;
-	nh[45]000)
-		basic_machine=m88k-harris
-		os=-cxux
-		;;
-	nindy960)
-		basic_machine=i960-intel
-		os=-nindy
-		;;
-	mon960)
-		basic_machine=i960-intel
-		os=-mon960
-		;;
-	nonstopux)
-		basic_machine=mips-compaq
-		os=-nonstopux
-		;;
-	np1)
-		basic_machine=np1-gould
-		;;
-	nsr-tandem)
-		basic_machine=nsr-tandem
-		;;
-	op50n-* | op60c-*)
-		basic_machine=hppa1.1-oki
-		os=-proelf
-		;;
-	OSE68000 | ose68000)
-		basic_machine=m68000-ericsson
-		os=-ose
-		;;
-	os68k)
-		basic_machine=m68k-none
-		os=-os68k
-		;;
-	pa-hitachi)
-		basic_machine=hppa1.1-hitachi
-		os=-hiuxwe2
-		;;
-	paragon)
-		basic_machine=i860-intel
-		os=-osf
-		;;
-	pbd)
-		basic_machine=sparc-tti
-		;;
-	pbb)
-		basic_machine=m68k-tti
-		;;
-        pc532 | pc532-*)
-		basic_machine=ns32k-pc532
-		;;
-	pentium | p5 | k5 | k6 | nexgen)
-		basic_machine=i586-pc
-		;;
-	pentiumpro | p6 | 6x86 | athlon)
-		basic_machine=i686-pc
-		;;
-	pentiumii | pentium2)
-		basic_machine=i686-pc
-		;;
-	pentium-* | p5-* | k5-* | k6-* | nexgen-*)
-		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pentiumpro-* | p6-* | 6x86-* | athlon-*)
-		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pentiumii-* | pentium2-*)
-		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pn)
-		basic_machine=pn-gould
-		;;
-	power)	basic_machine=power-ibm
-		;;
-	ppc)	basic_machine=powerpc-unknown
-	        ;;
-	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ppcle | powerpclittle | ppc-le | powerpc-little)
-		basic_machine=powerpcle-unknown
-	        ;;
-	ppcle-* | powerpclittle-*)
-		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ppc64)	basic_machine=powerpc64-unknown
-	        ;;
-	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
-		basic_machine=powerpc64le-unknown
-	        ;;
-	ppc64le-* | powerpc64little-*)
-		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ps2)
-		basic_machine=i386-ibm
-		;;
-	pw32)
-		basic_machine=i586-unknown
-		os=-pw32
-		;;
-	rom68k)
-		basic_machine=m68k-rom68k
-		os=-coff
-		;;
-	rm[46]00)
-		basic_machine=mips-siemens
-		;;
-	rtpc | rtpc-*)
-		basic_machine=romp-ibm
-		;;
-	sa29200)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-	sequent)
-		basic_machine=i386-sequent
-		;;
-	sh)
-		basic_machine=sh-hitachi
-		os=-hms
-		;;
-	sparclite-wrs)
-		basic_machine=sparclite-wrs
-		os=-vxworks
-		;;
-	sps7)
-		basic_machine=m68k-bull
-		os=-sysv2
-		;;
-	spur)
-		basic_machine=spur-unknown
-		;;
-	st2000)
-		basic_machine=m68k-tandem
-		;;
-	stratus)
-		basic_machine=i860-stratus
-		os=-sysv4
-		;;
-	sun2)
-		basic_machine=m68000-sun
-		;;
-	sun2os3)
-		basic_machine=m68000-sun
-		os=-sunos3
-		;;
-	sun2os4)
-		basic_machine=m68000-sun
-		os=-sunos4
-		;;
-	sun3os3)
-		basic_machine=m68k-sun
-		os=-sunos3
-		;;
-	sun3os4)
-		basic_machine=m68k-sun
-		os=-sunos4
-		;;
-	sun4os3)
-		basic_machine=sparc-sun
-		os=-sunos3
-		;;
-	sun4os4)
-		basic_machine=sparc-sun
-		os=-sunos4
-		;;
-	sun4sol2)
-		basic_machine=sparc-sun
-		os=-solaris2
-		;;
-	sun3 | sun3-*)
-		basic_machine=m68k-sun
-		;;
-	sun4)
-		basic_machine=sparc-sun
-		;;
-	sun386 | sun386i | roadrunner)
-		basic_machine=i386-sun
-		;;
-	sv1)
-		basic_machine=sv1-cray
-		os=-unicos
-		;;
-	symmetry)
-		basic_machine=i386-sequent
-		os=-dynix
-		;;
-	t3e)
-		basic_machine=t3e-cray
-		os=-unicos
-		;;
-	tic54x | c54x*)
-		basic_machine=tic54x-unknown
-		os=-coff
-		;;
-	tx39)
-		basic_machine=mipstx39-unknown
-		;;
-	tx39el)
-		basic_machine=mipstx39el-unknown
-		;;
-	tower | tower-32)
-		basic_machine=m68k-ncr
-		;;
-	udi29k)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-	ultra3)
-		basic_machine=a29k-nyu
-		os=-sym1
-		;;
-	v810 | necv810)
-		basic_machine=v810-nec
-		os=-none
-		;;
-	vaxv)
-		basic_machine=vax-dec
-		os=-sysv
-		;;
-	vms)
-		basic_machine=vax-dec
-		os=-vms
-		;;
-	vpp*|vx|vx-*)
-               basic_machine=f301-fujitsu
-               ;;
-	vxworks960)
-		basic_machine=i960-wrs
-		os=-vxworks
-		;;
-	vxworks68)
-		basic_machine=m68k-wrs
-		os=-vxworks
-		;;
-	vxworks29k)
-		basic_machine=a29k-wrs
-		os=-vxworks
-		;;
-	w65*)
-		basic_machine=w65-wdc
-		os=-none
-		;;
-	w89k-*)
-		basic_machine=hppa1.1-winbond
-		os=-proelf
-		;;
-	windows32)
-		basic_machine=i386-pc
-		os=-windows32-msvcrt
-		;;
-	xmp)
-		basic_machine=xmp-cray
-		os=-unicos
-		;;
-        xps | xps100)
-		basic_machine=xps100-honeywell
-		;;
-	z8k-*-coff)
-		basic_machine=z8k-unknown
-		os=-sim
-		;;
-	none)
-		basic_machine=none-none
-		os=-none
-		;;
-
-# Here we handle the default manufacturer of certain CPU types.  It is in
-# some cases the only manufacturer, in others, it is the most popular.
-	w89k)
-		basic_machine=hppa1.1-winbond
-		;;
-	op50n)
-		basic_machine=hppa1.1-oki
-		;;
-	op60c)
-		basic_machine=hppa1.1-oki
-		;;
-	mips)
-		if [ x$os = x-linux-gnu ]; then
-			basic_machine=mips-unknown
-		else
-			basic_machine=mips-mips
-		fi
-		;;
-	romp)
-		basic_machine=romp-ibm
-		;;
-	rs6000)
-		basic_machine=rs6000-ibm
-		;;
-	vax)
-		basic_machine=vax-dec
-		;;
-	pdp10)
-		# there are many clones, so DEC is not a safe bet
-		basic_machine=pdp10-unknown
-		;;
-	pdp11)
-		basic_machine=pdp11-dec
-		;;
-	we32k)
-		basic_machine=we32k-att
-		;;
-	sh3 | sh4 | sh3eb | sh4eb)
-		basic_machine=sh-unknown
-		;;
-	sparc | sparcv9 | sparcv9b)
-		basic_machine=sparc-sun
-		;;
-        cydra)
-		basic_machine=cydra-cydrome
-		;;
-	orion)
-		basic_machine=orion-highlevel
-		;;
-	orion105)
-		basic_machine=clipper-highlevel
-		;;
-	mac | mpw | mac-mpw)
-		basic_machine=m68k-apple
-		;;
-	pmac | pmac-mpw)
-		basic_machine=powerpc-apple
-		;;
-	c4x*)
-		basic_machine=c4x-none
-		os=-coff
-		;;
-	*-unknown)
-		# Make sure to match an already-canonicalized machine name.
-		;;
-	*)
-		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
-		exit 1
-		;;
-esac
-
-# Here we canonicalize certain aliases for manufacturers.
-case $basic_machine in
-	*-digital*)
-		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
-		;;
-	*-commodore*)
-		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
-		;;
-	*)
-		;;
-esac
-
-# Decode manufacturer-specific aliases for certain operating systems.
-
-if [ x"$os" != x"" ]
-then
-case $os in
-        # First match some system type aliases
-        # that might get confused with valid system types.
-	# -solaris* is a basic system type, with this one exception.
-	-solaris1 | -solaris1.*)
-		os=`echo $os | sed -e 's|solaris1|sunos4|'`
-		;;
-	-solaris)
-		os=-solaris2
-		;;
-	-svr4*)
-		os=-sysv4
-		;;
-	-unixware*)
-		os=-sysv4.2uw
-		;;
-	-gnu/linux*)
-		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
-		;;
-	# First accept the basic system types.
-	# The portable systems comes first.
-	# Each alternative MUST END IN A *, to match a version number.
-	# -sysv* is not here because it comes later, after sysvr4.
-	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
-	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
-	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
-	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* \
-	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
-	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
-	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
-	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
-	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
-	      | -chorusos* | -chorusrdb* \
-	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
-	      | -interix* | -uwin* | -rhapsody* | -darwin* | -opened* \
-	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
-	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
-	      | -os2* | -vos*)
-	# Remember, each alternative MUST END IN *, to match a version number.
-		;;
-	-qnx*)
-		case $basic_machine in
-		    x86-* | i*86-*)
-			;;
-		    *)
-			os=-nto$os
-			;;
-		esac
-		;;
-	-nto*)
-		os=-nto-qnx
-		;;
-	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
-	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
-	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
-		;;
-	-mac*)
-		os=`echo $os | sed -e 's|mac|macos|'`
-		;;
-	-linux*)
-		os=`echo $os | sed -e 's|linux|linux-gnu|'`
-		;;
-	-sunos5*)
-		os=`echo $os | sed -e 's|sunos5|solaris2|'`
-		;;
-	-sunos6*)
-		os=`echo $os | sed -e 's|sunos6|solaris3|'`
-		;;
-	-opened*)
-		os=-openedition
-		;;
-	-wince*)
-		os=-wince
-		;;
-	-osfrose*)
-		os=-osfrose
-		;;
-	-osf*)
-		os=-osf
-		;;
-	-utek*)
-		os=-bsd
-		;;
-	-dynix*)
-		os=-bsd
-		;;
-	-acis*)
-		os=-aos
-		;;
-	-386bsd)
-		os=-bsd
-		;;
-	-ctix* | -uts*)
-		os=-sysv
-		;;
-	-ns2 )
-	        os=-nextstep2
-		;;
-	-nsk*)
-		os=-nsk
-		;;
-	# Preserve the version number of sinix5.
-	-sinix5.*)
-		os=`echo $os | sed -e 's|sinix|sysv|'`
-		;;
-	-sinix*)
-		os=-sysv4
-		;;
-	-triton*)
-		os=-sysv3
-		;;
-	-oss*)
-		os=-sysv3
-		;;
-	-svr4)
-		os=-sysv4
-		;;
-	-svr3)
-		os=-sysv3
-		;;
-	-sysvr4)
-		os=-sysv4
-		;;
-	# This must come after -sysvr4.
-	-sysv*)
-		;;
-	-ose*)
-		os=-ose
-		;;
-	-es1800*)
-		os=-ose
-		;;
-	-xenix)
-		os=-xenix
-		;;
-        -*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
-	        os=-mint
-		;;
-	-none)
-		;;
-	*)
-		# Get rid of the `-' at the beginning of $os.
-		os=`echo $os | sed 's/[^-]*-//'`
-		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
-		exit 1
-		;;
-esac
-else
-
-# Here we handle the default operating systems that come with various machines.
-# The value should be what the vendor currently ships out the door with their
-# machine or put another way, the most popular os provided with the machine.
-
-# Note that if you're going to try to match "-MANUFACTURER" here (say,
-# "-sun"), then you have to tell the case statement up towards the top
-# that MANUFACTURER isn't an operating system.  Otherwise, code above
-# will signal an error saying that MANUFACTURER isn't an operating
-# system, and we'll never get to this point.
-
-case $basic_machine in
-	*-acorn)
-		os=-riscix1.2
-		;;
-	arm*-rebel)
-		os=-linux
-		;;
-	arm*-semi)
-		os=-aout
-		;;
-	pdp10-*)
-		os=-tops20
-		;;
-        pdp11-*)
-		os=-none
-		;;
-	*-dec | vax-*)
-		os=-ultrix4.2
-		;;
-	m68*-apollo)
-		os=-domain
-		;;
-	i386-sun)
-		os=-sunos4.0.2
-		;;
-	m68000-sun)
-		os=-sunos3
-		# This also exists in the configure program, but was not the
-		# default.
-		# os=-sunos4
-		;;
-	m68*-cisco)
-		os=-aout
-		;;
-	mips*-cisco)
-		os=-elf
-		;;
-	mips*-*)
-		os=-elf
-		;;
-	*-tti)	# must be before sparc entry or we get the wrong os.
-		os=-sysv3
-		;;
-	sparc-* | *-sun)
-		os=-sunos4.1.1
-		;;
-	*-be)
-		os=-beos
-		;;
-	*-ibm)
-		os=-aix
-		;;
-	*-wec)
-		os=-proelf
-		;;
-	*-winbond)
-		os=-proelf
-		;;
-	*-oki)
-		os=-proelf
-		;;
-	*-hp)
-		os=-hpux
-		;;
-	*-hitachi)
-		os=-hiux
-		;;
-	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
-		os=-sysv
-		;;
-	*-cbm)
-		os=-amigaos
-		;;
-	*-dg)
-		os=-dgux
-		;;
-	*-dolphin)
-		os=-sysv3
-		;;
-	m68k-ccur)
-		os=-rtu
-		;;
-	m88k-omron*)
-		os=-luna
-		;;
-	*-next )
-		os=-nextstep
-		;;
-	*-sequent)
-		os=-ptx
-		;;
-	*-crds)
-		os=-unos
-		;;
-	*-ns)
-		os=-genix
-		;;
-	i370-*)
-		os=-mvs
-		;;
-	*-next)
-		os=-nextstep3
-		;;
-        *-gould)
-		os=-sysv
-		;;
-        *-highlevel)
-		os=-bsd
-		;;
-	*-encore)
-		os=-bsd
-		;;
-        *-sgi)
-		os=-irix
-		;;
-        *-siemens)
-		os=-sysv4
-		;;
-	*-masscomp)
-		os=-rtu
-		;;
-	f30[01]-fujitsu | f700-fujitsu)
-		os=-uxpv
-		;;
-	*-rom68k)
-		os=-coff
-		;;
-	*-*bug)
-		os=-coff
-		;;
-	*-apple)
-		os=-macos
-		;;
-	*-atari*)
-		os=-mint
-		;;
-	*)
-		os=-none
-		;;
-esac
-fi
-
-# Here we handle the case where we know the os, and the CPU type, but not the
-# manufacturer.  We pick the logical manufacturer.
-vendor=unknown
-case $basic_machine in
-	*-unknown)
-		case $os in
-			-riscix*)
-				vendor=acorn
-				;;
-			-sunos*)
-				vendor=sun
-				;;
-			-aix*)
-				vendor=ibm
-				;;
-			-beos*)
-				vendor=be
-				;;
-			-hpux*)
-				vendor=hp
-				;;
-			-mpeix*)
-				vendor=hp
-				;;
-			-hiux*)
-				vendor=hitachi
-				;;
-			-unos*)
-				vendor=crds
-				;;
-			-dgux*)
-				vendor=dg
-				;;
-			-luna*)
-				vendor=omron
-				;;
-			-genix*)
-				vendor=ns
-				;;
-			-mvs* | -opened*)
-				vendor=ibm
-				;;
-			-ptx*)
-				vendor=sequent
-				;;
-			-vxsim* | -vxworks*)
-				vendor=wrs
-				;;
-			-aux*)
-				vendor=apple
-				;;
-			-hms*)
-				vendor=hitachi
-				;;
-			-mpw* | -macos*)
-				vendor=apple
-				;;
-			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
-				vendor=atari
-				;;
-			-vos*)
-				vendor=stratus
-				;;
-		esac
-		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
-		;;
-esac
-
-echo $basic_machine$os
-exit 0
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "timestamp='"
-# time-stamp-format: "%:y-%02m-%02d"
-# time-stamp-end: "'"
-# End:
diff --git a/main/editline/configure b/main/editline/configure
deleted file mode 100755
index b5fc6e0..0000000
--- a/main/editline/configure
+++ /dev/null
@@ -1,2464 +0,0 @@
-#! /bin/sh
-
-# Guess values for system-dependent variables and create Makefiles.
-# Generated automatically using autoconf version 2.13 
-# Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
-#
-# This configure script is free software; the Free Software Foundation
-# gives unlimited permission to copy, distribute and modify it.
-
-# Defaults:
-ac_help=
-ac_default_prefix=/usr/local
-# Any additions from configure.in:
-ac_help="$ac_help
-  --disable-readline      Disable readline compatibility"
-ac_help="$ac_help
-  --enable-debug          Enable debugging code"
-
-# Initialize some variables set by options.
-# The variables have the same names as the options, with
-# dashes changed to underlines.
-build=NONE
-cache_file=./config.cache
-exec_prefix=NONE
-host=NONE
-no_create=
-nonopt=NONE
-no_recursion=
-prefix=NONE
-program_prefix=NONE
-program_suffix=NONE
-program_transform_name=s,x,x,
-silent=
-site=
-srcdir=
-target=NONE
-verbose=
-x_includes=NONE
-x_libraries=NONE
-bindir='${exec_prefix}/bin'
-sbindir='${exec_prefix}/sbin'
-libexecdir='${exec_prefix}/libexec'
-datadir='${prefix}/share'
-sysconfdir='${prefix}/etc'
-sharedstatedir='${prefix}/com'
-localstatedir='${prefix}/var'
-libdir='${exec_prefix}/lib'
-includedir='${prefix}/include'
-oldincludedir='/usr/include'
-infodir='${prefix}/info'
-mandir='${prefix}/man'
-
-# Initialize some other variables.
-subdirs=
-MFLAGS= MAKEFLAGS=
-SHELL=${CONFIG_SHELL-/bin/sh}
-# Maximum number of lines to put in a shell here document.
-ac_max_here_lines=12
-
-ac_prev=
-for ac_option
-do
-
-  # If the previous option needs an argument, assign it.
-  if test -n "$ac_prev"; then
-    eval "$ac_prev=\$ac_option"
-    ac_prev=
-    continue
-  fi
-
-  case "$ac_option" in
-  -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
-  *) ac_optarg= ;;
-  esac
-
-  # Accept the important Cygnus configure options, so we can diagnose typos.
-
-  case "$ac_option" in
-
-  -bindir | --bindir | --bindi | --bind | --bin | --bi)
-    ac_prev=bindir ;;
-  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
-    bindir="$ac_optarg" ;;
-
-  -build | --build | --buil | --bui | --bu)
-    ac_prev=build ;;
-  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
-    build="$ac_optarg" ;;
-
-  -cache-file | --cache-file | --cache-fil | --cache-fi \
-  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
-    ac_prev=cache_file ;;
-  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
-  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
-    cache_file="$ac_optarg" ;;
-
-  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
-    ac_prev=datadir ;;
-  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
-  | --da=*)
-    datadir="$ac_optarg" ;;
-
-  -disable-* | --disable-*)
-    ac_feature=`echo $ac_option|sed -e 's/-*disable-//'`
-    # Reject names that are not valid shell variable names.
-    if test -n "`echo $ac_feature| sed 's/[-a-zA-Z0-9_]//g'`"; then
-      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
-    fi
-    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
-    eval "enable_${ac_feature}=no" ;;
-
-  -enable-* | --enable-*)
-    ac_feature=`echo $ac_option|sed -e 's/-*enable-//' -e 's/=.*//'`
-    # Reject names that are not valid shell variable names.
-    if test -n "`echo $ac_feature| sed 's/[-_a-zA-Z0-9]//g'`"; then
-      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
-    fi
-    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
-    case "$ac_option" in
-      *=*) ;;
-      *) ac_optarg=yes ;;
-    esac
-    eval "enable_${ac_feature}='$ac_optarg'" ;;
-
-  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
-  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
-  | --exec | --exe | --ex)
-    ac_prev=exec_prefix ;;
-  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
-  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
-  | --exec=* | --exe=* | --ex=*)
-    exec_prefix="$ac_optarg" ;;
-
-  -gas | --gas | --ga | --g)
-    # Obsolete; use --with-gas.
-    with_gas=yes ;;
-
-  -help | --help | --hel | --he)
-    # Omit some internal or obsolete options to make the list less imposing.
-    # This message is too long to be a string in the A/UX 3.1 sh.
-    cat << EOF
-Usage: configure [options] [host]
-Options: [defaults in brackets after descriptions]
-Configuration:
-  --cache-file=FILE       cache test results in FILE
-  --help                  print this message
-  --no-create             do not create output files
-  --quiet, --silent       do not print \`checking...' messages
-  --version               print the version of autoconf that created configure
-Directory and file names:
-  --prefix=PREFIX         install architecture-independent files in PREFIX
-                          [$ac_default_prefix]
-  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
-                          [same as prefix]
-  --bindir=DIR            user executables in DIR [EPREFIX/bin]
-  --sbindir=DIR           system admin executables in DIR [EPREFIX/sbin]
-  --libexecdir=DIR        program executables in DIR [EPREFIX/libexec]
-  --datadir=DIR           read-only architecture-independent data in DIR
-                          [PREFIX/share]
-  --sysconfdir=DIR        read-only single-machine data in DIR [PREFIX/etc]
-  --sharedstatedir=DIR    modifiable architecture-independent data in DIR
-                          [PREFIX/com]
-  --localstatedir=DIR     modifiable single-machine data in DIR [PREFIX/var]
-  --libdir=DIR            object code libraries in DIR [EPREFIX/lib]
-  --includedir=DIR        C header files in DIR [PREFIX/include]
-  --oldincludedir=DIR     C header files for non-gcc in DIR [/usr/include]
-  --infodir=DIR           info documentation in DIR [PREFIX/info]
-  --mandir=DIR            man documentation in DIR [PREFIX/man]
-  --srcdir=DIR            find the sources in DIR [configure dir or ..]
-  --program-prefix=PREFIX prepend PREFIX to installed program names
-  --program-suffix=SUFFIX append SUFFIX to installed program names
-  --program-transform-name=PROGRAM
-                          run sed PROGRAM on installed program names
-EOF
-    cat << EOF
-Host type:
-  --build=BUILD           configure for building on BUILD [BUILD=HOST]
-  --host=HOST             configure for HOST [guessed]
-  --target=TARGET         configure for TARGET [TARGET=HOST]
-Features and packages:
-  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
-  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
-  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
-  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
-  --x-includes=DIR        X include files are in DIR
-  --x-libraries=DIR       X library files are in DIR
-EOF
-    if test -n "$ac_help"; then
-      echo "--enable and --with options recognized:$ac_help"
-    fi
-    exit 0 ;;
-
-  -host | --host | --hos | --ho)
-    ac_prev=host ;;
-  -host=* | --host=* | --hos=* | --ho=*)
-    host="$ac_optarg" ;;
-
-  -includedir | --includedir | --includedi | --included | --include \
-  | --includ | --inclu | --incl | --inc)
-    ac_prev=includedir ;;
-  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
-  | --includ=* | --inclu=* | --incl=* | --inc=*)
-    includedir="$ac_optarg" ;;
-
-  -infodir | --infodir | --infodi | --infod | --info | --inf)
-    ac_prev=infodir ;;
-  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
-    infodir="$ac_optarg" ;;
-
-  -libdir | --libdir | --libdi | --libd)
-    ac_prev=libdir ;;
-  -libdir=* | --libdir=* | --libdi=* | --libd=*)
-    libdir="$ac_optarg" ;;
-
-  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
-  | --libexe | --libex | --libe)
-    ac_prev=libexecdir ;;
-  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
-  | --libexe=* | --libex=* | --libe=*)
-    libexecdir="$ac_optarg" ;;
-
-  -localstatedir | --localstatedir | --localstatedi | --localstated \
-  | --localstate | --localstat | --localsta | --localst \
-  | --locals | --local | --loca | --loc | --lo)
-    ac_prev=localstatedir ;;
-  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
-  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
-  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
-    localstatedir="$ac_optarg" ;;
-
-  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
-    ac_prev=mandir ;;
-  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
-    mandir="$ac_optarg" ;;
-
-  -nfp | --nfp | --nf)
-    # Obsolete; use --without-fp.
-    with_fp=no ;;
-
-  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-  | --no-cr | --no-c)
-    no_create=yes ;;
-
-  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
-    no_recursion=yes ;;
-
-  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
-  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
-  | --oldin | --oldi | --old | --ol | --o)
-    ac_prev=oldincludedir ;;
-  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
-  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
-  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
-    oldincludedir="$ac_optarg" ;;
-
-  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
-    ac_prev=prefix ;;
-  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
-    prefix="$ac_optarg" ;;
-
-  -program-prefix | --program-prefix | --program-prefi | --program-pref \
-  | --program-pre | --program-pr | --program-p)
-    ac_prev=program_prefix ;;
-  -program-prefix=* | --program-prefix=* | --program-prefi=* \
-  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
-    program_prefix="$ac_optarg" ;;
-
-  -program-suffix | --program-suffix | --program-suffi | --program-suff \
-  | --program-suf | --program-su | --program-s)
-    ac_prev=program_suffix ;;
-  -program-suffix=* | --program-suffix=* | --program-suffi=* \
-  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
-    program_suffix="$ac_optarg" ;;
-
-  -program-transform-name | --program-transform-name \
-  | --program-transform-nam | --program-transform-na \
-  | --program-transform-n | --program-transform- \
-  | --program-transform | --program-transfor \
-  | --program-transfo | --program-transf \
-  | --program-trans | --program-tran \
-  | --progr-tra | --program-tr | --program-t)
-    ac_prev=program_transform_name ;;
-  -program-transform-name=* | --program-transform-name=* \
-  | --program-transform-nam=* | --program-transform-na=* \
-  | --program-transform-n=* | --program-transform-=* \
-  | --program-transform=* | --program-transfor=* \
-  | --program-transfo=* | --program-transf=* \
-  | --program-trans=* | --program-tran=* \
-  | --progr-tra=* | --program-tr=* | --program-t=*)
-    program_transform_name="$ac_optarg" ;;
-
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil)
-    silent=yes ;;
-
-  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
-    ac_prev=sbindir ;;
-  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
-  | --sbi=* | --sb=*)
-    sbindir="$ac_optarg" ;;
-
-  -sharedstatedir | --sharedstatedir | --sharedstatedi \
-  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
-  | --sharedst | --shareds | --shared | --share | --shar \
-  | --sha | --sh)
-    ac_prev=sharedstatedir ;;
-  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
-  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
-  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
-  | --sha=* | --sh=*)
-    sharedstatedir="$ac_optarg" ;;
-
-  -site | --site | --sit)
-    ac_prev=site ;;
-  -site=* | --site=* | --sit=*)
-    site="$ac_optarg" ;;
-
-  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
-    ac_prev=srcdir ;;
-  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
-    srcdir="$ac_optarg" ;;
-
-  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
-  | --syscon | --sysco | --sysc | --sys | --sy)
-    ac_prev=sysconfdir ;;
-  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
-  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
-    sysconfdir="$ac_optarg" ;;
-
-  -target | --target | --targe | --targ | --tar | --ta | --t)
-    ac_prev=target ;;
-  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
-    target="$ac_optarg" ;;
-
-  -v | -verbose | --verbose | --verbos | --verbo | --verb)
-    verbose=yes ;;
-
-  -version | --version | --versio | --versi | --vers)
-    echo "configure generated by autoconf version 2.13"
-    exit 0 ;;
-
-  -with-* | --with-*)
-    ac_package=`echo $ac_option|sed -e 's/-*with-//' -e 's/=.*//'`
-    # Reject names that are not valid shell variable names.
-    if test -n "`echo $ac_package| sed 's/[-_a-zA-Z0-9]//g'`"; then
-      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
-    fi
-    ac_package=`echo $ac_package| sed 's/-/_/g'`
-    case "$ac_option" in
-      *=*) ;;
-      *) ac_optarg=yes ;;
-    esac
-    eval "with_${ac_package}='$ac_optarg'" ;;
-
-  -without-* | --without-*)
-    ac_package=`echo $ac_option|sed -e 's/-*without-//'`
-    # Reject names that are not valid shell variable names.
-    if test -n "`echo $ac_package| sed 's/[-a-zA-Z0-9_]//g'`"; then
-      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
-    fi
-    ac_package=`echo $ac_package| sed 's/-/_/g'`
-    eval "with_${ac_package}=no" ;;
-
-  --x)
-    # Obsolete; use --with-x.
-    with_x=yes ;;
-
-  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
-  | --x-incl | --x-inc | --x-in | --x-i)
-    ac_prev=x_includes ;;
-  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
-  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
-    x_includes="$ac_optarg" ;;
-
-  -x-libraries | --x-libraries | --x-librarie | --x-librari \
-  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
-    ac_prev=x_libraries ;;
-  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
-  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
-    x_libraries="$ac_optarg" ;;
-
-  -*) { echo "configure: error: $ac_option: invalid option; use --help to show usage" 1>&2; exit 1; }
-    ;;
-
-  *)
-    if test -n "`echo $ac_option| sed 's/[-a-z0-9.]//g'`"; then
-      echo "configure: warning: $ac_option: invalid host type" 1>&2
-    fi
-    if test "x$nonopt" != xNONE; then
-      { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; }
-    fi
-    nonopt="$ac_option"
-    ;;
-
-  esac
-done
-
-if test -n "$ac_prev"; then
-  { echo "configure: error: missing argument to --`echo $ac_prev | sed 's/_/-/g'`" 1>&2; exit 1; }
-fi
-
-trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
-
-# File descriptor usage:
-# 0 standard input
-# 1 file creation
-# 2 errors and warnings
-# 3 some systems may open it to /dev/tty
-# 4 used on the Kubota Titan
-# 6 checking for... messages and results
-# 5 compiler messages saved in config.log
-if test "$silent" = yes; then
-  exec 6>/dev/null
-else
-  exec 6>&1
-fi
-exec 5>./config.log
-
-echo "\
-This file contains any messages produced by compilers while
-running configure, to aid debugging if configure makes a mistake.
-" 1>&5
-
-# Strip out --no-create and --no-recursion so they do not pile up.
-# Also quote any args containing shell metacharacters.
-ac_configure_args=
-for ac_arg
-do
-  case "$ac_arg" in
-  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-  | --no-cr | --no-c) ;;
-  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
-  *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
-  ac_configure_args="$ac_configure_args '$ac_arg'" ;;
-  *) ac_configure_args="$ac_configure_args $ac_arg" ;;
-  esac
-done
-
-# NLS nuisances.
-# Only set these to C if already set.  These must not be set unconditionally
-# because not all systems understand e.g. LANG=C (notably SCO).
-# Fixing LC_MESSAGES prevents Solaris sh from translating var values in `set'!
-# Non-C LC_CTYPE values break the ctype check.
-if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
-if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
-if test "${LC_MESSAGES+set}" = set; then LC_MESSAGES=C; export LC_MESSAGES; fi
-if test "${LC_CTYPE+set}"    = set; then LC_CTYPE=C;    export LC_CTYPE;    fi
-
-# confdefs.h avoids OS command line length limits that DEFS can exceed.
-rm -rf conftest* confdefs.h
-# AIX cpp loses on an empty file, so make sure it contains at least a newline.
-echo > confdefs.h
-
-# A filename unique to this package, relative to the directory that
-# configure is in, which we can look for to find out if srcdir is correct.
-ac_unique_file=Makefile.in
-
-# Find the source files, if location was not specified.
-if test -z "$srcdir"; then
-  ac_srcdir_defaulted=yes
-  # Try the directory containing this script, then its parent.
-  ac_prog=$0
-  ac_confdir=`echo $ac_prog|sed 's%/[^/][^/]*$%%'`
-  test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
-  srcdir=$ac_confdir
-  if test ! -r $srcdir/$ac_unique_file; then
-    srcdir=..
-  fi
-else
-  ac_srcdir_defaulted=no
-fi
-if test ! -r $srcdir/$ac_unique_file; then
-  if test "$ac_srcdir_defaulted" = yes; then
-    { echo "configure: error: can not find sources in $ac_confdir or .." 1>&2; exit 1; }
-  else
-    { echo "configure: error: can not find sources in $srcdir" 1>&2; exit 1; }
-  fi
-fi
-srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`
-
-# Prefer explicitly selected file to automatically selected ones.
-if test -z "$CONFIG_SITE"; then
-  if test "x$prefix" != xNONE; then
-    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
-  else
-    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
-  fi
-fi
-for ac_site_file in $CONFIG_SITE; do
-  if test -r "$ac_site_file"; then
-    echo "loading site script $ac_site_file"
-    . "$ac_site_file"
-  fi
-done
-
-if test -r "$cache_file"; then
-  echo "loading cache $cache_file"
-  . $cache_file
-else
-  echo "creating cache $cache_file"
-  > $cache_file
-fi
-
-ac_ext=c
-# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
-ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
-cross_compiling=$ac_cv_prog_cc_cross
-
-ac_exeext=
-ac_objext=o
-if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
-  # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
-  if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
-    ac_n= ac_c='
-' ac_t='	'
-  else
-    ac_n=-n ac_c= ac_t=
-  fi
-else
-  ac_n= ac_c='\c' ac_t=
-fi
-
-
-
-CFLAGS=$CFLAGS
-# Extract the first word of "gcc", so it can be a program name with args.
-set dummy gcc; ac_word=$2
-echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:534: checking for $ac_word" >&5
-if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
-  ac_dummy="$PATH"
-  for ac_dir in $ac_dummy; do
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
-      ac_cv_prog_CC="gcc"
-      break
-    fi
-  done
-  IFS="$ac_save_ifs"
-fi
-fi
-CC="$ac_cv_prog_CC"
-if test -n "$CC"; then
-  echo "$ac_t""$CC" 1>&6
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-if test -z "$CC"; then
-  # Extract the first word of "cc", so it can be a program name with args.
-set dummy cc; ac_word=$2
-echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:564: checking for $ac_word" >&5
-if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
-  ac_prog_rejected=no
-  ac_dummy="$PATH"
-  for ac_dir in $ac_dummy; do
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
-      if test "$ac_dir/$ac_word" = "/usr/ucb/cc"; then
-        ac_prog_rejected=yes
-	continue
-      fi
-      ac_cv_prog_CC="cc"
-      break
-    fi
-  done
-  IFS="$ac_save_ifs"
-if test $ac_prog_rejected = yes; then
-  # We found a bogon in the path, so make sure we never use it.
-  set dummy $ac_cv_prog_CC
-  shift
-  if test $# -gt 0; then
-    # We chose a different compiler from the bogus one.
-    # However, it has the same basename, so the bogon will be chosen
-    # first if we set CC to just the basename; use the full file name.
-    shift
-    set dummy "$ac_dir/$ac_word" "$@"
-    shift
-    ac_cv_prog_CC="$@"
-  fi
-fi
-fi
-fi
-CC="$ac_cv_prog_CC"
-if test -n "$CC"; then
-  echo "$ac_t""$CC" 1>&6
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-  if test -z "$CC"; then
-    case "`uname -s`" in
-    *win32* | *WIN32*)
-      # Extract the first word of "cl", so it can be a program name with args.
-set dummy cl; ac_word=$2
-echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:615: checking for $ac_word" >&5
-if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
-  ac_dummy="$PATH"
-  for ac_dir in $ac_dummy; do
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
-      ac_cv_prog_CC="cl"
-      break
-    fi
-  done
-  IFS="$ac_save_ifs"
-fi
-fi
-CC="$ac_cv_prog_CC"
-if test -n "$CC"; then
-  echo "$ac_t""$CC" 1>&6
-else
-  echo "$ac_t""no" 1>&6
-fi
- ;;
-    esac
-  fi
-  test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
-fi
-
-echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:647: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
-
-ac_ext=c
-# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
-ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
-cross_compiling=$ac_cv_prog_cc_cross
-
-cat > conftest.$ac_ext << EOF
-
-#line 658 "configure"
-#include "confdefs.h"
-
-main(){return(0);}
-EOF
-if { (eval echo configure:663: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  ac_cv_prog_cc_works=yes
-  # If we can't run a trivial program, we are probably using a cross compiler.
-  if (./conftest; exit) 2>/dev/null; then
-    ac_cv_prog_cc_cross=no
-  else
-    ac_cv_prog_cc_cross=yes
-  fi
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  ac_cv_prog_cc_works=no
-fi
-rm -fr conftest*
-ac_ext=c
-# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
-ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
-cross_compiling=$ac_cv_prog_cc_cross
-
-echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
-if test $ac_cv_prog_cc_works = no; then
-  { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
-fi
-echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:689: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
-echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
-cross_compiling=$ac_cv_prog_cc_cross
-
-echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:694: checking whether we are using GNU C" >&5
-if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.c <<EOF
-#ifdef __GNUC__
-  yes;
-#endif
-EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:703: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
-  ac_cv_prog_gcc=yes
-else
-  ac_cv_prog_gcc=no
-fi
-fi
-
-echo "$ac_t""$ac_cv_prog_gcc" 1>&6
-
-if test $ac_cv_prog_gcc = yes; then
-  GCC=yes
-else
-  GCC=
-fi
-
-ac_test_CFLAGS="${CFLAGS+set}"
-ac_save_CFLAGS="$CFLAGS"
-CFLAGS=
-echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:722: checking whether ${CC-cc} accepts -g" >&5
-if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  echo 'void f(){}' > conftest.c
-if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
-  ac_cv_prog_cc_g=yes
-else
-  ac_cv_prog_cc_g=no
-fi
-rm -f conftest*
-
-fi
-
-echo "$ac_t""$ac_cv_prog_cc_g" 1>&6
-if test "$ac_test_CFLAGS" = set; then
-  CFLAGS="$ac_save_CFLAGS"
-elif test $ac_cv_prog_cc_g = yes; then
-  if test "$GCC" = yes; then
-    CFLAGS="-g -O2"
-  else
-    CFLAGS="-g"
-  fi
-else
-  if test "$GCC" = yes; then
-    CFLAGS="-O2"
-  else
-    CFLAGS=
-  fi
-fi
-
-if test "x$CFLAGS" = "x" ; then
-  no_CFLAGS="yes"
-fi
-if test "x$no_CFLAGS" = "xyes" -a "x$GCC" = "xyes" ; then
-	CFLAGS="-Wall -pipe -g3"
-fi
-A_CFLAGS=""
-
-S_CFLAGS="-fPIC -DPIC"
-
-echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:764: checking how to run the C preprocessor" >&5
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-if eval "test \"`echo '$''{'ac_cv_prog_CPP'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-    # This must be in double quotes, not single quotes, because CPP may get
-  # substituted into the Makefile and "${CC-cc}" will confuse make.
-  CPP="${CC-cc} -E"
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp.
-  cat > conftest.$ac_ext <<EOF
-#line 779 "configure"
-#include "confdefs.h"
-#include <assert.h>
-Syntax Error
-EOF
-ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:785: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
-ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
-if test -z "$ac_err"; then
-  :
-else
-  echo "$ac_err" >&5
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  CPP="${CC-cc} -E -traditional-cpp"
-  cat > conftest.$ac_ext <<EOF
-#line 796 "configure"
-#include "confdefs.h"
-#include <assert.h>
-Syntax Error
-EOF
-ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:802: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
-ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
-if test -z "$ac_err"; then
-  :
-else
-  echo "$ac_err" >&5
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  CPP="${CC-cc} -nologo -E"
-  cat > conftest.$ac_ext <<EOF
-#line 813 "configure"
-#include "confdefs.h"
-#include <assert.h>
-Syntax Error
-EOF
-ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:819: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
-ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
-if test -z "$ac_err"; then
-  :
-else
-  echo "$ac_err" >&5
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  CPP=/lib/cpp
-fi
-rm -f conftest*
-fi
-rm -f conftest*
-fi
-rm -f conftest*
-  ac_cv_prog_CPP="$CPP"
-fi
-  CPP="$ac_cv_prog_CPP"
-else
-  ac_cv_prog_CPP="$CPP"
-fi
-echo "$ac_t""$CPP" 1>&6
-
-for ac_prog in mawk gawk nawk awk
-do
-# Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:848: checking for $ac_word" >&5
-if eval "test \"`echo '$''{'ac_cv_prog_AWK'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test -n "$AWK"; then
-  ac_cv_prog_AWK="$AWK" # Let the user override the test.
-else
-  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
-  ac_dummy="$PATH"
-  for ac_dir in $ac_dummy; do
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
-      ac_cv_prog_AWK="$ac_prog"
-      break
-    fi
-  done
-  IFS="$ac_save_ifs"
-fi
-fi
-AWK="$ac_cv_prog_AWK"
-if test -n "$AWK"; then
-  echo "$ac_t""$AWK" 1>&6
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-test -n "$AWK" && break
-done
-
-
-ac_aux_dir=
-for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
-  if test -f $ac_dir/install-sh; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f $ac_dir/install.sh; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  fi
-done
-if test -z "$ac_aux_dir"; then
-  { echo "configure: error: can not find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." 1>&2; exit 1; }
-fi
-ac_config_guess=$ac_aux_dir/config.guess
-ac_config_sub=$ac_aux_dir/config.sub
-ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.
-
-
-# Make sure we can run config.sub.
-if ${CONFIG_SHELL-/bin/sh} $ac_config_sub sun4 >/dev/null 2>&1; then :
-else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
-fi
-
-echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:904: checking host system type" >&5
-
-host_alias=$host
-case "$host_alias" in
-NONE)
-  case $nonopt in
-  NONE)
-    if host_alias=`${CONFIG_SHELL-/bin/sh} $ac_config_guess`; then :
-    else { echo "configure: error: can not guess host type; you must specify one" 1>&2; exit 1; }
-    fi ;;
-  *) host_alias=$nonopt ;;
-  esac ;;
-esac
-
-host=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $host_alias`
-host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
-host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
-host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
-echo "$ac_t""$host" 1>&6
-
-case "${host}" in
-  *-*-darwin*)
-	CFLAGS="$CFLAGS -fno-common -no-cpp-precomp"
-	ABI="macho"
-	;;
-  *-*-freebsd*)
-	ABI="elf"
-	;;
-  *-*-linux* | *cygwin*)
-	if echo ${host} | grep -q cygwin ; then \
-		echo "cygwin detected"; \
-		S_CFLAGS=""; \
-		echo "/* cygdef.h. Generated automatically by configure. */ 
-#ifndef _CYGDEF_H_
-#define _CYGDEF_H_ 1
-#include <sys/ioctl.h>
-#define __linux__ 1
- 
-
-typedef void (*sig_t)(int);
- 
-
-#endif /* _CYGDEF_H_ */" > cygdef.h; \
-	echo "
- #define CYGWIN 1
-" > confdefs.h; \
-	fi
-	ABI="elf"
-	;;
-  *-*-netbsd*)
-	echo $ac_n "checking ABI""... $ac_c" 1>&6
-echo "configure:955: checking ABI" >&5
-	cat > conftest.$ac_ext <<EOF
-#line 957 "configure"
-#include "confdefs.h"
-#ifdef __ELF__
-  yes
-#endif
-
-EOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "yes" >/dev/null 2>&1; then
-  rm -rf conftest*
-  ABI="elf"
-else
-  rm -rf conftest*
-  ABI="aout"
-fi
-rm -f conftest*
-
-	echo "$ac_t""$ABI" 1>&6
-	;;
-  *-*-solaris2*)
-	ABI="elf"
-	cat >> confdefs.h <<\EOF
-#define SUNOS 1
-EOF
-
-	;;
-  *)
-	echo "$ac_t""Unsupported operating system: ${host}" 1>&6
-	ABI="elf"
-	;;
-esac
-
-# Find a good install program.  We prefer a C program (faster),
-# so one script is as good as another.  But avoid the broken or
-# incompatible versions:
-# SysV /etc/install, /usr/sbin/install
-# SunOS /usr/etc/install
-# IRIX /sbin/install
-# AIX /bin/install
-# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
-# AFS /usr/afsws/bin/install, which mishandles nonexistent args
-# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
-# ./install, which can be erroneously created by make from ./install.sh.
-echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
-echo "configure:1001: checking for a BSD compatible install" >&5
-if test -z "$INSTALL"; then
-if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-    IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS=":"
-  for ac_dir in $PATH; do
-    # Account for people who put trailing slashes in PATH elements.
-    case "$ac_dir/" in
-    /|./|.//|/etc/*|/usr/sbin/*|/usr/etc/*|/sbin/*|/usr/afsws/bin/*|/usr/ucb/*) ;;
-    *)
-      # OSF1 and SCO ODT 3.0 have their own names for install.
-      # Don't use installbsd from OSF since it installs stuff as root
-      # by default.
-      for ac_prog in ginstall scoinst install; do
-        if test -f $ac_dir/$ac_prog; then
-	  if test $ac_prog = install &&
-            grep dspmsg $ac_dir/$ac_prog >/dev/null 2>&1; then
-	    # AIX install.  It has an incompatible calling convention.
-	    :
-	  else
-	    ac_cv_path_install="$ac_dir/$ac_prog -c"
-	    break 2
-	  fi
-	fi
-      done
-      ;;
-    esac
-  done
-  IFS="$ac_save_IFS"
-
-fi
-  if test "${ac_cv_path_install+set}" = set; then
-    INSTALL="$ac_cv_path_install"
-  else
-    # As a last resort, use the slow shell script.  We don't cache a
-    # path for INSTALL within a source directory, because that will
-    # break other packages using the cache if that directory is
-    # removed, or if the path is relative.
-    INSTALL="$ac_install_sh"
-  fi
-fi
-echo "$ac_t""$INSTALL" 1>&6
-
-# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
-# It thinks the first close brace ends the variable substitution.
-test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
-
-test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'
-
-test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
-
-# Extract the first word of "ranlib", so it can be a program name with args.
-set dummy ranlib; ac_word=$2
-echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1056: checking for $ac_word" >&5
-if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test -n "$RANLIB"; then
-  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
-else
-  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
-  ac_dummy="$PATH"
-  for ac_dir in $ac_dummy; do
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
-      ac_cv_prog_RANLIB="ranlib"
-      break
-    fi
-  done
-  IFS="$ac_save_ifs"
-  test -z "$ac_cv_prog_RANLIB" && ac_cv_prog_RANLIB=":"
-fi
-fi
-RANLIB="$ac_cv_prog_RANLIB"
-if test -n "$RANLIB"; then
-  echo "$ac_t""$RANLIB" 1>&6
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-for ac_prog in ar gar
-do
-# Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1088: checking for $ac_word" >&5
-if eval "test \"`echo '$''{'ac_cv_path_AR'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  case "$AR" in
-  /*)
-  ac_cv_path_AR="$AR" # Let the user override the test with a path.
-  ;;
-  ?:/*)			 
-  ac_cv_path_AR="$AR" # Let the user override the test with a dos path.
-  ;;
-  *)
-  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
-  ac_dummy="$PATH"
-  for ac_dir in $ac_dummy; do 
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
-      ac_cv_path_AR="$ac_dir/$ac_word"
-      break
-    fi
-  done
-  IFS="$ac_save_ifs"
-  ;;
-esac
-fi
-AR="$ac_cv_path_AR"
-if test -n "$AR"; then
-  echo "$ac_t""$AR" 1>&6
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-test -n "$AR" && break
-done
-
-
-echo $ac_n "checking for tgetent in -ltermcap""... $ac_c" 1>&6
-echo "configure:1125: checking for tgetent in -ltermcap" >&5
-ac_lib_var=`echo termcap'_'tgetent | sed 'y%./+-%__p_%'`
-if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  ac_save_LIBS="$LIBS"
-LIBS="-ltermcap  $LIBS"
-cat > conftest.$ac_ext <<EOF
-#line 1133 "configure"
-#include "confdefs.h"
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char tgetent();
-
-int main() {
-tgetent()
-; return 0; }
-EOF
-if { (eval echo configure:1144: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=no"
-fi
-rm -f conftest*
-LIBS="$ac_save_LIBS"
-
-fi
-if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_lib=HAVE_LIB`echo termcap | sed -e 's/[^a-zA-Z0-9_]/_/g' \
-    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_lib 1
-EOF
-
-  LIBS="-ltermcap $LIBS"
-
-else
-  echo "$ac_t""no" 1>&6
-\
-  echo $ac_n "checking for tgetent in -ltinfo""... $ac_c" 1>&6
-echo "configure:1171: checking for tgetent in -ltinfo" >&5
-ac_lib_var=`echo tinfo'_'tgetent | sed 'y%./+-%__p_%'`
-if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  ac_save_LIBS="$LIBS"
-LIBS="-ltinfo  $LIBS"
-cat > conftest.$ac_ext <<EOF
-#line 1179 "configure"
-#include "confdefs.h"
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char tgetent();
-
-int main() {
-tgetent()
-; return 0; }
-EOF
-if { (eval echo configure:1190: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=no"
-fi
-rm -f conftest*
-LIBS="$ac_save_LIBS"
-
-fi
-if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_lib=HAVE_LIB`echo tinfo | sed -e 's/^a-zA-Z0-9_/_/g' \
-    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_lib 1
-EOF
-
-  LIBS="-ltinfo $LIBS"
-
-else
-  echo "$ac_t""no" 1>&6
-\
-    echo $ac_n "checking for tgetent in -lcurses""... $ac_c" 1>&6
-echo "configure:1217: checking for tgetent in -lcurses" >&5
-ac_lib_var=`echo curses'_'tgetent | sed 'y%./+-%__p_%'`
-if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  ac_save_LIBS="$LIBS"
-LIBS="-lcurses  $LIBS"
-cat > conftest.$ac_ext <<EOF
-#line 1225 "configure"
-#include "confdefs.h"
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char tgetent();
-
-int main() {
-tgetent()
-; return 0; }
-EOF
-if { (eval echo configure:1236: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=no"
-fi
-rm -f conftest*
-LIBS="$ac_save_LIBS"
-
-fi
-if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_lib=HAVE_LIB`echo curses | sed -e 's/^a-zA-Z0-9_/_/g' \
-    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_lib 1
-EOF
-
-  LIBS="-lcurses $LIBS"
-
-else
-  echo "$ac_t""no" 1>&6
-\
-      echo $ac_n "checking for tgetent in -lncurses""... $ac_c" 1>&6
-echo "configure:1263: checking for tgetent in -lncurses" >&5
-ac_lib_var=`echo ncurses'_'tgetent | sed 'y%./+-%__p_%'`
-if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  ac_save_LIBS="$LIBS"
-LIBS="-lncurses  $LIBS"
-cat > conftest.$ac_ext <<EOF
-#line 1271 "configure"
-#include "confdefs.h"
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char tgetent();
-
-int main() {
-tgetent()
-; return 0; }
-EOF
-if { (eval echo configure:1282: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=no"
-fi
-rm -f conftest*
-LIBS="$ac_save_LIBS"
-
-fi
-if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_lib=HAVE_LIB`echo ncurses | sed -e 's/^a-zA-Z0-9_/_/g' \
-    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_lib 1
-EOF
-
-  LIBS="-lncurses $LIBS"
-
-else
-  echo "$ac_t""no" 1>&6
-\
-        { echo "configure: error: termcap support not found" 1>&2; exit 1; }
-fi
-
-fi
-
-fi
-
-fi
-
-
-for ac_hdr in termcap.h
-do
-ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
-echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:1322: checking for $ac_hdr" >&5
-if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1327 "configure"
-#include "confdefs.h"
-#include <$ac_hdr>
-EOF
-ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1332: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
-ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
-if test -z "$ac_err"; then
-  rm -rf conftest*
-  eval "ac_cv_header_$ac_safe=yes"
-else
-  echo "$ac_err" >&5
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_header_$ac_safe=no"
-fi
-rm -f conftest*
-fi
-if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_hdr 1
-EOF
- 
-else
-  echo "$ac_t""no" 1>&6
-\
-  for ac_hdr in term.h
-do
-ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
-echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:1360: checking for $ac_hdr" >&5
-if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1365 "configure"
-#include "confdefs.h"
-#include <$ac_hdr>
-EOF
-ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1370: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
-ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
-if test -z "$ac_err"; then
-  rm -rf conftest*
-  eval "ac_cv_header_$ac_safe=yes"
-else
-  echo "$ac_err" >&5
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_header_$ac_safe=no"
-fi
-rm -f conftest*
-fi
-if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_hdr 1
-EOF
- 
-else
-  echo "$ac_t""no" 1>&6
-\
-    echo "$ac_t""Need term.h since termcap.h is missing" 1>&6
-fi
-done
-
-  for ac_hdr in curses.h
-do
-ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
-echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:1402: checking for $ac_hdr" >&5
-if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1407 "configure"
-#include "confdefs.h"
-#include <$ac_hdr>
-EOF
-ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1412: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
-ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
-if test -z "$ac_err"; then
-  rm -rf conftest*
-  eval "ac_cv_header_$ac_safe=yes"
-else
-  echo "$ac_err" >&5
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_header_$ac_safe=no"
-fi
-rm -f conftest*
-fi
-if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_hdr 1
-EOF
- 
-else
-  echo "$ac_t""no" 1>&6
-\
-    for ac_hdr in ncurses.h
-do
-ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
-echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:1440: checking for $ac_hdr" >&5
-if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1445 "configure"
-#include "confdefs.h"
-#include <$ac_hdr>
-EOF
-ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1450: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
-ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
-if test -z "$ac_err"; then
-  rm -rf conftest*
-  eval "ac_cv_header_$ac_safe=yes"
-else
-  echo "$ac_err" >&5
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_header_$ac_safe=no"
-fi
-rm -f conftest*
-fi
-if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_hdr 1
-EOF
- 
-else
-  echo "$ac_t""no" 1>&6
-\
-      echo "$ac_t""Need curses.h or ncurses.h" 1>&6
-fi
-done
-
-fi
-done
-
-fi
-done
-
-
-for ac_hdr in sys/cdefs.h vis.h
-do
-ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
-echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:1489: checking for $ac_hdr" >&5
-if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1494 "configure"
-#include "confdefs.h"
-#include <$ac_hdr>
-EOF
-ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1499: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
-ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
-if test -z "$ac_err"; then
-  rm -rf conftest*
-  eval "ac_cv_header_$ac_safe=yes"
-else
-  echo "$ac_err" >&5
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_header_$ac_safe=no"
-fi
-rm -f conftest*
-fi
-if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_hdr 1
-EOF
- 
-else
-  echo "$ac_t""no" 1>&6
-fi
-done
-
-
-for ac_func in issetugid
-do
-echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:1529: checking for $ac_func" >&5
-if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1534 "configure"
-#include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func(); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char $ac_func();
-
-int main() {
-
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
-#else
-$ac_func();
-#endif
-
-; return 0; }
-EOF
-if { (eval echo configure:1557: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=no"
-fi
-rm -f conftest*
-fi
-
-if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_func 1
-EOF
- 
-else
-  echo "$ac_t""no" 1>&6
-fi
-done
-
-for ac_func in fgetln
-do
-echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:1584: checking for $ac_func" >&5
-if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1589 "configure"
-#include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func(); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char $ac_func();
-
-int main() {
-
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
-#else
-$ac_func();
-#endif
-
-; return 0; }
-EOF
-if { (eval echo configure:1612: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=no"
-fi
-rm -f conftest*
-fi
-
-if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_func 1
-EOF
- 
-else
-  echo "$ac_t""no" 1>&6
-CCSRCS="$CCSRCS np/fgetln.c"
-fi
-done
-
-for ac_func in strvis
-do
-echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:1640: checking for $ac_func" >&5
-if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1645 "configure"
-#include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func(); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char $ac_func();
-
-int main() {
-
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
-#else
-$ac_func();
-#endif
-
-; return 0; }
-EOF
-if { (eval echo configure:1668: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=no"
-fi
-rm -f conftest*
-fi
-
-if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_func 1
-EOF
- 
-else
-  echo "$ac_t""no" 1>&6
-CCSRCS="$CCSRCS np/vis.c"
-fi
-done
-
-for ac_func in strunvis
-do
-echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:1696: checking for $ac_func" >&5
-if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1701 "configure"
-#include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func(); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char $ac_func();
-
-int main() {
-
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
-#else
-$ac_func();
-#endif
-
-; return 0; }
-EOF
-if { (eval echo configure:1724: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=no"
-fi
-rm -f conftest*
-fi
-
-if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_func 1
-EOF
- 
-else
-  echo "$ac_t""no" 1>&6
-CCSRCS="$CCSRCS np/unvis.c"
-fi
-done
-
-for ac_func in strlcpy
-do
-echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:1752: checking for $ac_func" >&5
-if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1757 "configure"
-#include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func(); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char $ac_func();
-
-int main() {
-
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
-#else
-$ac_func();
-#endif
-
-; return 0; }
-EOF
-if { (eval echo configure:1780: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=no"
-fi
-rm -f conftest*
-fi
-
-if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_func 1
-EOF
- 
-else
-  echo "$ac_t""no" 1>&6
-CCSRCS="$CCSRCS np/strlcpy.c"
-fi
-done
-
-for ac_func in strlcat
-do
-echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:1808: checking for $ac_func" >&5
-if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1813 "configure"
-#include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func(); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char $ac_func();
-
-int main() {
-
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
-#else
-$ac_func();
-#endif
-
-; return 0; }
-EOF
-if { (eval echo configure:1836: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_func_$ac_func=no"
-fi
-rm -f conftest*
-fi
-
-if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
-  cat >> confdefs.h <<EOF
-#define $ac_tr_func 1
-EOF
- 
-else
-  echo "$ac_t""no" 1>&6
-CCSRCS="$CCSRCS np/strlcat.c"
-fi
-done
-
-
-cat > conftest.$ac_ext <<EOF
-#line 1863 "configure"
-#include "confdefs.h"
-#include <sys/cdefs.h>
-#ifdef __RCSID
-  yes
-#endif
-
-EOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "yes" >/dev/null 2>&1; then
-  :
-else
-  rm -rf conftest*
-  CPPFLAGS="$CPPFLAGS '-D__RCSID(x)='"
-fi
-rm -f conftest*
-
-
-cat > conftest.$ac_ext <<EOF
-#line 1882 "configure"
-#include "confdefs.h"
-#include <sys/cdefs.h>
-#ifdef __COPYRIGHT
-  yes
-#endif
-
-EOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "yes" >/dev/null 2>&1; then
-  :
-else
-  rm -rf conftest*
-  CPPFLAGS="$CPPFLAGS '-D__COPYRIGHT(x)='"
-fi
-rm -f conftest*
-
-
-cat > conftest.$ac_ext <<EOF
-#line 1901 "configure"
-#include "confdefs.h"
-#include <sys/cdefs.h>
-#ifdef __RENAME
-  yes
-#endif
-
-EOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "yes" >/dev/null 2>&1; then
-  :
-else
-  rm -rf conftest*
-  CPPFLAGS="$CPPFLAGS '-D__RENAME(x)='"
-fi
-rm -f conftest*
-
-
-cat > conftest.$ac_ext <<EOF
-#line 1920 "configure"
-#include "confdefs.h"
-#include <sys/cdefs.h>
-#ifdef _DIAGASSERT
-  yes
-#endif
-
-EOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "yes" >/dev/null 2>&1; then
-  :
-else
-  rm -rf conftest*
-  CPPFLAGS="$CPPFLAGS '-D_DIAGASSERT(x)='"
-fi
-rm -f conftest*
-
-
-# Check whether --enable-readline or --disable-readline was given.
-if test "${enable_readline+set}" = set; then
-  enableval="$enable_readline"
-  if test "x$enable_readline" != "xyes" ; then
-  enable_readline="no"
-fi
-
-else
-  enable_readline="yes"
-
-fi
-
-
-# Check whether --enable-debug or --disable-debug was given.
-if test "${enable_debug+set}" = set; then
-  enableval="$enable_debug"
-  if test "x$enable_debug" != "xyes" ; then
-  enable_debug="no"
-fi
-
-else
-  enable_debug="no"
-
-fi
-
-if test "x$enable_debug" = "xyes" ; then
-  CPPFLAGS="$CPPFLAGS -DDEBUG_TTY -DDEBUG_KEY -DDEBUG_READ -DDEBUG"
-  CPPFLAGS="$CPPFLAGS -DDEBUG_REFRESH -DDEBUG_PASTE"
-else
-  CFLAGS="$CFLAGS -O"
-fi
-
-
-
-ACSRCS="common.c emacs.c vi.c"
-BCSRCS="chared.c el.c hist.c key.c map.c parse.c prompt.c read.c refresh.c search.c sig.c term.c tty.c"
-CCSRCS="$CCSRCS history.c tokenizer.c"
-
-AGCSRCS="fcns.c help.c"
-BGCSRCS="editline.c"
-
-HDRS="chared.h el.h hist.h key.h map.h parse.h prompt.h refresh.h search.h sig.h sys.h term.h tokenizer.h tty.h"
-
-IHDRS="histedit.h"
-
-IHDR_LINKS=
-
-AGHDRS="common.h emacs.h vi.h"
-BGHDRS="fcns.h help.h"
-
-HDR_DIRS="include"
-
-MAN3="editline.3"
-MAN5="editrc.5"
-
-MAN3_LINKS=
-for i in  el_init.3 el_end.3 el_reset.3 el_gets.3 el_getc.3 el_push.3 \
-          el_parse.3 el_set.3 el_get.3 el_source.3 el_resize.3 el_line.3 \
-	  el_insertstr.3 el_deletestr.3 history_init.3 history_end.3 \
-	  history.3 ; do
-  MAN3_LINKS="$MAN3_LINKS editline.3 $i"
-done
-
-MAN_DIRS="man/man3 man/man5"
-
-LIB_DIRS="lib"
-LIB_MAJOR="2"
-LIB_MINOR="6"
-LIB_A="libedit.a"
-LIB_A_LINKS=
-
-if test "x$ABI" = "xelf" ; then
-  LIB_S="libedit.so.$LIB_MAJOR"
-  LIB_S_LINK="libedit.so"
-  LIB_S_LINKS="$LIB_S $LIB_S_LINK"
-  S_LDFLAGS="-shared"
-elif test "x$ABI" = "xaout" ; then
-  LIB_S="libedit.so.$LIB_MAJOR.$LIB_MINOR"
-  LIB_S_LINKS=
-  S_LDFLAGS="-shared"
-elif test "x$ABI" = "xmacho" ; then
-  S_LDFLAGS="-shared"
-  LIB_S="libedit.$LIB_MAJOR.dylib"
-  LIB_S_LINK="libedit.dylib"
-  LIB_S_LINKS="$LIB_S $LIB_S_LINK"
-  if test "x$prefix" = "xNONE" ; then
-    S_LDFLAGS="-undefined suppress -flat_namespace -dynamiclib -compatibility_version $LIB_MAJOR -current_version $LIB_MAJOR -install_name /usr/local/lib/$LIB_S"
-  else
-    S_LDFLAGS="-undefined suppress -flat_namespace -dynamiclib -compatibility_version $LIB_MAJOR -current_version $LIB_MAJOR -install_name $prefix/lib/$LIB_S"
-  fi
-fi
-
-TEST="TEST/test"
-TCSRCS="TEST/test.c"
-
-if test "x$enable_readline" = "xyes" ; then
-  CCSRCS="$CCSRCS readline.c"
-  IHDRS="$IHDRS readline/readline.h"
-  IHDR_LINKS="readline.h readline/history.h"
-  HDR_DIRS="$HDR_DIRS include/readline"
-  LIB_A_LINKS="$LIB_A_LINKS libedit.a libreadline.a"
-  if test "x$ABI" = "xelf" ; then
-    LIB_S_LINKS="$LIB_S_LINKS $LIB_S_LINK libreadline.so"
-  elif test "x$ABI" = "xaout" ; then
-    LIB_S_LINKS="$LIB_S_LINKS $LIB_S libreadline.so.$LIB_MAJOR.$LIB_MINOR"
-  elif test "x$ABI" = "xmacho" ; then
-    LIB_S_LINKS="$LIB_S_LINKS $LIB_S_LINK libreadline.dylib"
-  fi
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-trap '' 1 2 15
-cat > confcache <<\EOF
-# This file is a shell script that caches the results of configure
-# tests run on this system so they can be shared between configure
-# scripts and configure runs.  It is not useful on other systems.
-# If it contains results you don't want to keep, you may remove or edit it.
-#
-# By default, configure uses ./config.cache as the cache file,
-# creating it if it does not exist already.  You can give configure
-# the --cache-file=FILE option to use a different cache file; that is
-# what configure does when it calls configure scripts in
-# subdirectories, so they share the cache.
-# Giving --cache-file=/dev/null disables caching, for debugging configure.
-# config.status only pays attention to the cache file if you give it the
-# --recheck option to rerun configure.
-#
-EOF
-# The following way of writing the cache mishandles newlines in values,
-# but we know of no workaround that is simple, portable, and efficient.
-# So, don't put newlines in cache variables' values.
-# Ultrix sh set writes to stderr and can't be redirected directly,
-# and sets the high bit in the cache file unless we assign to the vars.
-(set) 2>&1 |
-  case `(ac_space=' '; set | grep ac_space) 2>&1` in
-  *ac_space=\ *)
-    # `set' does not quote correctly, so add quotes (double-quote substitution
-    # turns \\\\ into \\, and sed turns \\ into \).
-    sed -n \
-      -e "s/'/'\\\\''/g" \
-      -e "s/^\\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\\)=\\(.*\\)/\\1=\${\\1='\\2'}/p"
-    ;;
-  *)
-    # `set' quotes correctly as required by POSIX, so do not add quotes.
-    sed -n -e 's/^\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\)=\(.*\)/\1=${\1=\2}/p'
-    ;;
-  esac >> confcache
-if cmp -s $cache_file confcache; then
-  :
-else
-  if test -w $cache_file; then
-    echo "updating cache $cache_file"
-    cat confcache > $cache_file
-  else
-    echo "not updating unwritable cache $cache_file"
-  fi
-fi
-rm -f confcache
-
-trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
-
-test "x$prefix" = xNONE && prefix=$ac_default_prefix
-# Let make expand exec_prefix.
-test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
-
-# Any assignment to VPATH causes Sun make to only execute
-# the first set of double-colon rules, so remove it if not needed.
-# If there is a colon in the path, we need to keep it.
-if test "x$srcdir" = x.; then
-  ac_vpsub='/^[ 	]*VPATH[ 	]*=[^:]*$/d'
-fi
-
-trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15
-
-DEFS=-DHAVE_CONFIG_H
-
-# Without the "./", some shells look in PATH for config.status.
-: ${CONFIG_STATUS=./config.status}
-
-echo creating $CONFIG_STATUS
-rm -f $CONFIG_STATUS
-cat > $CONFIG_STATUS <<EOF
-#! /bin/sh
-# Generated automatically by configure.
-# Run this file to recreate the current configuration.
-# This directory was configured as follows,
-# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
-#
-# $0 $ac_configure_args
-#
-# Compiler output produced by configure, useful for debugging
-# configure, is in ./config.log if it exists.
-
-ac_cs_usage="Usage: $CONFIG_STATUS [--recheck] [--version] [--help]"
-for ac_option
-do
-  case "\$ac_option" in
-  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
-    echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
-    exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
-  -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
-    echo "$CONFIG_STATUS generated by autoconf version 2.13"
-    exit 0 ;;
-  -help | --help | --hel | --he | --h)
-    echo "\$ac_cs_usage"; exit 0 ;;
-  *) echo "\$ac_cs_usage"; exit 1 ;;
-  esac
-done
-
-ac_given_srcdir=$srcdir
-ac_given_INSTALL="$INSTALL"
-
-trap 'rm -fr `echo "Makefile makelist config.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
-EOF
-cat >> $CONFIG_STATUS <<EOF
-
-# Protect against being on the right side of a sed subst in config.status.
-sed 's/%@/@@/; s/@%/@@/; s/%g\$/@g/; /@g\$/s/[\\\\&%]/\\\\&/g;
- s/@@/%@/; s/@@/@%/; s/@g\$/%g/' > conftest.subs <<\\CEOF
-$ac_vpsub
-$extrasub
-s%@SHELL@%$SHELL%g
-s%@CFLAGS@%$CFLAGS%g
-s%@CPPFLAGS@%$CPPFLAGS%g
-s%@CXXFLAGS@%$CXXFLAGS%g
-s%@FFLAGS@%$FFLAGS%g
-s%@DEFS@%$DEFS%g
-s%@LDFLAGS@%$LDFLAGS%g
-s%@LIBS@%$LIBS%g
-s%@exec_prefix@%$exec_prefix%g
-s%@prefix@%$prefix%g
-s%@program_transform_name@%$program_transform_name%g
-s%@bindir@%$bindir%g
-s%@sbindir@%$sbindir%g
-s%@libexecdir@%$libexecdir%g
-s%@datadir@%$datadir%g
-s%@sysconfdir@%$sysconfdir%g
-s%@sharedstatedir@%$sharedstatedir%g
-s%@localstatedir@%$localstatedir%g
-s%@libdir@%$libdir%g
-s%@includedir@%$includedir%g
-s%@oldincludedir@%$oldincludedir%g
-s%@infodir@%$infodir%g
-s%@mandir@%$mandir%g
-s%@CC@%$CC%g
-s%@A_CFLAGS@%$A_CFLAGS%g
-s%@S_CFLAGS@%$S_CFLAGS%g
-s%@CPP@%$CPP%g
-s%@AWK@%$AWK%g
-s%@host@%$host%g
-s%@host_alias@%$host_alias%g
-s%@host_cpu@%$host_cpu%g
-s%@host_vendor@%$host_vendor%g
-s%@host_os@%$host_os%g
-s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
-s%@INSTALL_SCRIPT@%$INSTALL_SCRIPT%g
-s%@INSTALL_DATA@%$INSTALL_DATA%g
-s%@RANLIB@%$RANLIB%g
-s%@AR@%$AR%g
-s%@ACSRCS@%$ACSRCS%g
-s%@BCSRCS@%$BCSRCS%g
-s%@CCSRCS@%$CCSRCS%g
-s%@AGCSRCS@%$AGCSRCS%g
-s%@BGCSRCS@%$BGCSRCS%g
-s%@HDRS@%$HDRS%g
-s%@IHDRS@%$IHDRS%g
-s%@IHDR_LINKS@%$IHDR_LINKS%g
-s%@AGHDRS@%$AGHDRS%g
-s%@BGHDRS@%$BGHDRS%g
-s%@HDR_DIRS@%$HDR_DIRS%g
-s%@MAN3@%$MAN3%g
-s%@MAN5@%$MAN5%g
-s%@MAN3_LINKS@%$MAN3_LINKS%g
-s%@MAN_DIRS@%$MAN_DIRS%g
-s%@LIB_DIRS@%$LIB_DIRS%g
-s%@LIB_VER@%$LIB_VER%g
-s%@LIB_A@%$LIB_A%g
-s%@LIB_A_LINKS@%$LIB_A_LINKS%g
-s%@LIB_S@%$LIB_S%g
-s%@LIB_S_LINKS@%$LIB_S_LINKS%g
-s%@S_LDFLAGS@%$S_LDFLAGS%g
-s%@TEST@%$TEST%g
-s%@TCSRCS@%$TCSRCS%g
-
-CEOF
-EOF
-
-cat >> $CONFIG_STATUS <<\EOF
-
-# Split the substitutions into bite-sized pieces for seds with
-# small command number limits, like on Digital OSF/1 and HP-UX.
-ac_max_sed_cmds=90 # Maximum number of lines to put in a sed script.
-ac_file=1 # Number of current file.
-ac_beg=1 # First line for current file.
-ac_end=$ac_max_sed_cmds # Line after last line for current file.
-ac_more_lines=:
-ac_sed_cmds=""
-while $ac_more_lines; do
-  if test $ac_beg -gt 1; then
-    sed "1,${ac_beg}d; ${ac_end}q" conftest.subs > conftest.s$ac_file
-  else
-    sed "${ac_end}q" conftest.subs > conftest.s$ac_file
-  fi
-  if test ! -s conftest.s$ac_file; then
-    ac_more_lines=false
-    rm -f conftest.s$ac_file
-  else
-    if test -z "$ac_sed_cmds"; then
-      ac_sed_cmds="sed -f conftest.s$ac_file"
-    else
-      ac_sed_cmds="$ac_sed_cmds | sed -f conftest.s$ac_file"
-    fi
-    ac_file=`expr $ac_file + 1`
-    ac_beg=$ac_end
-    ac_end=`expr $ac_end + $ac_max_sed_cmds`
-  fi
-done
-if test -z "$ac_sed_cmds"; then
-  ac_sed_cmds=cat
-fi
-EOF
-
-cat >> $CONFIG_STATUS <<EOF
-
-CONFIG_FILES=\${CONFIG_FILES-"Makefile makelist"}
-EOF
-cat >> $CONFIG_STATUS <<\EOF
-for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
-  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
-  case "$ac_file" in
-  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
-       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
-  *) ac_file_in="${ac_file}.in" ;;
-  esac
-
-  # Adjust a relative srcdir, top_srcdir, and INSTALL for subdirectories.
-
-  # Remove last slash and all that follows it.  Not all systems have dirname.
-  ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
-  if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
-    # The file is in a subdirectory.
-    test ! -d "$ac_dir" && mkdir "$ac_dir"
-    ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
-    # A "../" for each directory in $ac_dir_suffix.
-    ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
-  else
-    ac_dir_suffix= ac_dots=
-  fi
-
-  case "$ac_given_srcdir" in
-  .)  srcdir=.
-      if test -z "$ac_dots"; then top_srcdir=.
-      else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
-  /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
-  *) # Relative path.
-    srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
-    top_srcdir="$ac_dots$ac_given_srcdir" ;;
-  esac
-
-  case "$ac_given_INSTALL" in
-  [/$]*) INSTALL="$ac_given_INSTALL" ;;
-  *) INSTALL="$ac_dots$ac_given_INSTALL" ;;
-  esac
-
-  echo creating "$ac_file"
-  rm -f "$ac_file"
-  configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
-  case "$ac_file" in
-  *Makefile*) ac_comsub="1i\\
-# $configure_input" ;;
-  *) ac_comsub= ;;
-  esac
-
-  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
-  sed -e "$ac_comsub
-s%@configure_input@%$configure_input%g
-s%@srcdir@%$srcdir%g
-s%@top_srcdir@%$top_srcdir%g
-s%@INSTALL@%$INSTALL%g
-" $ac_file_inputs | (eval "$ac_sed_cmds") > $ac_file
-fi; done
-rm -f conftest.s*
-
-# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
-# NAME is the cpp macro being defined and VALUE is the value it is being given.
-#
-# ac_d sets the value in "#define NAME VALUE" lines.
-ac_dA='s%^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
-ac_dB='\([ 	][ 	]*\)[^ 	]*%\1#\2'
-ac_dC='\3'
-ac_dD='%g'
-# ac_u turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
-ac_uA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
-ac_uB='\([ 	]\)%\1#\2define\3'
-ac_uC=' '
-ac_uD='\4%g'
-# ac_e turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
-ac_eA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
-ac_eB='$%\1#\2define\3'
-ac_eC=' '
-ac_eD='%g'
-
-if test "${CONFIG_HEADERS+set}" != set; then
-EOF
-cat >> $CONFIG_STATUS <<EOF
-  CONFIG_HEADERS="config.h"
-EOF
-cat >> $CONFIG_STATUS <<\EOF
-fi
-for ac_file in .. $CONFIG_HEADERS; do if test "x$ac_file" != x..; then
-  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
-  case "$ac_file" in
-  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
-       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
-  *) ac_file_in="${ac_file}.in" ;;
-  esac
-
-  echo creating $ac_file
-
-  rm -f conftest.frag conftest.in conftest.out
-  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
-  cat $ac_file_inputs > conftest.in
-
-EOF
-
-# Transform confdefs.h into a sed script conftest.vals that substitutes
-# the proper values into config.h.in to produce config.h.  And first:
-# Protect against being on the right side of a sed subst in config.status.
-# Protect against being in an unquoted here document in config.status.
-rm -f conftest.vals
-cat > conftest.hdr <<\EOF
-s/[\\&%]/\\&/g
-s%[\\$`]%\\&%g
-s%#define \([A-Za-z_][A-Za-z0-9_]*\) *\(.*\)%${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD}%gp
-s%ac_d%ac_u%gp
-s%ac_u%ac_e%gp
-EOF
-sed -n -f conftest.hdr confdefs.h > conftest.vals
-rm -f conftest.hdr
-
-# This sed command replaces #undef with comments.  This is necessary, for
-# example, in the case of _POSIX_SOURCE, which is predefined and required
-# on some systems where configure will not decide to define it.
-cat >> conftest.vals <<\EOF
-s%^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*%/* & */%
-EOF
-
-# Break up conftest.vals because some shells have a limit on
-# the size of here documents, and old seds have small limits too.
-
-rm -f conftest.tail
-while :
-do
-  ac_lines=`grep -c . conftest.vals`
-  # grep -c gives empty output for an empty file on some AIX systems.
-  if test -z "$ac_lines" || test "$ac_lines" -eq 0; then break; fi
-  # Write a limited-size here document to conftest.frag.
-  echo '  cat > conftest.frag <<CEOF' >> $CONFIG_STATUS
-  sed ${ac_max_here_lines}q conftest.vals >> $CONFIG_STATUS
-  echo 'CEOF
-  sed -f conftest.frag conftest.in > conftest.out
-  rm -f conftest.in
-  mv conftest.out conftest.in
-' >> $CONFIG_STATUS
-  sed 1,${ac_max_here_lines}d conftest.vals > conftest.tail
-  rm -f conftest.vals
-  mv conftest.tail conftest.vals
-done
-rm -f conftest.vals
-
-cat >> $CONFIG_STATUS <<\EOF
-  rm -f conftest.frag conftest.h
-  echo "/* $ac_file.  Generated automatically by configure.  */" > conftest.h
-  cat conftest.in >> conftest.h
-  rm -f conftest.in
-  if cmp -s $ac_file conftest.h 2>/dev/null; then
-    echo "$ac_file is unchanged"
-    rm -f conftest.h
-  else
-    # Remove last slash and all that follows it.  Not all systems have dirname.
-      ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
-      if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
-      # The file is in a subdirectory.
-      test ! -d "$ac_dir" && mkdir "$ac_dir"
-    fi
-    rm -f $ac_file
-    mv conftest.h $ac_file
-  fi
-fi; done
-
-EOF
-cat >> $CONFIG_STATUS <<EOF
-
-EOF
-cat >> $CONFIG_STATUS <<\EOF
-
-exit 0
-EOF
-chmod +x $CONFIG_STATUS
-rm -fr confdefs* $ac_clean_files
-test "$no_create" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1
-
-
diff --git a/main/editline/configure.in b/main/editline/configure.in
deleted file mode 100644
index db53334..0000000
--- a/main/editline/configure.in
+++ /dev/null
@@ -1,278 +0,0 @@
-dnl 
-dnl Process this file with autoconf to produce a configure script.
-dnl 
-AC_INIT(Makefile.in)
-
-dnl If CFLAGS isn't defined and using gcc, set CFLAGS to something reasonable.
-dnl Otherwise, just prevent autoconf from molesting CFLAGS.
-CFLAGS=$CFLAGS
-AC_PROG_CC
-if test "x$CFLAGS" = "x" ; then
-  no_CFLAGS="yes"
-fi
-if test "x$no_CFLAGS" = "xyes" -a "x$GCC" = "xyes" ; then
-	CFLAGS="-Wall -pipe -g3"
-fi
-A_CFLAGS=""
-AC_SUBST(A_CFLAGS)
-S_CFLAGS="-fPIC -DPIC"
-AC_SUBST(S_CFLAGS)
-AC_PROG_CPP
-AC_PROG_AWK
-
-dnl Platform-specific settings.  The ABI can probably be determined
-dnl programmatically, but doing so is error-prone, which makes it generally
-dnl not worth the trouble.
-AC_CANONICAL_HOST
-case "${host}" in
-  *-*-darwin*)
-	CFLAGS="$CFLAGS -fno-common -no-cpp-precomp"
-	ABI="macho"
-	;;
-  *-*-freebsd*)
-	ABI="elf"
-	;;
-  *-*-linux* | *cygwin*)
-	if echo ${host} | grep -q cygwin ; then \
-		echo "cygwin detected"; \
-		S_CFLAGS=""; \
-		echo "/* cygdef.h. Generated automatically by configure. */ 
-#ifndef _CYGDEF_H_
-#define _CYGDEF_H_ 1
-#include <sys/ioctl.h>
-#define __linux__ 1
- 
-
-typedef void (*sig_t)(int);
- 
-
-#endif /* _CYGDEF_H_ */" > cygdef.h; \
-	echo "
- #define CYGWIN 1
-" > confdefs.h; \
-	fi
-	ABI="elf"
-	;;
-  *-*-netbsd*)
-	AC_MSG_CHECKING(ABI)
-	AC_EGREP_CPP(yes,
-[#ifdef __ELF__
-  yes
-#endif
-],
-		     ABI="elf",
-		     ABI="aout")
-	AC_MSG_RESULT($ABI)
-	;;
-  *-*-solaris2*)
-	ABI="elf"
-	AC_DEFINE(SUNOS)
-	;;
-  *)
-	AC_MSG_RESULT(Unsupported operating system: ${host})
-	ABI="elf"
-	;;
-esac
-
-AC_PROG_INSTALL
-AC_PROG_RANLIB
-AC_PATH_PROGS(AR, ar gar, , $PATH)
-
-dnl Search for termcap access routines in termcap, tinfo, curses, and ncurses.
-AC_CHECK_LIB(termcap, tgetent, , \
-  AC_CHECK_LIB(tinfo, tgetent, , \
-    AC_CHECK_LIB(curses, tgetent, , \
-      AC_CHECK_LIB(ncurses, tgetent, , \
-        AC_MSG_ERROR(termcap support not found)))))
-
-dnl Use termcap.h if it exists; otherwise we need both term.h and [n]curses.h.
-AC_CHECK_HEADERS(termcap.h, , \
-  AC_CHECK_HEADERS(term.h, , \
-    AC_MSG_RESULT(Need term.h since termcap.h is missing))
-  AC_CHECK_HEADERS(curses.h, , \
-    AC_CHECK_HEADERS(ncurses.h, , \
-      AC_MSG_RESULT(Need curses.h or ncurses.h))))
-
-AC_CHECK_HEADERS(sys/cdefs.h vis.h)
-
-AC_CHECK_FUNCS(issetugid)
-AC_CHECK_FUNCS(fgetln, , CCSRCS="$CCSRCS np/fgetln.c")
-AC_CHECK_FUNCS(strvis, , CCSRCS="$CCSRCS np/vis.c")
-AC_CHECK_FUNCS(strunvis, , CCSRCS="$CCSRCS np/unvis.c")
-AC_CHECK_FUNCS(strlcpy, , CCSRCS="$CCSRCS np/strlcpy.c")
-AC_CHECK_FUNCS(strlcat, , CCSRCS="$CCSRCS np/strlcat.c")
-
-AC_EGREP_CPP(yes,
-[#include <sys/cdefs.h>
-#ifdef __RCSID
-  yes
-#endif
-], , [CPPFLAGS="$CPPFLAGS '-D__RCSID(x)='"])
-
-AC_EGREP_CPP(yes,
-[#include <sys/cdefs.h>
-#ifdef __COPYRIGHT
-  yes
-#endif
-], , [CPPFLAGS="$CPPFLAGS '-D__COPYRIGHT(x)='"])
-
-AC_EGREP_CPP(yes,
-[#include <sys/cdefs.h>
-#ifdef __RENAME
-  yes
-#endif
-], , [CPPFLAGS="$CPPFLAGS '-D__RENAME(x)='"])
-
-AC_EGREP_CPP(yes,
-[#include <sys/cdefs.h>
-#ifdef _DIAGASSERT
-  yes
-#endif
-], , [CPPFLAGS="$CPPFLAGS '-D_DIAGASSERT(x)='"])
-
-dnl Enable readline compatibility by default.
-AC_ARG_ENABLE(readline, [  --disable-readline      Disable readline compatibility],
-if test "x$enable_readline" != "xyes" ; then
-  enable_readline="no"
-fi
-,
-enable_readline="yes"
-)
-
-dnl Optionally enable debugging.
-AC_ARG_ENABLE(debug, [  --enable-debug          Enable debugging code],
-if test "x$enable_debug" != "xyes" ; then
-  enable_debug="no"
-fi
-,
-enable_debug="no"
-)
-if test "x$enable_debug" = "xyes" ; then
-  CPPFLAGS="$CPPFLAGS -DDEBUG_TTY -DDEBUG_KEY -DDEBUG_READ -DDEBUG"
-  CPPFLAGS="$CPPFLAGS -DDEBUG_REFRESH -DDEBUG_PASTE"
-else
-  CFLAGS="$CFLAGS -O"
-fi
-
-
-dnl 
-dnl File lists.  This is done here instead of in the Makefile in order to avoid
-dnl the need for conditionals.
-dnl 
-
-dnl .c files.
-ACSRCS="common.c emacs.c vi.c"
-BCSRCS="chared.c el.c hist.c key.c map.c parse.c prompt.c read.c refresh.c search.c sig.c term.c tty.c"
-CCSRCS="$CCSRCS history.c tokenizer.c"
-
-dnl Generated .c files.
-AGCSRCS="fcns.c help.c"
-BGCSRCS="editline.c"
-
-dnl .h files.
-HDRS="chared.h el.h hist.h key.h map.h parse.h prompt.h refresh.h search.h sig.h sys.h term.h tokenizer.h tty.h"
-
-dnl Installed .h files.
-IHDRS="histedit.h"
-
-dnl Installed headers for readline compatibility.
-IHDR_LINKS=
-
-dnl Generated .h files.
-AGHDRS="common.h emacs.h vi.h"
-BGHDRS="fcns.h help.h"
-
-dnl Header installation directories.
-HDR_DIRS="include"
-
-dnl Man pages.
-MAN3="editline.3"
-MAN5="editrc.5"
-
-MAN3_LINKS=
-for i in  el_init.3 el_end.3 el_reset.3 el_gets.3 el_getc.3 el_push.3 \
-          el_parse.3 el_set.3 el_get.3 el_source.3 el_resize.3 el_line.3 \
-	  el_insertstr.3 el_deletestr.3 history_init.3 history_end.3 \
-	  history.3 ; do
-  MAN3_LINKS="$MAN3_LINKS editline.3 $i"
-done
-
-dnl Man page installation directories.
-MAN_DIRS="man/man3 man/man5"
-
-dnl Library settings.
-LIB_DIRS="lib"
-LIB_MAJOR="2"
-LIB_MINOR="6"
-LIB_A="libedit.a"
-LIB_A_LINKS=
-
-if test "x$ABI" = "xelf" ; then
-  LIB_S="libedit.so.$LIB_MAJOR"
-  LIB_S_LINK="libedit.so"
-  LIB_S_LINKS="$LIB_S $LIB_S_LINK"
-  S_LDFLAGS="-shared"
-elif test "x$ABI" = "xaout" ; then
-  LIB_S="libedit.so.$LIB_MAJOR.$LIB_MINOR"
-  LIB_S_LINKS=
-  S_LDFLAGS="-shared"
-elif test "x$ABI" = "xmacho" ; then
-  S_LDFLAGS="-shared"
-  LIB_S="libedit.$LIB_MAJOR.dylib"
-  LIB_S_LINK="libedit.dylib"
-  LIB_S_LINKS="$LIB_S $LIB_S_LINK"
-  if test "x$prefix" = "xNONE" ; then
-    S_LDFLAGS="-undefined suppress -flat_namespace -dynamiclib -compatibility_version $LIB_MAJOR -current_version $LIB_MAJOR -install_name /usr/local/lib/$LIB_S"
-  else
-    S_LDFLAGS="-undefined suppress -flat_namespace -dynamiclib -compatibility_version $LIB_MAJOR -current_version $LIB_MAJOR -install_name $prefix/lib/$LIB_S"
-  fi
-fi
-
-dnl Test program.
-TEST="TEST/test"
-TCSRCS="TEST/test.c"
-
-dnl Add files to the lists if readline compatibility is enabled.
-if test "x$enable_readline" = "xyes" ; then
-  CCSRCS="$CCSRCS readline.c"
-  IHDRS="$IHDRS readline/readline.h"
-  IHDR_LINKS="readline.h readline/history.h"
-  HDR_DIRS="$HDR_DIRS include/readline"
-  LIB_A_LINKS="$LIB_A_LINKS libedit.a libreadline.a"
-  if test "x$ABI" = "xelf" ; then
-    LIB_S_LINKS="$LIB_S_LINKS $LIB_S_LINK libreadline.so"
-  elif test "x$ABI" = "xaout" ; then
-    LIB_S_LINKS="$LIB_S_LINKS $LIB_S libreadline.so.$LIB_MAJOR.$LIB_MINOR"
-  elif test "x$ABI" = "xmacho" ; then
-    LIB_S_LINKS="$LIB_S_LINKS $LIB_S_LINK libreadline.dylib"
-  fi
-fi
-
-AC_SUBST(ACSRCS)
-AC_SUBST(BCSRCS)
-AC_SUBST(CCSRCS)
-AC_SUBST(AGCSRCS)
-AC_SUBST(BGCSRCS)
-AC_SUBST(HDRS)
-AC_SUBST(IHDRS)
-AC_SUBST(IHDR_LINKS)
-AC_SUBST(AGHDRS)
-AC_SUBST(BGHDRS)
-AC_SUBST(HDR_DIRS)
-AC_SUBST(MAN3)
-AC_SUBST(MAN5)
-AC_SUBST(MAN3_LINKS)
-AC_SUBST(MAN_DIRS)
-AC_SUBST(LIB_DIRS)
-AC_SUBST(LIB_VER)
-AC_SUBST(LIB_A)
-AC_SUBST(LIB_A_LINKS)
-AC_SUBST(LIB_S)
-AC_SUBST(LIB_S_LINKS)
-AC_SUBST(S_LDFLAGS)
-AC_SUBST(TEST)
-AC_SUBST(TCSRCS)
-
-AC_CONFIG_HEADER(config.h)
-AC_OUTPUT([Makefile makelist])
-
diff --git a/main/editline/editline.3 b/main/editline/editline.3
deleted file mode 100644
index 28f6ddb..0000000
--- a/main/editline/editline.3
+++ /dev/null
@@ -1,646 +0,0 @@
-.\"	$NetBSD: editline.3,v 1.25 2002/01/15 02:46:22 wiz Exp $
-.\"
-.\" Copyright (c) 1997-1999 The NetBSD Foundation, Inc.
-.\" All rights reserved.
-.\"
-.\" This file was contributed to The NetBSD Foundation by Luke Mewburn.
-.\"
-.\" Redistribution and use in source and binary forms, with or without
-.\" modification, are permitted provided that the following conditions
-.\" are met:
-.\" 1. Redistributions of source code must retain the above copyright
-.\"    notice, this list of conditions and the following disclaimer.
-.\" 2. Redistributions in binary form must reproduce the above copyright
-.\"    notice, this list of conditions and the following disclaimer in the
-.\"    documentation and/or other materials provided with the distribution.
-.\" 3. All advertising materials mentioning features or use of this software
-.\"    must display the following acknowledgement:
-.\"        This product includes software developed by the NetBSD
-.\"        Foundation, Inc. and its contributors.
-.\" 4. Neither the name of The NetBSD Foundation nor the names of its
-.\"    contributors may be used to endorse or promote products derived
-.\"    from this software without specific prior written permission.
-.\"
-.\" THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
-.\" ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-.\" TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-.\" PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
-.\" BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-.\" CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-.\" SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-.\" INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-.\" CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-.\" ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-.\" POSSIBILITY OF SUCH DAMAGE.
-.\"
-.Dd November 12, 1999
-.Os
-.Dt EDITLINE 3
-.Sh NAME
-.Nm editline ,
-.Nm el_init ,
-.Nm el_end ,
-.Nm el_reset ,
-.Nm el_gets ,
-.Nm el_getc ,
-.Nm el_push ,
-.Nm el_parse ,
-.Nm el_set ,
-.Nm el_source ,
-.Nm el_resize ,
-.Nm el_line ,
-.Nm el_insertstr ,
-.Nm el_deletestr ,
-.Nm history_init ,
-.Nm history_end ,
-.Nm history
-.Nd line editor and history functions
-.Sh LIBRARY
-.Lb libedit
-.Sh SYNOPSIS
-.Fd #include <histedit.h>
-.Ft EditLine *
-.Fn el_init "const char *prog" "FILE *fin" "FILE *fout" "FILE *ferr"
-.Ft void
-.Fn el_end "EditLine *e"
-.Ft void
-.Fn el_reset "EditLine *e"
-.Ft const char *
-.Fn el_gets "EditLine *e" "int *count"
-.Ft int
-.Fn el_getc "EditLine *e" "char *ch"
-.Ft void
-.Fn el_push "EditLine *e" "const char *str"
-.Ft int
-.Fn el_parse "EditLine *e" "int argc" "char *argv[]"
-.Ft int
-.Fn el_set "EditLine *e" "int op" "..."
-.Ft int
-.Fn el_get "EditLine *e" "int op" "void *result"
-.Ft int
-.Fn el_source "EditLine *e" "const char *file"
-.Ft void
-.Fn el_resize "EditLine *e"
-.Ft const LineInfo *
-.Fn el_line "EditLine *e"
-.Ft int
-.Fn el_insertstr "EditLine *e" "const char *str"
-.Ft void
-.Fn el_deletestr "EditLine *e" "int count"
-.Ft History *
-.Fn history_init
-.Ft void
-.Fn history_end "History *h"
-.Ft int
-.Fn history "History *h" "HistEvent *ev" "int op" "..."
-.Sh DESCRIPTION
-The
-.Nm
-library provides generic line editing and history functions,
-similar to those found in
-.Xr sh 1 .
-.Pp
-These functions are available in the
-.Nm libedit
-library (which needs the
-.Nm libtermcap
-library).
-Programs should be linked with
-.Fl ledit ltermcap .
-.Sh LINE EDITING FUNCTIONS
-The line editing functions use a common data structure,
-.Fa EditLine ,
-which is created by
-.Fn el_init
-and freed by
-.Fn el_end .
-.Pp
-The following functions are available:
-.Bl -tag -width 4n
-.It Fn el_init
-Initialise the line editor, and return a data structure
-to be used by all other line editing functions.
-.Fa prog
-is the name of the invoking program, used when reading the
-.Xr editrc 5
-file to determine which settings to use.
-.Fa fin ,
-.Fa fout
-and
-.Fa ferr
-are the input, output, and error streams (respectively) to use.
-In this documentation, references to
-.Dq the tty
-are actually to this input/output stream combination.
-.It Fn el_end
-Clean up and finish with
-.Fa e ,
-assumed to have been created with
-.Fn el_init .
-.It Fn el_reset
-Reset the tty and the parser.
-This should be called after an error which may have upset the tty's
-state.
-.It Fn el_gets
-Read a line from the tty.
-.Fa count
-is modified to contain the number of characters read.
-Returns the line read if successful, or
-.Dv NULL
-if no characters were read or if an error occurred.
-.It Fn el_getc
-Read a character from the tty.
-.Fa ch
-is modified to contain the character read.
-Returns the number of characters read if successful, -1 otherwise.
-.It Fn el_push
-Pushes
-.Fa str
-back onto the input stream.
-This is used by the macro expansion mechanism.
-Refer to the description of
-.Ic bind
-.Fl s
-in
-.Xr editrc 5
-for more information.
-.It Fn el_parse
-Parses the
-.Fa argv
-array (which is
-.Fa argc
-elements in size)
-to execute builtin
-.Nm
-commands.
-If the command is prefixed with
-.Dq prog :
-then
-.Fn el_parse
-will only execute the command if
-.Dq prog
-matches the
-.Fa prog
-argument supplied to
-.Fn el_init .
-The return value is
--1 if the command is unknown,
-0 if there was no error or
-.Dq prog
-didn't match, or
-1 if the command returned an error.
-Refer to
-.Xr editrc 5
-for more information.
-.It Fn el_set
-Set
-.Nm
-parameters.
-.Fa op
-determines which parameter to set, and each operation has its
-own parameter list.
-.Pp
-The following values for
-.Fa op
-are supported, along with the required argument list:
-.Bl -tag -width 4n
-.It Dv EL_PROMPT , Fa "char *(*f)(EditLine *)"
-Define prompt printing function as
-.Fa f ,
-which is to return a string that contains the prompt.
-.It Dv EL_RPROMPT , Fa "char *(*f)(EditLine *)"
-Define right side prompt printing function as
-.Fa f ,
-which is to return a string that contains the prompt.
-.It Dv EL_TERMINAL , Fa "const char *type"
-Define terminal type of the tty to be
-.Fa type ,
-or to
-.Ev TERM
-if
-.Fa type
-is
-.Dv NULL .
-.It Dv EL_EDITOR , Fa "const char *mode"
-Set editing mode to
-.Fa mode ,
-which must be one of
-.Dq emacs
-or
-.Dq vi .
-.It Dv EL_SIGNAL , Fa "int flag"
-If
-.Fa flag
-is non-zero,
-.Nm
-will install its own signal handler for the following signals when
-reading command input:
-.Dv SIGCONT ,
-.Dv SIGHUP ,
-.Dv SIGINT ,
-.Dv SIGQUIT ,
-.Dv SIGSTOP ,
-.Dv SIGTERM ,
-.Dv SIGTSTP ,
-and
-.Dv SIGWINCH .
-Otherwise, the current signal handlers will be used.
-.It Dv EL_BIND , Xo
-.Fa "const char *" ,
-.Fa "..." ,
-.Dv NULL
-.Xc
-Perform the
-.Ic bind
-builtin command.
-Refer to
-.Xr editrc 5
-for more information.
-.It Dv EL_ECHOTC , Xo
-.Fa "const char *" ,
-.Fa "..." ,
-.Dv NULL
-.Xc
-Perform the
-.Ic echotc
-builtin command.
-Refer to
-.Xr editrc 5
-for more information.
-.It Dv EL_SETTC , Xo
-.Fa "const char *" ,
-.Fa "..." ,
-.Dv NULL
-.Xc
-Perform the
-.Ic settc
-builtin command.
-Refer to
-.Xr editrc 5
-for more information.
-.It Dv EL_SETTY , Xo
-.Fa "const char *" ,
-.Fa "..." ,
-.Dv NULL
-.Xc
-Perform the
-.Ic setty
-builtin command.
-Refer to
-.Xr editrc 5
-for more information.
-.It Dv EL_TELLTC , Xo
-.Fa "const char *" ,
-.Fa "..." ,
-.Dv NULL
-.Xc
-Perform the
-.Ic telltc
-builtin command.
-Refer to
-.Xr editrc 5
-for more information.
-.It Dv EL_ADDFN , Xo
-.Fa "const char *name" ,
-.Fa "const char *help" ,
-.Fa "unsigned char (*func)(EditLine *e, int ch)
-.Xc
-Add a user defined function,
-.Fn func ,
-referred to as
-.Fa name
-which is invoked when a key which is bound to
-.Fa name
-is entered.
-.Fa help
-is a description of
-.Fa name .
-At invocation time,
-.Fa ch
-is the key which caused the invocation.
-The return value of
-.Fn func
-should be one of:
-.Bl -tag -width "CC_REDISPLAY"
-.It Dv CC_NORM
-Add a normal character.
-.It Dv CC_NEWLINE
-End of line was entered.
-.It Dv CC_EOF
-EOF was entered.
-.It Dv CC_ARGHACK
-Expecting further command input as arguments, do nothing visually.
-.It Dv CC_REFRESH
-Refresh display.
-.It Dv CC_REFRESH_BEEP
-Refresh display, and beep.
-.It Dv CC_CURSOR
-Cursor moved, so update and perform
-.Dv CC_REFRESH .
-.It Dv CC_REDISPLAY
-Redisplay entire input line.
-This is useful if a key binding outputs extra information.
-.It Dv CC_ERROR
-An error occurred.
-Beep, and flush tty.
-.It Dv CC_FATAL
-Fatal error, reset tty to known state.
-.El
-.It Dv EL_HIST , Xo
-.Fa "History *(*func)(History *, int op, ...)" ,
-.Fa "const char *ptr"
-.Xc
-Defines which history function to use, which is usually
-.Fn history .
-.Fa ptr
-should be the value returned by
-.Fn history_init .
-.It Dv EL_EDITMODE , Fa "int flag"
-If
-.Fa flag
-is non-zero,
-editing is enabled (the default).
-Note that this is only an indication, and does not
-affect the operation of
-.Nm "" .
-At this time, it is the caller's responsibility to
-check this
-(using
-.Fn el_get )
-to determine if editing should be enabled or not.
-.It Dv EL_GETCFN , Fa "int (*f)(EditLine *, char *c)"
-Define the character reading function as
-.Fa f ,
-which is to return the number of characters read and store them in
-.Fa c .
-This function is called internally by
-.Fn el_gets
-and
-.Fn el_getc .
-The builtin function can be set or restored with the special function
-name ``EL_BUILTIN_GETCFN''.
-.It Dv EL_CLIENTDATA , Fa "void *data"
-Register
-.Fa data
-to be associated with this EditLine structure. It can be retrieved with
-the corresponding
-.Fn el_get
-call.
-.El
-.It Fn el_get
-Get
-.Nm
-parameters.
-.Fa op
-determines which parameter to retrieve into
-.Fa result .
-.Pp
-The following values for
-.Fa op
-are supported, along with actual type of
-.Fa result :
-.Bl -tag -width 4n
-.It Dv EL_PROMPT , Fa "char *(*f)(EditLine *)"
-Return a pointer to the function that displays the prompt.
-.It Dv EL_RPROMPT , Fa "char *(*f)(EditLine *)"
-Return a pointer to the function that displays the rightside prompt.
-.It Dv EL_EDITOR , Fa "const char *"
-Return the name of the editor, which will be one of
-.Dq emacs
-or
-.Dq vi .
-.It Dv EL_SIGNAL , Fa "int *"
-Return non-zero if
-.Nm
-has installed private signal handlers (see
-.Fn el_get
-above).
-.It Dv EL_EDITMODE, Fa "int *"
-Return non-zero if editing is enabled.
-.It Dv EL_GETCFN, Fa "int (**f)(EditLine *, char *)"
-Return a pointer to the function that read characters, which is equal to
-``EL_BUILTIN_GETCFN'' in the case of the default builtin function.
-.It Dv EL_CLIENTDATA , Fa "void **data"
-Retrieve
-.Fa data
-previously registered with the corresponding
-.Fn el_set
-call.
-.El
-.It Fn el_source
-Initialise
-.Nm
-by reading the contents of
-.Fa file .
-.Fn el_parse
-is called for each line in
-.Fa file .
-If
-.Fa file
-is
-.Dv NULL ,
-try
-.Pa $PWD/.editrc
-then
-.Pa $HOME/.editrc .
-Refer to
-.Xr editrc 5
-for details on the format of
-.Fa file .
-.It Fn el_resize
-Must be called if the terminal size changes.
-If
-.Dv EL_SIGNAL
-has been set with
-.Fn el_set ,
-then this is done automatically.
-Otherwise, it's the responsibility of the application to call
-.Fn el_resize
-on the appropriate occasions.
-.It Fn el_line
-Return the editing information for the current line in a
-.Fa LineInfo
-structure, which is defined as follows:
-.Bd -literal
-typedef struct lineinfo {
-    const char *buffer;    /* address of buffer */
-    const char *cursor;    /* address of cursor */
-    const char *lastchar;  /* address of last character */
-} LineInfo;
-.Ed
-.It Fn el_insertstr
-Insert
-.Fa str
-into the line at the cursor.
-Returns -1 if
-.Fa str
-is empty or won't fit, and 0 otherwise.
-.It Fn el_deletestr
-Delete
-.Fa num
-characters before the cursor.
-.El
-.Sh HISTORY LIST FUNCTIONS
-The history functions use a common data structure,
-.Fa History ,
-which is created by
-.Fn history_init
-and freed by
-.Fn history_end .
-.Pp
-The following functions are available:
-.Bl -tag -width 4n
-.It Fn history_init
-Initialise the history list, and return a data structure
-to be used by all other history list functions.
-.It Fn history_end
-Clean up and finish with
-.Fa h ,
-assumed to have been created with
-.Fn history_init .
-.It Fn history
-Perform operation
-.Fa op
-on the history list, with optional arguments as needed by the
-operation.
-.Fa ev
-is changed accordingly to operation.
-The following values for
-.Fa op
-are supported, along with the required argument list:
-.Bl -tag -width 4n
-.It Dv H_SETSIZE , Fa "int size"
-Set size of history to
-.Fa size
-elements.
-.It Dv H_GETSIZE
-Get number of events currently in history.
-.It Dv H_END
-Cleans up and finishes with
-.Fa h ,
-assumed to be created with
-.Fn history_init .
-.It Dv H_CLEAR
-Clear the history.
-.It Dv H_FUNC , Xo
-.Fa "void *ptr" ,
-.Fa "history_gfun_t first" ,
-.Fa "history_gfun_t next" ,
-.Fa "history_gfun_t last" ,
-.Fa "history_gfun_t prev" ,
-.Fa "history_gfun_t curr" ,
-.Fa "history_sfun_t set" ,
-.Fa "history_vfun_t clear" ,
-.Fa "history_efun_t enter" ,
-.Fa "history_efun_t add"
-.Xc
-Define functions to perform various history operations.
-.Fa ptr
-is the argument given to a function when it's invoked.
-.It Dv H_FIRST
-Return the first element in the history.
-.It Dv H_LAST
-Return the last element in the history.
-.It Dv H_PREV
-Return the previous element in the history.
-.It Dv H_NEXT
-Return the next element in the history.
-.It Dv H_CURR
-Return the current element in the history.
-.It Dv H_SET
-Set the cursor to point to the requested element.
-.It Dv H_ADD , Fa "const char *str"
-Append
-.Fa str
-to the current element of the history, or create an element with
-.It Dv H_APPEND , Fa "const char *str"
-Append
-.Fa str
-to the last new element of the history.
-.It Dv H_ENTER , Fa "const char *str"
-Add
-.Fa str
-as a new element to the history, and, if necessary,
-removing the oldest entry to keep the list to the created size.
-.It Dv H_PREV_STR , Fa "const char *str"
-Return the closest previous event that starts with
-.Fa str .
-.It Dv H_NEXT_STR , Fa "const char *str"
-Return the closest next event that starts with
-.Fa str .
-.It Dv H_PREV_EVENT , Fa "int e"
-Return the previous event numbered
-.Fa e .
-.It Dv H_NEXT_EVENT , Fa "int e"
-Return the next event numbered
-.Fa e .
-.It Dv H_LOAD , Fa "const char *file"
-Load the history list stored in
-.Fa file .
-.It Dv H_SAVE , Fa "const char *file"
-Save the history list to
-.Fa file .
-.El
-.Pp
-.Fn history
-returns 0 if the operation
-.Fa op
-succeeds. Otherwise, -1 is returned and
-.Fa ev
-is updated to contain more details about the error.
-.El
-.\"XXX.Sh EXAMPLES
-.\"XXX: provide some examples
-.Sh SEE ALSO
-.Xr sh 1 ,
-.Xr signal 3 ,
-.Xr termcap 3 ,
-.Xr editrc 5
-.Sh HISTORY
-The
-.Nm
-library first appeared in
-.Bx 4.4 .
-.Dv CC_REDISPLAY
-appeared in
-.Nx 1.3 .
-.Dv CC_REFRESH_BEEP ,
-.Dv EL_EDITMODE
-and the readline emulation appeared in
-.Nx 1.4 .
-.Dv EL_RPROMPT
-appeared in
-.Nx 1.5 .
-.Sh AUTHORS
-The
-.Nm
-library was written by Christos Zoulas.
-Luke Mewburn wrote this manual and implemented
-.Dv CC_REDISPLAY ,
-.Dv CC_REFRESH_BEEP ,
-.Dv EL_EDITMODE ,
-and
-.Dv EL_RPROMPT .
-Jaromir Dolecek implemented the readline emulation.
-.Sh BUGS
-The tokenization functions are not publicly defined in
-.Fd <histedit.h> .
-.Pp
-At this time, it is the responsibility of the caller to
-check the result of the
-.Dv EL_EDITMODE
-operation of
-.Fn el_get
-(after an
-.Fn el_source
-or
-.Fn el_parse )
-to determine if
-.Nm
-should be used for further input.
-I.e.,
-.Dv EL_EDITMODE
-is purely an indication of the result of the most recent
-.Xr editrc 5
-.Ic edit
-command.
diff --git a/main/editline/editrc.5 b/main/editline/editrc.5
deleted file mode 100644
index ddd1289..0000000
--- a/main/editline/editrc.5
+++ /dev/null
@@ -1,491 +0,0 @@
-.\"	$NetBSD: editrc.5,v 1.12 2002/01/15 02:46:44 wiz Exp $
-.\"
-.\" Copyright (c) 1997-2000 The NetBSD Foundation, Inc.
-.\" All rights reserved.
-.\"
-.\" This file was contributed to The NetBSD Foundation by Luke Mewburn.
-.\"
-.\" Redistribution and use in source and binary forms, with or without
-.\" modification, are permitted provided that the following conditions
-.\" are met:
-.\" 1. Redistributions of source code must retain the above copyright
-.\"    notice, this list of conditions and the following disclaimer.
-.\" 2. Redistributions in binary form must reproduce the above copyright
-.\"    notice, this list of conditions and the following disclaimer in the
-.\"    documentation and/or other materials provided with the distribution.
-.\" 3. All advertising materials mentioning features or use of this software
-.\"    must display the following acknowledgement:
-.\"        This product includes software developed by the NetBSD
-.\"        Foundation, Inc. and its contributors.
-.\" 4. Neither the name of The NetBSD Foundation nor the names of its
-.\"    contributors may be used to endorse or promote products derived
-.\"    from this software without specific prior written permission.
-.\"
-.\" THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
-.\" ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-.\" TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-.\" PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
-.\" BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-.\" CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-.\" SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-.\" INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-.\" CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-.\" ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-.\" POSSIBILITY OF SUCH DAMAGE.
-.\"
-.Dd November 8, 2000
-.Os
-.Dt EDITRC 5
-.Sh NAME
-.Nm editrc
-.Nd configuration file for editline library
-.Sh SYNOPSIS
-.Nm
-.Sh DESCRIPTION
-The
-.Nm
-file defines various settings to be used by the
-.Xr editline 3
-library.
-.Pp
-The format of each line is:
-.Dl [prog:]command [arg [...]]
-.Pp
-.Ar command
-is one of the
-.Xr editline 3
-builtin commands.
-Refer to
-.Sx BUILTIN COMMANDS
-for more information.
-.Pp
-.Ar prog
-is the program name string that a program defines when it calls
-.Xr el_init 3
-to setup
-.Xr editline 3 ,
-which is usually
-.Va argv[0] .
-.Ar command
-will be executed for any program which matches
-.Ar prog .
-.Pp
-.Ar prog
-may also be a
-.Xr regex 3
-style
-regular expression, in which case
-.Ar command
-will be executed for any program that matches the regular expression.
-.Pp
-If
-.Ar prog
-is absent,
-.Ar command
-is executed for all programs.
-.Sh BUILTIN COMMANDS
-The
-.Nm editline
-library has some builtin commands, which affect the way
-that the line editing and history functions operate.
-These are based on similar named builtins present in the
-.Xr tcsh 1
-shell.
-.Pp
-The following builtin commands are available:
-.Bl -tag -width 4n
-.It Ic bind Xo
-.Op Fl a
-.Op Fl e
-.Op Fl k
-.Op Fl l
-.Op Fl r
-.Op Fl s
-.Op Fl v
-.Op Ar key Op Ar command
-.Xc
-Without options, list all bound keys, and the editor command to which
-each is bound.
-If
-.Ar key
-is supplied, show the bindings for
-.Ar key .
-If
-.Ar key command
-is supplied, bind
-.Ar command
-to
-.Ar key .
-Options include:
-.Bl -tag -width 4n
-.It Fl e
-Bind all keys to the standard GNU Emacs-like bindings.
-.It Fl v
-Bind all keys to the standard
-.Xr vi 1 -like
-bindings.
-.It Fl a
-List or change key bindings in the
-.Xr vi 1
-mode alternate (command mode) key map.
-.It Fl k
-.Ar key
-is interpreted as a symbolic arrow key name, which may be one of
-.Sq up ,
-.Sq down ,
-.Sq left
-or
-.Sq right .
-.It Fl l
-List all editor commands and a short description of each.
-.It Fl r
-Remove a key's binding.
-.It Fl s
-.Ar command
-is taken as a literal string and treated as terminal input when
-.Ar key
-is typed.
-Bound keys in
-.Ar command
-are themselves reinterpreted, and this continues for ten levels of
-interpretation.
-.El
-.Pp
-.Ar command
-may be one of the commands documented in
-.Sx "EDITOR COMMANDS"
-below, or another key.
-.Pp
-.Ar key
-and
-.Ar command
-can contain control characters of the form
-.Sm off
-.Sq No ^ Ar character
-.Sm on
-.Po
-e.g.
-.Sq ^A
-.Pc ,
-and the following backslashed escape sequences:
-.Pp
-.Bl -tag -compact -offset indent -width 4n
-.It Ic \ea
-Bell
-.It Ic \eb
-Backspace
-.It Ic \ee
-Escape
-.It Ic \ef
-Formfeed
-.It Ic \en
-Newline
-.It Ic \er
-Carriage return
-.It Ic \et
-Horizontal tab
-.It Ic \ev
-Vertical tab
-.Sm off
-.It Sy \e Ar nnn
-.Sm on
-The ASCII character corresponding to the octal number
-.Ar nnn .
-.El
-.Pp
-.Sq \e
-nullifies the special meaning of the following character,
-if it has any, notably
-.Sq \e
-and
-.Sq ^ .
-.It Ic echotc Xo
-.Op Fl sv
-.Ar arg
-.Ar ...
-.Xc
-Exercise terminal capabilities given in
-.Ar arg Ar ... .
-If
-.Ar arg
-is
-.Sq baud ,
-.Sq cols ,
-.Sq lines ,
-.Sq rows ,
-.Sq meta or
-.Sq tabs ,
-the value of that capability is printed, with
-.Dq yes
-or
-.Dq no
-indicating that the terminal does or does not have that capability.
-.Pp
-.Fl s
-returns an emptry string for non-existent capabilities, rather than
-causing an error.
-.Fl v
-causes messages to be verbose.
-.It Ic edit Op Li on | Li off
-Enable or disable the
-.Nm editline
-functionality in a program.
-.It Ic history
-List the history.
-.It Ic telltc
-List the values of all the terminal capabilities (see
-.Xr termcap 5 ) .
-.It Ic settc Ar cap Ar val
-Set the terminal capability
-.Ar cap
-to
-.Ar val ,
-as defined in
-.Xr termcap 5 .
-No sanity checking is done.
-.It Ic setty Xo
-.Op Fl a
-.Op Fl d
-.Op Fl q
-.Op Fl x
-.Op Ar +mode
-.Op Ar -mode
-.Op Ar mode
-.Xc
-Control which tty modes that
-.Nm
-won't allow the user to change.
-.Fl d ,
-.Fl q
-or
-.Fl x
-tells
-.Ic setty
-to act on the
-.Sq edit ,
-.Sq quote
-or
-.Sq execute
-set of tty modes respectively; defaulting to
-.Fl x .
-.Pp
-Without other arguments,
-.Ic setty
-lists the modes in the chosen set which are fixed on
-.Po
-.Sq +mode
-.Pc
-or off
-.Po
-.Sq -mode
-.Pc .
-.Fl a
-lists all tty modes in the chosen set regardless of the setting.
-With
-.Ar +mode ,
-.Ar -mode
-or
-.Ar mode ,
-fixes
-.Ar mode
-on or off or removes control of
-.Ar mode
-in the chosen set.
-.El
-.Sh EDITOR COMMANDS
-The following editor commands are available for use in key bindings:
-.\" Section automatically generated with makelist
-.Bl -tag -width 4n
-.It Ic vi-paste-next
-Vi paste previous deletion to the right of the cursor.
-.It Ic vi-paste-prev
-Vi paste previous deletion to the left of the cursor.
-.It Ic vi-prev-space-word
-Vi move to the previous space delimited word.
-.It Ic vi-prev-word
-Vi move to the previous word.
-.It Ic vi-next-space-word
-Vi move to the next space delimited word.
-.It Ic vi-next-word
-Vi move to the next word.
-.It Ic vi-change-case
-Vi change case of character under the cursor and advance one character.
-.It Ic vi-change-meta
-Vi change prefix command.
-.It Ic vi-insert-at-bol
-Vi enter insert mode at the beginning of line.
-.It Ic vi-replace-char
-Vi replace character under the cursor with the next character typed.
-.It Ic vi-replace-mode
-Vi enter replace mode.
-.It Ic vi-substitute-char
-Vi replace character under the cursor and enter insert mode.
-.It Ic vi-substitute-line
-Vi substitute entire line.
-.It Ic vi-change-to-eol
-Vi change to end of line.
-.It Ic vi-insert
-Vi enter insert mode.
-.It Ic vi-add
-Vi enter insert mode after the cursor.
-.It Ic vi-add-at-eol
-Vi enter insert mode at end of line.
-.It Ic vi-delete-meta
-Vi delete prefix command.
-.It Ic vi-end-word
-Vi move to the end of the current space delimited word.
-.It Ic vi-to-end-word
-Vi move to the end of the current word.
-.It Ic vi-undo
-Vi undo last change.
-.It Ic vi-command-mode
-Vi enter command mode (use alternative key bindings).
-.It Ic vi-zero
-Vi move to the beginning of line.
-.It Ic vi-delete-prev-char
-Vi move to previous character (backspace).
-.It Ic vi-list-or-eof
-Vi list choices for completion or indicate end of file if empty line.
-.It Ic vi-kill-line-prev
-Vi cut from beginning of line to cursor.
-.It Ic vi-search-prev
-Vi search history previous.
-.It Ic vi-search-next
-Vi search history next.
-.It Ic vi-repeat-search-next
-Vi repeat current search in the same search direction.
-.It Ic vi-repeat-search-prev
-Vi repeat current search in the opposite search direction.
-.It Ic vi-next-char
-Vi move to the character specified next.
-.It Ic vi-prev-char
-Vi move to the character specified previous.
-.It Ic vi-to-next-char
-Vi move up to the character specified next.
-.It Ic vi-to-prev-char
-Vi move up to the character specified previous.
-.It Ic vi-repeat-next-char
-Vi repeat current character search in the same search direction.
-.It Ic vi-repeat-prev-char
-Vi repeat current character search in the opposite search direction.
-.It Ic em-delete-or-list
-Delete character under cursor or list completions if at end of line.
-.It Ic em-delete-next-word
-Cut from cursor to end of current word.
-.It Ic em-yank
-Paste cut buffer at cursor position.
-.It Ic em-kill-line
-Cut the entire line and save in cut buffer.
-.It Ic em-kill-region
-Cut area between mark and cursor and save in cut buffer.
-.It Ic em-copy-region
-Copy area between mark and cursor to cut buffer.
-.It Ic em-gosmacs-traspose
-Exchange the two characters before the cursor.
-.It Ic em-next-word
-Move next to end of current word.
-.It Ic em-upper-case
-Uppercase the characters from cursor to end of current word.
-.It Ic em-capitol-case
-Capitalize the characters from cursor to end of current word.
-.It Ic em-lower-case
-Lowercase the characters from cursor to end of current word.
-.It Ic em-set-mark
-Set the mark at cursor.
-.It Ic em-exchange-mark
-Exchange the cursor and mark.
-.It Ic em-universal-argument
-Universal argument (argument times 4).
-.It Ic em-meta-next
-Add 8th bit to next character typed.
-.It Ic em-toggle-overwrite
-Switch from insert to overwrite mode or vice versa.
-.It Ic em-copy-prev-word
-Copy current word to cursor.
-.It Ic em-inc-search-next
-Emacs incremental next search.
-.It Ic em-inc-search-prev
-Emacs incremental reverse search.
-.It Ic ed-end-of-file
-Indicate end of file.
-.It Ic ed-insert
-Add character to the line.
-.It Ic ed-delete-prev-word
-Delete from beginning of current word to cursor.
-.It Ic ed-delete-next-char
-Delete character under cursor.
-.It Ic ed-kill-line
-Cut to the end of line.
-.It Ic ed-move-to-end
-Move cursor to the end of line.
-.It Ic ed-move-to-beg
-Move cursor to the beginning of line.
-.It Ic ed-transpose-chars
-Exchange the character to the left of the cursor with the one under it.
-.It Ic ed-next-char
-Move to the right one character.
-.It Ic ed-prev-word
-Move to the beginning of the current word.
-.It Ic ed-prev-char
-Move to the left one character.
-.It Ic ed-quoted-insert
-Add the next character typed verbatim.
-.It Ic ed-digit
-Adds to argument or enters a digit.
-.It Ic ed-argument-digit
-Digit that starts argument.
-.It Ic ed-unassigned
-Indicates unbound character.
-.It Ic ed-tty-sigint
-Tty interrupt character.
-.It Ic ed-tty-dsusp
-Tty delayed suspend character.
-.It Ic ed-tty-flush-output
-Tty flush output characters.
-.It Ic ed-tty-sigquit
-Tty quit character.
-.It Ic ed-tty-sigtstp
-Tty suspend character.
-.It Ic ed-tty-stop-output
-Tty disallow output characters.
-.It Ic ed-tty-start-output
-Tty allow output characters.
-.It Ic ed-newline
-Execute command.
-.It Ic ed-delete-prev-char
-Delete the character to the left of the cursor.
-.It Ic ed-clear-screen
-Clear screen leaving current line at the top.
-.It Ic ed-redisplay
-Redisplay everything.
-.It Ic ed-start-over
-Erase current line and start from scratch.
-.It Ic ed-sequence-lead-in
-First character in a bound sequence.
-.It Ic ed-prev-history
-Move to the previous history line.
-.It Ic ed-next-history
-Move to the next history line.
-.It Ic ed-search-prev-history
-Search previous in history for a line matching the current.
-.It Ic ed-search-next-history
-Search next in history for a line matching the current.
-.It Ic ed-prev-line
-Move up one line.
-.It Ic ed-next-line
-Move down one line.
-.It Ic ed-command
-Editline extended command.
-.El
-.\" End of section automatically generated with makelist
-.Sh SEE ALSO
-.Xr editline 3 ,
-.Xr regex 3 ,
-.Xr termcap 5
-.Sh AUTHORS
-The
-.Nm editline
-library was written by Christos Zoulas,
-and this manual was written by Luke Mewburn,
-with some sections inspired by
-.Xr tcsh 1 .
diff --git a/main/editline/el.c b/main/editline/el.c
deleted file mode 100644
index 514316f..0000000
--- a/main/editline/el.c
+++ /dev/null
@@ -1,509 +0,0 @@
-/*	$NetBSD: el.c,v 1.29 2002/03/18 16:00:52 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)el.c	8.2 (Berkeley) 1/3/94";
-#else
-__RCSID("$NetBSD: el.c,v 1.29 2002/03/18 16:00:52 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * el.c: EditLine interface functions
- */
-#include <sys/types.h>
-#include <sys/param.h>
-#include <string.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include "el.h"
-
-/* el_init():
- *	Initialize editline and set default parameters.
- */
-public EditLine *
-el_init(const char *prog, FILE *fin, FILE *fout, FILE *ferr)
-{
-
-	EditLine *el = (EditLine *) el_malloc(sizeof(EditLine));
-
-	if (el == NULL)
-		return (NULL);
-
-	memset(el, 0, sizeof(EditLine));
-
-	el->el_infd = fileno(fin);
-	el->el_outfile = fout;
-	el->el_errfile = ferr;
-	el->el_prog = strdup(prog);
-
-	/*
-         * Initialize all the modules. Order is important!!!
-         */
-	el->el_flags = 0;
-
-	if (term_init(el) == -1) {
-		free(el->el_prog);
-		el_free(el);
-		return NULL;
-	}
-	(void) key_init(el);
-	(void) map_init(el);
-	if (tty_init(el) == -1)
-		el->el_flags |= NO_TTY;
-	(void) ch_init(el);
-	(void) search_init(el);
-	(void) hist_init(el);
-	(void) prompt_init(el);
-	(void) sig_init(el);
-	(void) read_init(el);
-
-	return (el);
-}
-
-
-/* el_end():
- *	Clean up.
- */
-public void
-el_end(EditLine *el)
-{
-
-	if (el == NULL)
-		return;
-
-	el_reset(el);
-
-	term_end(el);
-	key_end(el);
-	map_end(el);
-	tty_end(el);
-	ch_end(el);
-	search_end(el);
-	hist_end(el);
-	prompt_end(el);
-	sig_end(el);
-
-	if (el->el_prog)
-		el_free((ptr_t) el->el_prog);
-	el_free((ptr_t) el);
-}
-
-
-/* el_reset():
- *	Reset the tty and the parser
- */
-public void
-el_reset(EditLine *el)
-{
-
-	tty_cookedmode(el);
-	ch_reset(el);		/* XXX: Do we want that? */
-}
-
-
-/* el_set():
- *	set the editline parameters
- */
-public int
-el_set(EditLine *el, int op, ...)
-{
-	va_list va;
-	int rv = 0;
-
-	if (el == NULL)
-		return (-1);
-	va_start(va, op);
-
-	switch (op) {
-	case EL_PROMPT:
-	case EL_RPROMPT:
-		rv = prompt_set(el, va_arg(va, el_pfunc_t), op);
-		break;
-
-	case EL_TERMINAL:
-		rv = term_set(el, va_arg(va, char *));
-		break;
-
-	case EL_EDITOR:
-		rv = map_set_editor(el, va_arg(va, char *));
-		break;
-
-	case EL_SIGNAL:
-		if (va_arg(va, int))
-			el->el_flags |= HANDLE_SIGNALS;
-		else
-			el->el_flags &= ~HANDLE_SIGNALS;
-		break;
-
-	case EL_BIND:
-	case EL_TELLTC:
-	case EL_SETTC:
-	case EL_ECHOTC:
-	case EL_SETTY:
-	{
-		const char *argv[20];
-		int i;
-
-		for (i = 1; i < 20; i++)
-			if ((argv[i] = va_arg(va, char *)) == NULL)
-				break;
-
-		switch (op) {
-		case EL_BIND:
-			argv[0] = "bind";
-			rv = map_bind(el, i, argv);
-			break;
-
-		case EL_TELLTC:
-			argv[0] = "telltc";
-			rv = term_telltc(el, i, argv);
-			break;
-
-		case EL_SETTC:
-			argv[0] = "settc";
-			rv = term_settc(el, i, argv);
-			break;
-
-		case EL_ECHOTC:
-			argv[0] = "echotc";
-			rv = term_echotc(el, i, argv);
-			break;
-
-		case EL_SETTY:
-			argv[0] = "setty";
-			rv = tty_stty(el, i, argv);
-			break;
-
-		default:
-			rv = -1;
-			EL_ABORT((el->el_errfile, "Bad op %d\n", op));
-			break;
-		}
-		break;
-	}
-
-	case EL_ADDFN:
-	{
-		char *name = va_arg(va, char *);
-		char *help = va_arg(va, char *);
-		el_func_t func = va_arg(va, el_func_t);
-
-		rv = map_addfunc(el, name, help, func);
-		break;
-	}
-
-	case EL_HIST:
-	{
-		hist_fun_t func = va_arg(va, hist_fun_t);
-		ptr_t ptr = va_arg(va, char *);
-
-		rv = hist_set(el, func, ptr);
-		break;
-	}
-
-	case EL_EDITMODE:
-		if (va_arg(va, int))
-			el->el_flags &= ~EDIT_DISABLED;
-		else
-			el->el_flags |= EDIT_DISABLED;
-		rv = 0;
-		break;
-
-	case EL_GETCFN:
-	{
-		el_rfunc_t rc = va_arg(va, el_rfunc_t);
-		rv = el_read_setfn(el, rc);
-		break;
-	}
-
-	case EL_CLIENTDATA:
-		el->el_data = va_arg(va, void *);
-		break;
-
-	default:
-		rv = -1;
-		break;
-	}
-
-	va_end(va);
-	return (rv);
-}
-
-
-/* el_get():
- *	retrieve the editline parameters
- */
-public int
-el_get(EditLine *el, int op, void *ret)
-{
-	int rv;
-
-	if (el == NULL || ret == NULL)
-		return (-1);
-	switch (op) {
-	case EL_PROMPT:
-	case EL_RPROMPT:
-		rv = prompt_get(el, (el_pfunc_t *) & ret, op);
-		break;
-
-	case EL_EDITOR:
-		rv = map_get_editor(el, (const char **) &ret);
-		break;
-
-	case EL_SIGNAL:
-		*((int *) ret) = (el->el_flags & HANDLE_SIGNALS);
-		rv = 0;
-		break;
-
-	case EL_EDITMODE:
-		*((int *) ret) = (!(el->el_flags & EDIT_DISABLED));
-		rv = 0;
-		break;
-
-#if 0				/* XXX */
-	case EL_TERMINAL:
-		rv = term_get(el, (const char *) &ret);
-		break;
-
-	case EL_BIND:
-	case EL_TELLTC:
-	case EL_SETTC:
-	case EL_ECHOTC:
-	case EL_SETTY:
-	{
-		char *argv[20];
-		int i;
-
-		for (i = 1; i < 20; i++)
-			if ((argv[i] = va_arg(va, char *)) == NULL)
-				break;
-
-		switch (op) {
-		case EL_BIND:
-			argv[0] = "bind";
-			rv = map_bind(el, i, argv);
-			break;
-
-		case EL_TELLTC:
-			argv[0] = "telltc";
-			rv = term_telltc(el, i, argv);
-			break;
-
-		case EL_SETTC:
-			argv[0] = "settc";
-			rv = term_settc(el, i, argv);
-			break;
-
-		case EL_ECHOTC:
-			argv[0] = "echotc";
-			rv = term_echotc(el, i, argv);
-			break;
-
-		case EL_SETTY:
-			argv[0] = "setty";
-			rv = tty_stty(el, i, argv);
-			break;
-
-		default:
-			rv = -1;
-			EL_ABORT((el->errfile, "Bad op %d\n", op));
-			break;
-		}
-		break;
-	}
-
-	case EL_ADDFN:
-	{
-		char *name = va_arg(va, char *);
-		char *help = va_arg(va, char *);
-		el_func_t func = va_arg(va, el_func_t);
-
-		rv = map_addfunc(el, name, help, func);
-		break;
-	}
-
-	case EL_HIST:
-		{
-			hist_fun_t func = va_arg(va, hist_fun_t);
-			ptr_t ptr = va_arg(va, char *);
-			rv = hist_set(el, func, ptr);
-		}
-		break;
-#endif /* XXX */
-
-	case EL_GETCFN:
-		*((el_rfunc_t *)ret) = el_read_getfn(el);
-		rv = 0;
-		break;
-
-	case EL_CLIENTDATA:
-		*((void **)ret) = el->el_data;
-		rv = 0;
-		break;
-
-	default:
-		rv = -1;
-	}
-
-	return (rv);
-}
-
-
-/* el_line():
- *	Return editing info
- */
-public const LineInfo *
-el_line(EditLine *el)
-{
-
-	return (const LineInfo *) (void *) &el->el_line;
-}
-
-
-/* el_source():
- *	Source a file
- */
-public int
-el_source(EditLine *el, const char *fname)
-{
-	FILE *fp;
-	size_t len;
-	char *ptr;
-
-	fp = NULL;
-	if (fname == NULL) {
-#ifdef HAVE_ISSETUGID
-		static const char elpath[] = "/.editrc";
-		char path[MAXPATHLEN];
-
-		if (issetugid())
-			return (-1);
-		if ((ptr = getenv("HOME")) == NULL)
-			return (-1);
-		if (strlcpy(path, ptr, sizeof(path)) >= sizeof(path))
-			return (-1);
-		if (strlcat(path, elpath, sizeof(path)) >= sizeof(path))
-			return (-1);
-		fname = path;
-#else
-		/*
-		 * If issetugid() is missing, always return an error, in order
-		 * to keep from inadvertently opening up the user to a security
-		 * hole.
-		 */
-		return (-1);
-#endif
-	}
-	if (fp == NULL)
-		fp = fopen(fname, "r");
-	if (fp == NULL)
-		return (-1);
-
-	while ((ptr = fgetln(fp, &len)) != NULL) {
-		if (len > 0 && ptr[len - 1] == '\n')
-			--len;
-		ptr[len] = '\0';
-		if (parse_line(el, ptr) == -1) {
-			(void) fclose(fp);
-			return (-1);
-		}
-	}
-
-	(void) fclose(fp);
-	return (0);
-}
-
-
-/* el_resize():
- *	Called from program when terminal is resized
- */
-public void
-el_resize(EditLine *el)
-{
-	int lins, cols;
-	sigset_t oset, nset;
-
-	(void) sigemptyset(&nset);
-	(void) sigaddset(&nset, SIGWINCH);
-	(void) sigprocmask(SIG_BLOCK, &nset, &oset);
-
-	/* get the correct window size */
-	if (term_get_size(el, &lins, &cols))
-		term_change_size(el, lins, cols);
-
-	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
-}
-
-
-/* el_beep():
- *	Called from the program to beep
- */
-public void
-el_beep(EditLine *el)
-{
-
-	term_beep(el);
-}
-
-
-/* el_editmode()
- *	Set the state of EDIT_DISABLED from the `edit' command.
- */
-protected int
-/*ARGSUSED*/
-el_editmode(EditLine *el, int argc, const char **argv)
-{
-	const char *how;
-
-	if (argv == NULL || argc != 2 || argv[1] == NULL)
-		return (-1);
-
-	how = argv[1];
-	if (strcmp(how, "on") == 0)
-		el->el_flags &= ~EDIT_DISABLED;
-	else if (strcmp(how, "off") == 0)
-		el->el_flags |= EDIT_DISABLED;
-	else {
-		(void) fprintf(el->el_errfile, "edit: Bad value `%s'.\n", how);
-		return (-1);
-	}
-	return (0);
-}
diff --git a/main/editline/el.h b/main/editline/el.h
deleted file mode 100644
index 641081e..0000000
--- a/main/editline/el.h
+++ /dev/null
@@ -1,145 +0,0 @@
-/*	$NetBSD: el.h,v 1.11 2002/03/18 16:00:52 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)el.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.h: Internal structures.
- */
-#ifndef _h_el
-#define	_h_el
-/*
- * Local defaults
- */
-#define	KSHVI
-#define	VIDEFAULT
-#define	ANCHOR
-
-#include <stdio.h>
-#include <sys/types.h>
-
-#define	EL_BUFSIZ	1024		/* Maximum line size		*/
-
-#define	HANDLE_SIGNALS	1<<0
-#define	NO_TTY		1<<1
-#define	EDIT_DISABLED	1<<2
-
-typedef int bool_t;			/* True or not			*/
-
-typedef unsigned char el_action_t;	/* Index to command array	*/
-
-typedef struct coord_t {		/* Position on the screen	*/
-	int	h;
-	int	v;
-} coord_t;
-
-typedef struct el_line_t {
-	char	*buffer;		/* Input line			*/
-	char	*cursor;		/* Cursor position		*/
-	char	*lastchar;		/* Last character		*/
-	const char	*limit;			/* Max position			*/
-} el_line_t;
-
-/*
- * Editor state
- */
-typedef struct el_state_t {
-	int		inputmode;	/* What mode are we in?		*/
-	int		doingarg;	/* Are we getting an argument?	*/
-	int		argument;	/* Numeric argument		*/
-	int		metanext;	/* Is the next char a meta char */
-	el_action_t	lastcmd;	/* Previous command		*/
-} el_state_t;
-
-/*
- * Until we come up with something better...
- */
-#define	el_malloc(a)	malloc(a)
-#define	el_realloc(a,b)	realloc(a, b)
-#define	el_free(a)	free(a)
-
-#include "tty.h"
-#include "prompt.h"
-#include "key.h"
-#include "term.h"
-#include "refresh.h"
-#include "chared.h"
-#include "common.h"
-#include "search.h"
-#include "hist.h"
-#include "map.h"
-#include "parse.h"
-#include "sig.h"
-#include "help.h"
-#include "read.h"
-
-struct editline {
-	char		 *el_prog;	/* the program name		*/
-	FILE		 *el_outfile;	/* Stdio stuff			*/
-	FILE		 *el_errfile;	/* Stdio stuff			*/
-	int		  el_infd;	/* Input file descriptor	*/
-	int		  el_flags;	/* Various flags.		*/
-	coord_t		  el_cursor;	/* Cursor location		*/
-	char		**el_display;	/* Real screen image = what is there */
-	char		**el_vdisplay;	/* Virtual screen image = what we see */
-	void		 *el_data;	/* Client data			*/
-	el_line_t	  el_line;	/* The current line information	*/
-	el_state_t	  el_state;	/* Current editor state		*/
-	el_term_t	  el_term;	/* Terminal dependent stuff	*/
-	el_tty_t	  el_tty;	/* Tty dependent stuff		*/
-	el_refresh_t	  el_refresh;	/* Refresh stuff		*/
-	el_prompt_t	  el_prompt;	/* Prompt stuff			*/
-	el_prompt_t	  el_rprompt;	/* Prompt stuff			*/
-	el_chared_t	  el_chared;	/* Characted editor stuff	*/
-	el_map_t	  el_map;	/* Key mapping stuff		*/
-	el_key_t	  el_key;	/* Key binding stuff		*/
-	el_history_t	  el_history;	/* History stuff		*/
-	el_search_t	  el_search;	/* Search stuff			*/
-	el_signal_t	  el_signal;	/* Signal handling stuff	*/
-	el_read_t	  el_read;	/* Character reading stuff	*/
-};
-
-protected int	el_editmode(EditLine *, int, const char **);
-
-#ifdef DEBUG
-#define EL_ABORT(a)	(void) (fprintf(el->el_errfile, "%s, %d: ", \
-				__FILE__, __LINE__), fprintf a, abort())
-#else
-#define EL_ABORT(a)	abort()
-#endif
-#endif /* _h_el */
diff --git a/main/editline/emacs.c b/main/editline/emacs.c
deleted file mode 100644
index f520d02..0000000
--- a/main/editline/emacs.c
+++ /dev/null
@@ -1,488 +0,0 @@
-/*	$NetBSD: emacs.c,v 1.10 2002/03/18 16:00:52 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)emacs.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: emacs.c,v 1.10 2002/03/18 16:00:52 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * emacs.c: Emacs functions
- */
-#include "el.h"
-
-/* em_delete_or_list():
- *	Delete character under cursor or list completions if at end of line
- *	[^D]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_delete_or_list(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor == el->el_line.lastchar) {
-					/* if I'm at the end */
-		if (el->el_line.cursor == el->el_line.buffer) {
-					/* and the beginning */
-			term_overwrite(el, STReof, 4);	/* then do a EOF */
-			term__flush();
-			return (CC_EOF);
-		} else {
-			/*
-			 * Here we could list completions, but it is an
-			 * error right now
-			 */
-			term_beep(el);
-			return (CC_ERROR);
-		}
-	} else {
-		c_delafter(el, el->el_state.argument);	/* delete after dot */
-		if (el->el_line.cursor > el->el_line.lastchar)
-			el->el_line.cursor = el->el_line.lastchar;
-				/* bounds check */
-		return (CC_REFRESH);
-	}
-}
-
-
-/* em_delete_next_word():
- *	Cut from cursor to end of current word
- *	[M-d]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_delete_next_word(EditLine *el, int c)
-{
-	char *cp, *p, *kp;
-
-	if (el->el_line.cursor == el->el_line.lastchar)
-		return (CC_ERROR);
-
-	cp = c__next_word(el->el_line.cursor, el->el_line.lastchar,
-	    el->el_state.argument, ce__isword);
-
-	for (p = el->el_line.cursor, kp = el->el_chared.c_kill.buf; p < cp; p++)
-				/* save the text */
-		*kp++ = *p;
-	el->el_chared.c_kill.last = kp;
-
-	c_delafter(el, cp - el->el_line.cursor);	/* delete after dot */
-	if (el->el_line.cursor > el->el_line.lastchar)
-		el->el_line.cursor = el->el_line.lastchar;
-				/* bounds check */
-	return (CC_REFRESH);
-}
-
-
-/* em_yank():
- *	Paste cut buffer at cursor position
- *	[^Y]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_yank(EditLine *el, int c)
-{
-	char *kp, *cp;
-
-	if (el->el_chared.c_kill.last == el->el_chared.c_kill.buf) {
-		if (!ch_enlargebufs(el, 1))
-			return (CC_ERROR);
-	}
-
-	if (el->el_line.lastchar +
-	    (el->el_chared.c_kill.last - el->el_chared.c_kill.buf) >=
-	    el->el_line.limit)
-		return (CC_ERROR);
-
-	el->el_chared.c_kill.mark = el->el_line.cursor;
-	cp = el->el_line.cursor;
-
-	/* open the space, */
-	c_insert(el, el->el_chared.c_kill.last - el->el_chared.c_kill.buf);
-	/* copy the chars */
-	for (kp = el->el_chared.c_kill.buf; kp < el->el_chared.c_kill.last; kp++)
-		*cp++ = *kp;
-
-	/* if an arg, cursor at beginning else cursor at end */
-	if (el->el_state.argument == 1)
-		el->el_line.cursor = cp;
-
-	return (CC_REFRESH);
-}
-
-
-/* em_kill_line():
- *	Cut the entire line and save in cut buffer
- *	[^U]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_kill_line(EditLine *el, int c)
-{
-	char *kp, *cp;
-
-	cp = el->el_line.buffer;
-	kp = el->el_chared.c_kill.buf;
-	while (cp < el->el_line.lastchar)
-		*kp++ = *cp++;	/* copy it */
-	el->el_chared.c_kill.last = kp;
-				/* zap! -- delete all of it */
-	el->el_line.lastchar = el->el_line.buffer;
-	el->el_line.cursor = el->el_line.buffer;
-	return (CC_REFRESH);
-}
-
-
-/* em_kill_region():
- *	Cut area between mark and cursor and save in cut buffer
- *	[^W]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_kill_region(EditLine *el, int c)
-{
-	char *kp, *cp;
-
-	if (!el->el_chared.c_kill.mark)
-		return (CC_ERROR);
-
-	if (el->el_chared.c_kill.mark > el->el_line.cursor) {
-		cp = el->el_line.cursor;
-		kp = el->el_chared.c_kill.buf;
-		while (cp < el->el_chared.c_kill.mark)
-			*kp++ = *cp++;	/* copy it */
-		el->el_chared.c_kill.last = kp;
-		c_delafter(el, cp - el->el_line.cursor);
-	} else {		/* mark is before cursor */
-		cp = el->el_chared.c_kill.mark;
-		kp = el->el_chared.c_kill.buf;
-		while (cp < el->el_line.cursor)
-			*kp++ = *cp++;	/* copy it */
-		el->el_chared.c_kill.last = kp;
-		c_delbefore(el, cp - el->el_chared.c_kill.mark);
-		el->el_line.cursor = el->el_chared.c_kill.mark;
-	}
-	return (CC_REFRESH);
-}
-
-
-/* em_copy_region():
- *	Copy area between mark and cursor to cut buffer
- *	[M-W]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_copy_region(EditLine *el, int c)
-{
-	char *kp, *cp;
-
-	if (el->el_chared.c_kill.mark)
-		return (CC_ERROR);
-
-	if (el->el_chared.c_kill.mark > el->el_line.cursor) {
-		cp = el->el_line.cursor;
-		kp = el->el_chared.c_kill.buf;
-		while (cp < el->el_chared.c_kill.mark)
-			*kp++ = *cp++;	/* copy it */
-		el->el_chared.c_kill.last = kp;
-	} else {
-		cp = el->el_chared.c_kill.mark;
-		kp = el->el_chared.c_kill.buf;
-		while (cp < el->el_line.cursor)
-			*kp++ = *cp++;	/* copy it */
-		el->el_chared.c_kill.last = kp;
-	}
-	return (CC_NORM);
-}
-
-
-/* em_gosmacs_traspose():
- *	Exchange the two characters before the cursor
- *	Gosling emacs transpose chars [^T]
- */
-protected el_action_t
-em_gosmacs_traspose(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor > &el->el_line.buffer[1]) {
-		/* must have at least two chars entered */
-		c = el->el_line.cursor[-2];
-		el->el_line.cursor[-2] = el->el_line.cursor[-1];
-		el->el_line.cursor[-1] = c;
-		return (CC_REFRESH);
-	} else
-		return (CC_ERROR);
-}
-
-
-/* em_next_word():
- *	Move next to end of current word
- *	[M-f]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_next_word(EditLine *el, int c)
-{
-	if (el->el_line.cursor == el->el_line.lastchar)
-		return (CC_ERROR);
-
-	el->el_line.cursor = c__next_word(el->el_line.cursor,
-	    el->el_line.lastchar,
-	    el->el_state.argument,
-	    ce__isword);
-
-	if (el->el_map.type == MAP_VI)
-		if (el->el_chared.c_vcmd.action & DELETE) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-	return (CC_CURSOR);
-}
-
-
-/* em_upper_case():
- *	Uppercase the characters from cursor to end of current word
- *	[M-u]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_upper_case(EditLine *el, int c)
-{
-	char *cp, *ep;
-
-	ep = c__next_word(el->el_line.cursor, el->el_line.lastchar,
-	    el->el_state.argument, ce__isword);
-
-	for (cp = el->el_line.cursor; cp < ep; cp++)
-		if (islower((unsigned char) *cp))
-			*cp = toupper(*cp);
-
-	el->el_line.cursor = ep;
-	if (el->el_line.cursor > el->el_line.lastchar)
-		el->el_line.cursor = el->el_line.lastchar;
-	return (CC_REFRESH);
-}
-
-
-/* em_capitol_case():
- *	Capitalize the characters from cursor to end of current word
- *	[M-c]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_capitol_case(EditLine *el, int c)
-{
-	char *cp, *ep;
-
-	ep = c__next_word(el->el_line.cursor, el->el_line.lastchar,
-	    el->el_state.argument, ce__isword);
-
-	for (cp = el->el_line.cursor; cp < ep; cp++) {
-		if (isalpha((unsigned char) *cp)) {
-			if (islower((unsigned char) *cp))
-				*cp = toupper(*cp);
-			cp++;
-			break;
-		}
-	}
-	for (; cp < ep; cp++)
-		if (isupper((unsigned char) *cp))
-			*cp = tolower(*cp);
-
-	el->el_line.cursor = ep;
-	if (el->el_line.cursor > el->el_line.lastchar)
-		el->el_line.cursor = el->el_line.lastchar;
-	return (CC_REFRESH);
-}
-
-
-/* em_lower_case():
- *	Lowercase the characters from cursor to end of current word
- *	[M-l]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_lower_case(EditLine *el, int c)
-{
-	char *cp, *ep;
-
-	ep = c__next_word(el->el_line.cursor, el->el_line.lastchar,
-	    el->el_state.argument, ce__isword);
-
-	for (cp = el->el_line.cursor; cp < ep; cp++)
-		if (isupper((unsigned char) *cp))
-			*cp = tolower(*cp);
-
-	el->el_line.cursor = ep;
-	if (el->el_line.cursor > el->el_line.lastchar)
-		el->el_line.cursor = el->el_line.lastchar;
-	return (CC_REFRESH);
-}
-
-
-/* em_set_mark():
- *	Set the mark at cursor
- *	[^@]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_set_mark(EditLine *el, int c)
-{
-
-	el->el_chared.c_kill.mark = el->el_line.cursor;
-	return (CC_NORM);
-}
-
-
-/* em_exchange_mark():
- *	Exchange the cursor and mark
- *	[^X^X]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_exchange_mark(EditLine *el, int c)
-{
-	char *cp;
-
-	cp = el->el_line.cursor;
-	el->el_line.cursor = el->el_chared.c_kill.mark;
-	el->el_chared.c_kill.mark = cp;
-	return (CC_CURSOR);
-}
-
-
-/* em_universal_argument():
- *	Universal argument (argument times 4)
- *	[^U]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_universal_argument(EditLine *el, int c)
-{				/* multiply current argument by 4 */
-
-	if (el->el_state.argument > 1000000)
-		return (CC_ERROR);
-	el->el_state.doingarg = 1;
-	el->el_state.argument *= 4;
-	return (CC_ARGHACK);
-}
-
-
-/* em_meta_next():
- *	Add 8th bit to next character typed
- *	[<ESC>]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_meta_next(EditLine *el, int c)
-{
-
-	el->el_state.metanext = 1;
-	return (CC_ARGHACK);
-}
-
-
-/* em_toggle_overwrite():
- *	Switch from insert to overwrite mode or vice versa
- */
-protected el_action_t
-/*ARGSUSED*/
-em_toggle_overwrite(EditLine *el, int c)
-{
-
-	el->el_state.inputmode = (el->el_state.inputmode == MODE_INSERT) ?
-	    MODE_REPLACE : MODE_INSERT;
-	return (CC_NORM);
-}
-
-
-/* em_copy_prev_word():
- *	Copy current word to cursor
- */
-protected el_action_t
-/*ARGSUSED*/
-em_copy_prev_word(EditLine *el, int c)
-{
-	char *cp, *oldc, *dp;
-
-	if (el->el_line.cursor == el->el_line.buffer)
-		return (CC_ERROR);
-
-	oldc = el->el_line.cursor;
-	/* does a bounds check */
-	cp = c__prev_word(el->el_line.cursor, el->el_line.buffer,
-	    el->el_state.argument, ce__isword);
-
-	c_insert(el, oldc - cp);
-	for (dp = oldc; cp < oldc && dp < el->el_line.lastchar; cp++)
-		*dp++ = *cp;
-
-	el->el_line.cursor = dp;/* put cursor at end */
-
-	return (CC_REFRESH);
-}
-
-
-/* em_inc_search_next():
- *	Emacs incremental next search
- */
-protected el_action_t
-/*ARGSUSED*/
-em_inc_search_next(EditLine *el, int c)
-{
-
-	el->el_search.patlen = 0;
-	return (ce_inc_search(el, ED_SEARCH_NEXT_HISTORY));
-}
-
-
-/* em_inc_search_prev():
- *	Emacs incremental reverse search
- */
-protected el_action_t
-/*ARGSUSED*/
-em_inc_search_prev(EditLine *el, int c)
-{
-
-	el->el_search.patlen = 0;
-	return (ce_inc_search(el, ED_SEARCH_PREV_HISTORY));
-}
diff --git a/main/editline/hist.c b/main/editline/hist.c
deleted file mode 100644
index 11f39ae..0000000
--- a/main/editline/hist.c
+++ /dev/null
@@ -1,197 +0,0 @@
-/*	$NetBSD: hist.c,v 1.10 2002/03/18 16:00:53 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)hist.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: hist.c,v 1.10 2002/03/18 16:00:53 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * hist.c: History access functions
- */
-#include <stdlib.h>
-#include "el.h"
-
-/* hist_init():
- *	Initialization function.
- */
-protected int
-hist_init(EditLine *el)
-{
-
-	el->el_history.fun = NULL;
-	el->el_history.ref = NULL;
-	el->el_history.buf = (char *) el_malloc(EL_BUFSIZ);
-	el->el_history.sz  = EL_BUFSIZ;
-	if (el->el_history.buf == NULL)
-		return (-1);
-	el->el_history.last = el->el_history.buf;
-	return (0);
-}
-
-
-/* hist_end():
- *	clean up history;
- */
-protected void
-hist_end(EditLine *el)
-{
-
-	el_free((ptr_t) el->el_history.buf);
-	el->el_history.buf = NULL;
-}
-
-
-/* hist_set():
- *	Set new history interface
- */
-protected int
-hist_set(EditLine *el, hist_fun_t fun, ptr_t ptr)
-{
-
-	el->el_history.ref = ptr;
-	el->el_history.fun = fun;
-	return (0);
-}
-
-
-/* hist_get():
- *	Get a history line and update it in the buffer.
- *	eventno tells us the event to get.
- */
-protected el_action_t
-hist_get(EditLine *el)
-{
-	const char *hp;
-	int h;
-
-	if (el->el_history.eventno == 0) {	/* if really the current line */
-		(void) strncpy(el->el_line.buffer, el->el_history.buf,
-		    el->el_history.sz - 1);
-		el->el_line.lastchar = el->el_line.buffer +
-		    (el->el_history.last - el->el_history.buf);
-
-#ifdef KSHVI
-		if (el->el_map.type == MAP_VI)
-			el->el_line.cursor = el->el_line.buffer;
-		else
-#endif /* KSHVI */
-			el->el_line.cursor = el->el_line.lastchar;
-
-		return (CC_REFRESH);
-	}
-	if (el->el_history.ref == NULL)
-		return (CC_ERROR);
-
-	hp = HIST_FIRST(el);
-
-	if (hp == NULL)
-		return (CC_ERROR);
-
-	for (h = 1; h < el->el_history.eventno; h++)
-		if ((hp = HIST_NEXT(el)) == NULL) {
-			el->el_history.eventno = h;
-			return (CC_ERROR);
-		}
-	(void) strncpy(el->el_line.buffer, hp,
-			(size_t)(el->el_line.limit - el->el_line.buffer));
-	el->el_line.lastchar = el->el_line.buffer + strlen(el->el_line.buffer);
-
-	if (el->el_line.lastchar > el->el_line.buffer) {
-		if (el->el_line.lastchar[-1] == '\n')
-			el->el_line.lastchar--;
-		if ((el->el_line.lastchar > el->el_line.buffer)&&(el->el_line.lastchar[-1] == ' ')) /* bill heckel */
-			el->el_line.lastchar--;
-		if (el->el_line.lastchar < el->el_line.buffer)
-			el->el_line.lastchar = el->el_line.buffer;
-	}
-#ifdef KSHVI
-	if (el->el_map.type == MAP_VI)
-		el->el_line.cursor = el->el_line.buffer;
-	else
-#endif /* KSHVI */
-		el->el_line.cursor = el->el_line.lastchar;
-
-	return (CC_REFRESH);
-}
-
-
-/* hist_list()
- *	List history entries
- */
-protected int
-/*ARGSUSED*/
-hist_list(EditLine *el, int argc, const char **argv)
-{
-	const char *str;
-
-	if (el->el_history.ref == NULL)
-		return (-1);
-	for (str = HIST_LAST(el); str != NULL; str = HIST_PREV(el))
-		(void) fprintf(el->el_outfile, "%d %s",
-		    el->el_history.ev.num, str);
-	return (0);
-}
-
-/* hist_enlargebuf()
- *	Enlarge history buffer to specified value. Called from el_enlargebufs().
- *	Return 0 for failure, 1 for success.
- */
-protected int
-/*ARGSUSED*/
-hist_enlargebuf(EditLine *el, size_t oldsz, size_t newsz)
-{
-	char *newbuf;
-
-	newbuf = realloc(el->el_history.buf, newsz);
-	if (!newbuf)
-		return 0;
-
-	(void) memset(&newbuf[oldsz], '\0', newsz - oldsz);
-
-	el->el_history.last = newbuf +
-				(el->el_history.last - el->el_history.buf);
-	el->el_history.buf = newbuf;
-	el->el_history.sz  = newsz;
-
-	return 1;
-}
diff --git a/main/editline/hist.h b/main/editline/hist.h
deleted file mode 100644
index 5fdccd0..0000000
--- a/main/editline/hist.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*	$NetBSD: hist.h,v 1.7 2002/03/18 16:00:53 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)hist.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.hist.c: History functions
- */
-#ifndef _h_el_hist
-#define	_h_el_hist
-
-#include "histedit.h"
-
-typedef int (*hist_fun_t)(ptr_t, HistEvent *, int, ...);
-
-typedef struct el_history_t {
-	char		*buf;		/* The history buffer		*/
-	size_t		sz;		/* Size of history buffer	*/
-	char		*last;		/* The last character		*/
-	int		 eventno;	/* Event we are looking for	*/
-	ptr_t		 ref;		/* Argument for history fcns	*/
-	hist_fun_t	 fun;		/* Event access			*/
-	HistEvent	 ev;		/* Event cookie			*/
-} el_history_t;
-
-#define	HIST_FUN(el, fn, arg)	\
-    ((((*(el)->el_history.fun) ((el)->el_history.ref, &(el)->el_history.ev, \
-	fn, arg)) == -1) ? NULL : (el)->el_history.ev.str)
-
-#define	HIST_NEXT(el)		HIST_FUN(el, H_NEXT, NULL)
-#define	HIST_FIRST(el)		HIST_FUN(el, H_FIRST, NULL)
-#define	HIST_LAST(el)		HIST_FUN(el, H_LAST, NULL)
-#define	HIST_PREV(el)		HIST_FUN(el, H_PREV, NULL)
-#define	HIST_EVENT(el, num)	HIST_FUN(el, H_EVENT, num)
-#define	HIST_LOAD(el, fname)	HIST_FUN(el, H_LOAD fname)
-#define	HIST_SAVE(el, fname)	HIST_FUN(el, H_SAVE fname)
-
-protected int		hist_init(EditLine *);
-protected void		hist_end(EditLine *);
-protected el_action_t	hist_get(EditLine *);
-protected int		hist_set(EditLine *, hist_fun_t, ptr_t);
-protected int		hist_list(EditLine *, int, const char **);
-protected int		hist_enlargebuf(EditLine *, size_t, size_t);
-
-#endif /* _h_el_hist */
diff --git a/main/editline/histedit.h b/main/editline/histedit.h
deleted file mode 100644
index e387e3b..0000000
--- a/main/editline/histedit.h
+++ /dev/null
@@ -1,197 +0,0 @@
-/*	$NetBSD: histedit.h,v 1.19 2002/03/18 16:00:54 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)histedit.h	8.2 (Berkeley) 1/3/94
- */
-
-/*
- * histedit.h: Line editor and history interface.
- */
-#ifndef _HISTEDIT_H_
-#define	_HISTEDIT_H_
-
-#define	LIBEDIT_MAJOR 2
-#define	LIBEDIT_MINOR 6
-
-#include <sys/types.h>
-#include <stdio.h>
-
-/*
- * ==== Editing ====
- */
-typedef struct editline EditLine;
-
-/*
- * For user-defined function interface
- */
-typedef struct lineinfo {
-	char	*buffer;
-	char	*cursor;
-	char	*lastchar;
-} LineInfo;
-
-
-/*
- * EditLine editor function return codes.
- * For user-defined function interface
- */
-#define	CC_NORM		0
-#define	CC_NEWLINE	1
-#define	CC_EOF		2
-#define	CC_ARGHACK	3
-#define	CC_REFRESH	4
-#define	CC_CURSOR	5
-#define	CC_ERROR	6
-#define	CC_FATAL	7
-#define	CC_REDISPLAY	8
-#define	CC_REFRESH_BEEP	9
-
-/*
- * Initialization, cleanup, and resetting
- */
-EditLine	*el_init(const char *, FILE *, FILE *, FILE *);
-void		 el_reset(EditLine *);
-void		 el_end(EditLine *);
-
-
-/*
- * Get a line, a character or push a string back in the input queue
- */
-const char	*el_gets(EditLine *, int *);
-int		 el_getc(EditLine *, char *);
-void		 el_push(EditLine *, char *);
-
-/*
- * Beep!
- */
-void		 el_beep(EditLine *);
-
-/*
- * High level function internals control
- * Parses argc, argv array and executes builtin editline commands
- */
-int		 el_parse(EditLine *, int, const char **);
-
-/*
- * Low level editline access functions
- */
-int		 el_set(EditLine *, int, ...);
-int		 el_get(EditLine *, int, void *);
-
-/*
- * el_set/el_get parameters
- */
-#define	EL_PROMPT	0	/* , el_pfunc_t);		*/
-#define	EL_TERMINAL	1	/* , const char *);		*/
-#define	EL_EDITOR	2	/* , const char *);		*/
-#define	EL_SIGNAL	3	/* , int);			*/
-#define	EL_BIND		4	/* , const char *, ..., NULL);	*/
-#define	EL_TELLTC	5	/* , const char *, ..., NULL);	*/
-#define	EL_SETTC	6	/* , const char *, ..., NULL);	*/
-#define	EL_ECHOTC	7	/* , const char *, ..., NULL);	*/
-#define	EL_SETTY	8	/* , const char *, ..., NULL);	*/
-#define	EL_ADDFN	9	/* , const char *, const char *	*/
-				/* , el_func_t);		*/
-#define	EL_HIST		10	/* , hist_fun_t, const char *);	*/
-#define	EL_EDITMODE	11	/* , int);			*/
-#define	EL_RPROMPT	12	/* , el_pfunc_t);		*/
-#define	EL_GETCFN	13	/* , el_rfunc_t);		*/
-#define	EL_CLIENTDATA	14	/* , void *);			*/
-
-#define EL_BUILTIN_GETCFN	(NULL)
-
-/*
- * Source named file or $PWD/.editrc or $HOME/.editrc
- */
-int		el_source(EditLine *, const char *);
-
-/*
- * Must be called when the terminal changes size; If EL_SIGNAL
- * is set this is done automatically otherwise it is the responsibility
- * of the application
- */
-void		 el_resize(EditLine *);
-
-
-/*
- * User-defined function interface.
- */
-const LineInfo	*el_line(EditLine *);
-int		 el_insertstr(EditLine *, const char *);
-void		 el_deletestr(EditLine *, int);
-
-/*
- * ==== History ====
- */
-
-typedef struct history History;
-
-typedef struct HistEvent {
-	int		 num;
-	const char	*str;
-} HistEvent;
-
-/*
- * History access functions.
- */
-History *	history_init(void);
-void		history_end(History *);
-
-int		history(History *, HistEvent *, int, ...);
-
-#define	H_FUNC		 0	/* , UTSL		*/
-#define	H_SETSIZE	 1	/* , const int);	*/
-#define	H_GETSIZE	 2	/* , void);		*/
-#define	H_FIRST		 3	/* , void);		*/
-#define	H_LAST		 4	/* , void);		*/
-#define	H_PREV		 5	/* , void);		*/
-#define	H_NEXT		 6	/* , void);		*/
-#define	H_CURR		 8	/* , const int);	*/
-#define	H_SET		 7	/* , void);		*/
-#define	H_ADD		 9	/* , const char *);	*/
-#define	H_ENTER		10	/* , const char *);	*/
-#define	H_APPEND	11	/* , const char *);	*/
-#define	H_END		12	/* , void);		*/
-#define	H_NEXT_STR	13	/* , const char *);	*/
-#define	H_PREV_STR	14	/* , const char *);	*/
-#define	H_NEXT_EVENT	15	/* , const int);	*/
-#define	H_PREV_EVENT	16	/* , const int);	*/
-#define	H_LOAD		17	/* , const char *);	*/
-#define	H_SAVE		18	/* , const char *);	*/
-#define	H_CLEAR		19	/* , void);		*/
-
-#endif /* _HISTEDIT_H_ */
diff --git a/main/editline/history.c b/main/editline/history.c
deleted file mode 100644
index f133d2e..0000000
--- a/main/editline/history.c
+++ /dev/null
@@ -1,875 +0,0 @@
-/*	$NetBSD: history.c,v 1.19 2002/03/18 16:00:54 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)history.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: history.c,v 1.19 2002/03/18 16:00:54 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * hist.c: History access functions
- */
-#include <string.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#ifdef HAVE_VIS_H
-#include <vis.h>
-#else
-#include "np/vis.h"
-#endif
-#include <sys/stat.h>
-
-static const char hist_cookie[] = "_HiStOrY_V2_\n";
-
-#include "histedit.h"
-
-typedef int (*history_gfun_t)(ptr_t, HistEvent *);
-typedef int (*history_efun_t)(ptr_t, HistEvent *, const char *);
-typedef void (*history_vfun_t)(ptr_t, HistEvent *);
-typedef int (*history_sfun_t)(ptr_t, HistEvent *, const int);
-
-struct history {
-	ptr_t h_ref;		/* Argument for history fcns	 */
-	int h_ent;		/* Last entry point for history	 */
-	history_gfun_t h_first;	/* Get the first element	 */
-	history_gfun_t h_next;	/* Get the next element		 */
-	history_gfun_t h_last;	/* Get the last element		 */
-	history_gfun_t h_prev;	/* Get the previous element	 */
-	history_gfun_t h_curr;	/* Get the current element	 */
-	history_sfun_t h_set;	/* Set the current element	 */
-	history_vfun_t h_clear;	/* Clear the history list	 */
-	history_efun_t h_enter;	/* Add an element		 */
-	history_efun_t h_add;	/* Append to an element		 */
-};
-#define	HNEXT(h, ev)		(*(h)->h_next)((h)->h_ref, ev)
-#define	HFIRST(h, ev)		(*(h)->h_first)((h)->h_ref, ev)
-#define	HPREV(h, ev)		(*(h)->h_prev)((h)->h_ref, ev)
-#define	HLAST(h, ev)		(*(h)->h_last)((h)->h_ref, ev)
-#define	HCURR(h, ev)		(*(h)->h_curr)((h)->h_ref, ev)
-#define	HSET(h, ev, n)		(*(h)->h_set)((h)->h_ref, ev, n)
-#define	HCLEAR(h, ev)		(*(h)->h_clear)((h)->h_ref, ev)
-#define	HENTER(h, ev, str)	(*(h)->h_enter)((h)->h_ref, ev, str)
-#define	HADD(h, ev, str)	(*(h)->h_add)((h)->h_ref, ev, str)
-
-#define	h_malloc(a)	malloc(a)
-#define	h_realloc(a, b)	realloc((a), (b))
-#define	h_free(a)	free(a)
-
-typedef struct {
-    int		num;
-    char	*str;
-} HistEventPrivate;
-
-
-
-private int history_setsize(History *, HistEvent *, int);
-private int history_getsize(History *, HistEvent *);
-private int history_set_fun(History *, History *);
-private int history_load(History *, const char *);
-private int history_save(History *, const char *);
-private int history_prev_event(History *, HistEvent *, int);
-private int history_next_event(History *, HistEvent *, int);
-private int history_next_string(History *, HistEvent *, const char *);
-private int history_prev_string(History *, HistEvent *, const char *);
-
-
-/***********************************************************************/
-
-/*
- * Builtin- history implementation
- */
-typedef struct hentry_t {
-	HistEvent ev;		/* What we return		 */
-	struct hentry_t *next;	/* Next entry			 */
-	struct hentry_t *prev;	/* Previous entry		 */
-}        hentry_t;
-
-typedef struct history_t {
-	hentry_t list;		/* Fake list header element	 */
-	hentry_t *cursor;	/* Current element in the list	 */
-	int max;		/* Maximum number of events	 */
-	int cur;		/* Current number of events	 */
-	int eventid;		/* For generation of unique event id	 */
-}         history_t;
-
-private int history_def_first(ptr_t, HistEvent *);
-private int history_def_last(ptr_t, HistEvent *);
-private int history_def_next(ptr_t, HistEvent *);
-private int history_def_prev(ptr_t, HistEvent *);
-private int history_def_curr(ptr_t, HistEvent *);
-private int history_def_set(ptr_t, HistEvent *, const int n);
-private int history_def_enter(ptr_t, HistEvent *, const char *);
-private int history_def_add(ptr_t, HistEvent *, const char *);
-private void history_def_init(ptr_t *, HistEvent *, int);
-private void history_def_clear(ptr_t, HistEvent *);
-private int history_def_insert(history_t *, HistEvent *, const char *);
-private void history_def_delete(history_t *, HistEvent *, hentry_t *);
-
-#define	history_def_setsize(p, num)(void) (((history_t *) p)->max = (num))
-#define	history_def_getsize(p)  (((history_t *) p)->cur)
-
-#define	he_strerror(code)	he_errlist[code]
-#define	he_seterrev(evp, code)	{\
-				    evp->num = code;\
-				    evp->str = he_strerror(code);\
-				}
-
-/* error messages */
-static const char *const he_errlist[] = {
-	"OK",
-	"unknown error",
-	"malloc() failed",
-	"first event not found",
-	"last event not found",
-	"empty list",
-	"no next event",
-	"no previous event",
-	"current event is invalid",
-	"event not found",
-	"can't read history from file",
-	"can't write history",
-	"required parameter(s) not supplied",
-	"history size negative",
-	"function not allowed with other history-functions-set the default",
-	"bad parameters"
-};
-/* error codes */
-#define	_HE_OK                   0
-#define	_HE_UNKNOWN		 1
-#define	_HE_MALLOC_FAILED        2
-#define	_HE_FIRST_NOTFOUND       3
-#define	_HE_LAST_NOTFOUND        4
-#define	_HE_EMPTY_LIST           5
-#define	_HE_END_REACHED          6
-#define	_HE_START_REACHED	 7
-#define	_HE_CURR_INVALID	 8
-#define	_HE_NOT_FOUND		 9
-#define	_HE_HIST_READ		10
-#define	_HE_HIST_WRITE		11
-#define	_HE_PARAM_MISSING	12
-#define	_HE_SIZE_NEGATIVE	13
-#define	_HE_NOT_ALLOWED		14
-#define	_HE_BAD_PARAM		15
-
-/* history_def_first():
- *	Default function to return the first event in the history.
- */
-private int
-history_def_first(ptr_t p, HistEvent *ev)
-{
-	history_t *h = (history_t *) p;
-
-	h->cursor = h->list.next;
-	if (h->cursor != &h->list)
-		*ev = h->cursor->ev;
-	else {
-		he_seterrev(ev, _HE_FIRST_NOTFOUND);
-		return (-1);
-	}
-
-	return (0);
-}
-
-
-/* history_def_last():
- *	Default function to return the last event in the history.
- */
-private int
-history_def_last(ptr_t p, HistEvent *ev)
-{
-	history_t *h = (history_t *) p;
-
-	h->cursor = h->list.prev;
-	if (h->cursor != &h->list)
-		*ev = h->cursor->ev;
-	else {
-		he_seterrev(ev, _HE_LAST_NOTFOUND);
-		return (-1);
-	}
-
-	return (0);
-}
-
-
-/* history_def_next():
- *	Default function to return the next event in the history.
- */
-private int
-history_def_next(ptr_t p, HistEvent *ev)
-{
-	history_t *h = (history_t *) p;
-
-	if (h->cursor != &h->list)
-		h->cursor = h->cursor->next;
-	else {
-		he_seterrev(ev, _HE_EMPTY_LIST);
-		return (-1);
-	}
-
-	if (h->cursor != &h->list)
-		*ev = h->cursor->ev;
-	else {
-		he_seterrev(ev, _HE_END_REACHED);
-		return (-1);
-	}
-
-	return (0);
-}
-
-
-/* history_def_prev():
- *	Default function to return the previous event in the history.
- */
-private int
-history_def_prev(ptr_t p, HistEvent *ev)
-{
-	history_t *h = (history_t *) p;
-
-	if (h->cursor != &h->list)
-		h->cursor = h->cursor->prev;
-	else {
-		he_seterrev(ev,
-		    (h->cur > 0) ? _HE_END_REACHED : _HE_EMPTY_LIST);
-		return (-1);
-	}
-
-	if (h->cursor != &h->list)
-		*ev = h->cursor->ev;
-	else {
-		he_seterrev(ev, _HE_START_REACHED);
-		return (-1);
-	}
-
-	return (0);
-}
-
-
-/* history_def_curr():
- *	Default function to return the current event in the history.
- */
-private int
-history_def_curr(ptr_t p, HistEvent *ev)
-{
-	history_t *h = (history_t *) p;
-
-	if (h->cursor != &h->list)
-		*ev = h->cursor->ev;
-	else {
-		he_seterrev(ev,
-		    (h->cur > 0) ? _HE_CURR_INVALID : _HE_EMPTY_LIST);
-		return (-1);
-	}
-
-	return (0);
-}
-
-
-/* history_def_set():
- *	Default function to set the current event in the history to the
- *	given one.
- */
-private int
-history_def_set(ptr_t p, HistEvent *ev, const int n)
-{
-	history_t *h = (history_t *) p;
-
-	if (h->cur == 0) {
-		he_seterrev(ev, _HE_EMPTY_LIST);
-		return (-1);
-	}
-	if (h->cursor == &h->list || h->cursor->ev.num != n) {
-		for (h->cursor = h->list.next; h->cursor != &h->list;
-		    h->cursor = h->cursor->next)
-			if (h->cursor->ev.num == n)
-				break;
-	}
-	if (h->cursor == &h->list) {
-		he_seterrev(ev, _HE_NOT_FOUND);
-		return (-1);
-	}
-	return (0);
-}
-
-
-/* history_def_add():
- *	Append string to element
- */
-private int
-history_def_add(ptr_t p, HistEvent *ev, const char *str)
-{
-	history_t *h = (history_t *) p;
-	size_t len;
-	char *s;
-	HistEventPrivate *evp = (void *)&h->cursor->ev;
-
-	if (h->cursor == &h->list)
-		return (history_def_enter(p, ev, str));
-	len = strlen(evp->str) + strlen(str) + 1;
-	s = (char *) h_malloc(len);
-	if (!s) {
-		he_seterrev(ev, _HE_MALLOC_FAILED);
-		return (-1);
-	}
-	(void) strlcpy(s, h->cursor->ev.str, len);
-	(void) strlcat(s, str, len);
-	h_free(evp->str);
-	evp->str = s;
-	*ev = h->cursor->ev;
-	return (0);
-}
-
-
-/* history_def_delete():
- *	Delete element hp of the h list
- */
-/* ARGSUSED */
-private void
-history_def_delete(history_t *h, HistEvent *ev, hentry_t *hp)
-{
-	HistEventPrivate *evp = (void *)&hp->ev;
-	if (hp == &h->list)
-		abort();
-	hp->prev->next = hp->next;
-	hp->next->prev = hp->prev;
-	h_free((ptr_t) evp->str);
-	h_free(hp);
-	h->cur--;
-}
-
-
-/* history_def_insert():
- *	Insert element with string str in the h list
- */
-private int
-history_def_insert(history_t *h, HistEvent *ev, const char *str)
-{
-
-	h->cursor = (hentry_t *) h_malloc(sizeof(hentry_t));
-	if (h->cursor)
-		h->cursor->ev.str = strdup(str);
-	if (!h->cursor || !h->cursor->ev.str) {
-		he_seterrev(ev, _HE_MALLOC_FAILED);
-		return (-1);
-	}
-	h->cursor->ev.num = ++h->eventid;
-	h->cursor->next = h->list.next;
-	h->cursor->prev = &h->list;
-	h->list.next->prev = h->cursor;
-	h->list.next = h->cursor;
-	h->cur++;
-
-	*ev = h->cursor->ev;
-	return (0);
-}
-
-
-/* history_def_enter():
- *	Default function to enter an item in the history
- */
-private int
-history_def_enter(ptr_t p, HistEvent *ev, const char *str)
-{
-	history_t *h = (history_t *) p;
-
-	if (history_def_insert(h, ev, str) == -1)
-		return (-1);	/* error, keep error message */
-
-	/*
-         * Always keep at least one entry.
-         * This way we don't have to check for the empty list.
-         */
-	while (h->cur > h->max && h->cur > 0)
-		history_def_delete(h, ev, h->list.prev);
-
-	return (0);
-}
-
-
-/* history_def_init():
- *	Default history initialization function
- */
-/* ARGSUSED */
-private void
-history_def_init(ptr_t *p, HistEvent *ev, int n)
-{
-	history_t *h = (history_t *) h_malloc(sizeof(history_t));
-
-	if (n <= 0)
-		n = 0;
-	h->eventid = 0;
-	h->cur = 0;
-	h->max = n;
-	h->list.next = h->list.prev = &h->list;
-	h->list.ev.str = NULL;
-	h->list.ev.num = 0;
-	h->cursor = &h->list;
-	*p = (ptr_t) h;
-}
-
-
-/* history_def_clear():
- *	Default history cleanup function
- */
-private void
-history_def_clear(ptr_t p, HistEvent *ev)
-{
-	history_t *h = (history_t *) p;
-
-	while (h->list.prev != &h->list)
-		history_def_delete(h, ev, h->list.prev);
-	h->eventid = 0;
-	h->cur = 0;
-}
-
-
-
-
-/************************************************************************/
-
-/* history_init():
- *	Initialization function.
- */
-public History *
-history_init(void)
-{
-	History *h = (History *) h_malloc(sizeof(History));
-	HistEvent ev;
-
-	history_def_init(&h->h_ref, &ev, 0);
-	h->h_ent = -1;
-	h->h_next = history_def_next;
-	h->h_first = history_def_first;
-	h->h_last = history_def_last;
-	h->h_prev = history_def_prev;
-	h->h_curr = history_def_curr;
-	h->h_set = history_def_set;
-	h->h_clear = history_def_clear;
-	h->h_enter = history_def_enter;
-	h->h_add = history_def_add;
-
-	return (h);
-}
-
-
-/* history_end():
- *	clean up history;
- */
-public void
-history_end(History *h)
-{
-	HistEvent ev;
-
-	if (h->h_next == history_def_next)
-		history_def_clear(h->h_ref, &ev);
-}
-
-
-
-/* history_setsize():
- *	Set history number of events
- */
-private int
-history_setsize(History *h, HistEvent *ev, int num)
-{
-
-	if (h->h_next != history_def_next) {
-		he_seterrev(ev, _HE_NOT_ALLOWED);
-		return (-1);
-	}
-	if (num < 0) {
-		he_seterrev(ev, _HE_BAD_PARAM);
-		return (-1);
-	}
-	history_def_setsize(h->h_ref, num);
-	return (0);
-}
-
-
-/* history_getsize():
- *      Get number of events currently in history
- */
-private int
-history_getsize(History *h, HistEvent *ev)
-{
-	int retval = 0;
-
-	if (h->h_next != history_def_next) {
-		he_seterrev(ev, _HE_NOT_ALLOWED);
-		return (-1);
-	}
-	retval = history_def_getsize(h->h_ref);
-	if (retval < -1) {
-		he_seterrev(ev, _HE_SIZE_NEGATIVE);
-		return (-1);
-	}
-	ev->num = retval;
-	return (0);
-}
-
-
-/* history_set_fun():
- *	Set history functions
- */
-private int
-history_set_fun(History *h, History *nh)
-{
-	HistEvent ev;
-
-	if (nh->h_first == NULL || nh->h_next == NULL || nh->h_last == NULL ||
-	    nh->h_prev == NULL || nh->h_curr == NULL || nh->h_set == NULL ||
-	    nh->h_enter == NULL || nh->h_add == NULL || nh->h_clear == NULL ||
-	    nh->h_ref == NULL) {
-		if (h->h_next != history_def_next) {
-			history_def_init(&h->h_ref, &ev, 0);
-			h->h_first = history_def_first;
-			h->h_next = history_def_next;
-			h->h_last = history_def_last;
-			h->h_prev = history_def_prev;
-			h->h_curr = history_def_curr;
-			h->h_set = history_def_set;
-			h->h_clear = history_def_clear;
-			h->h_enter = history_def_enter;
-			h->h_add = history_def_add;
-		}
-		return (-1);
-	}
-	if (h->h_next == history_def_next)
-		history_def_clear(h->h_ref, &ev);
-
-	h->h_ent = -1;
-	h->h_first = nh->h_first;
-	h->h_next = nh->h_next;
-	h->h_last = nh->h_last;
-	h->h_prev = nh->h_prev;
-	h->h_curr = nh->h_curr;
-	h->h_set = nh->h_set;
-	h->h_clear = nh->h_clear;
-	h->h_enter = nh->h_enter;
-	h->h_add = nh->h_add;
-
-	return (0);
-}
-
-
-/* history_load():
- *	History load function
- */
-private int
-history_load(History *h, const char *fname)
-{
-	FILE *fp;
-	char *line;
-	size_t sz, max_size;
-	char *ptr;
-	int i = -1;
-	HistEvent ev;
-
-	if ((fp = fopen(fname, "r")) == NULL)
-		return (i);
-
-	if ((line = fgetln(fp, &sz)) == NULL)
-		goto done;
-
-	if (strncmp(line, hist_cookie, sz) != 0)
-		goto done;
-
-	ptr = h_malloc(max_size = 1024);
-	for (i = 0; (line = fgetln(fp, &sz)) != NULL; i++) {
-		char c = line[sz];
-
-		if (sz != 0 && line[sz - 1] == '\n')
-			line[--sz] = '\0';
-		else
-			line[sz] = '\0';
-
-		if (max_size < sz) {
-			max_size = (sz + 1023) & ~1023;
-			ptr = h_realloc(ptr, max_size);
-		}
-		(void) strunvis(ptr, line);
-		line[sz] = c;
-		HENTER(h, &ev, ptr);
-	}
-	h_free(ptr);
-
-done:
-	(void) fclose(fp);
-	return (i);
-}
-
-
-/* history_save():
- *	History save function
- */
-private int
-history_save(History *h, const char *fname)
-{
-	FILE *fp;
-	HistEvent ev;
-	int i = 0, retval;
-	size_t len, max_size;
-	char *ptr;
-
-	if ((fp = fopen(fname, "w")) == NULL)
-		return (-1);
-
-	(void) fchmod(fileno(fp), S_IRUSR|S_IWUSR);
-	(void) fputs(hist_cookie, fp);
-	ptr = h_malloc(max_size = 1024);
-	for (retval = HLAST(h, &ev);
-	    retval != -1;
-	    retval = HPREV(h, &ev), i++) {
-		len = strlen(ev.str) * 4;
-		if (len >= max_size) {
-			max_size = (len + 1023) & 1023;
-			ptr = h_realloc(ptr, max_size);
-		}
-		(void) strvis(ptr, ev.str, VIS_WHITE);
-		(void) fprintf(fp, "%s\n", ev.str);
-	}
-	h_free(ptr);
-	(void) fclose(fp);
-	return (i);
-}
-
-
-/* history_prev_event():
- *	Find the previous event, with number given
- */
-private int
-history_prev_event(History *h, HistEvent *ev, int num)
-{
-	int retval;
-
-	for (retval = HCURR(h, ev); retval != -1; retval = HPREV(h, ev))
-		if (ev->num == num)
-			return (0);
-
-	he_seterrev(ev, _HE_NOT_FOUND);
-	return (-1);
-}
-
-
-/* history_next_event():
- *	Find the next event, with number given
- */
-private int
-history_next_event(History *h, HistEvent *ev, int num)
-{
-	int retval;
-
-	for (retval = HCURR(h, ev); retval != -1; retval = HNEXT(h, ev))
-		if (ev->num == num)
-			return (0);
-
-	he_seterrev(ev, _HE_NOT_FOUND);
-	return (-1);
-}
-
-
-/* history_prev_string():
- *	Find the previous event beginning with string
- */
-private int
-history_prev_string(History *h, HistEvent *ev, const char *str)
-{
-	size_t len = strlen(str);
-	int retval;
-
-	for (retval = HCURR(h, ev); retval != -1; retval = HNEXT(h, ev))
-		if (strncmp(str, ev->str, len) == 0)
-			return (0);
-
-	he_seterrev(ev, _HE_NOT_FOUND);
-	return (-1);
-}
-
-
-/* history_next_string():
- *	Find the next event beginning with string
- */
-private int
-history_next_string(History *h, HistEvent *ev, const char *str)
-{
-	size_t len = strlen(str);
-	int retval;
-
-	for (retval = HCURR(h, ev); retval != -1; retval = HPREV(h, ev))
-		if (strncmp(str, ev->str, len) == 0)
-			return (0);
-
-	he_seterrev(ev, _HE_NOT_FOUND);
-	return (-1);
-}
-
-
-/* history():
- *	User interface to history functions.
- */
-int
-history(History *h, HistEvent *ev, int fun, ...)
-{
-	va_list va;
-	const char *str;
-	int retval;
-
-	va_start(va, fun);
-
-	he_seterrev(ev, _HE_OK);
-
-	switch (fun) {
-	case H_GETSIZE:
-		retval = history_getsize(h, ev);
-		break;
-
-	case H_SETSIZE:
-		retval = history_setsize(h, ev, va_arg(va, int));
-		break;
-
-	case H_ADD:
-		str = va_arg(va, const char *);
-		retval = HADD(h, ev, str);
-		break;
-
-	case H_ENTER:
-		str = va_arg(va, const char *);
-		if ((retval = HENTER(h, ev, str)) != -1)
-			h->h_ent = ev->num;
-		break;
-
-	case H_APPEND:
-		str = va_arg(va, const char *);
-		if ((retval = HSET(h, ev, h->h_ent)) != -1)
-			retval = HADD(h, ev, str);
-		break;
-
-	case H_FIRST:
-		retval = HFIRST(h, ev);
-		break;
-
-	case H_NEXT:
-		retval = HNEXT(h, ev);
-		break;
-
-	case H_LAST:
-		retval = HLAST(h, ev);
-		break;
-
-	case H_PREV:
-		retval = HPREV(h, ev);
-		break;
-
-	case H_CURR:
-		retval = HCURR(h, ev);
-		break;
-
-	case H_SET:
-		retval = HSET(h, ev, va_arg(va, const int));
-		break;
-
-	case H_CLEAR:
-		HCLEAR(h, ev);
-		retval = 0;
-		break;
-
-	case H_LOAD:
-		retval = history_load(h, va_arg(va, const char *));
-		if (retval == -1)
-			he_seterrev(ev, _HE_HIST_READ);
-		break;
-
-	case H_SAVE:
-		retval = history_save(h, va_arg(va, const char *));
-		if (retval == -1)
-			he_seterrev(ev, _HE_HIST_WRITE);
-		break;
-
-	case H_PREV_EVENT:
-		retval = history_prev_event(h, ev, va_arg(va, int));
-		break;
-
-	case H_NEXT_EVENT:
-		retval = history_next_event(h, ev, va_arg(va, int));
-		break;
-
-	case H_PREV_STR:
-		retval = history_prev_string(h, ev, va_arg(va, const char *));
-		break;
-
-	case H_NEXT_STR:
-		retval = history_next_string(h, ev, va_arg(va, const char *));
-		break;
-
-	case H_FUNC:
-	{
-		History hf;
-
-		hf.h_ref = va_arg(va, ptr_t);
-		h->h_ent = -1;
-		hf.h_first = va_arg(va, history_gfun_t);
-		hf.h_next = va_arg(va, history_gfun_t);
-		hf.h_last = va_arg(va, history_gfun_t);
-		hf.h_prev = va_arg(va, history_gfun_t);
-		hf.h_curr = va_arg(va, history_gfun_t);
-		hf.h_set = va_arg(va, history_sfun_t);
-		hf.h_clear = va_arg(va, history_vfun_t);
-		hf.h_enter = va_arg(va, history_efun_t);
-		hf.h_add = va_arg(va, history_efun_t);
-
-		if ((retval = history_set_fun(h, &hf)) == -1)
-			he_seterrev(ev, _HE_PARAM_MISSING);
-		break;
-	}
-
-	case H_END:
-		history_end(h);
-		retval = 0;
-		break;
-
-	default:
-		retval = -1;
-		he_seterrev(ev, _HE_UNKNOWN);
-		break;
-	}
-	va_end(va);
-	return (retval);
-}
diff --git a/main/editline/install-sh b/main/editline/install-sh
deleted file mode 100755
index ebc6691..0000000
--- a/main/editline/install-sh
+++ /dev/null
@@ -1,250 +0,0 @@
-#! /bin/sh
-#
-# install - install a program, script, or datafile
-# This comes from X11R5 (mit/util/scripts/install.sh).
-#
-# Copyright 1991 by the Massachusetts Institute of Technology
-#
-# Permission to use, copy, modify, distribute, and sell this software and its
-# documentation for any purpose is hereby granted without fee, provided that
-# the above copyright notice appear in all copies and that both that
-# copyright notice and this permission notice appear in supporting
-# documentation, and that the name of M.I.T. not be used in advertising or
-# publicity pertaining to distribution of the software without specific,
-# written prior permission.  M.I.T. makes no representations about the
-# suitability of this software for any purpose.  It is provided "as is"
-# without express or implied warranty.
-#
-# Calling this script install-sh is preferred over install.sh, to prevent
-# `make' implicit rules from creating a file called install from it
-# when there is no Makefile.
-#
-# This script is compatible with the BSD install script, but was written
-# from scratch.  It can only install one file at a time, a restriction
-# shared with many OS's install programs.
-
-
-# set DOITPROG to echo to test this script
-
-# Don't use :- since 4.3BSD and earlier shells don't like it.
-doit="${DOITPROG-}"
-
-
-# put in absolute paths if you don't have them in your path; or use env. vars.
-
-mvprog="${MVPROG-mv}"
-cpprog="${CPPROG-cp}"
-chmodprog="${CHMODPROG-chmod}"
-chownprog="${CHOWNPROG-chown}"
-chgrpprog="${CHGRPPROG-chgrp}"
-stripprog="${STRIPPROG-strip}"
-rmprog="${RMPROG-rm}"
-mkdirprog="${MKDIRPROG-mkdir}"
-
-transformbasename=""
-transform_arg=""
-instcmd="$mvprog"
-chmodcmd="$chmodprog 0755"
-chowncmd=""
-chgrpcmd=""
-stripcmd=""
-rmcmd="$rmprog -f"
-mvcmd="$mvprog"
-src=""
-dst=""
-dir_arg=""
-
-while [ x"$1" != x ]; do
-    case $1 in
-	-c) instcmd="$cpprog"
-	    shift
-	    continue;;
-
-	-d) dir_arg=true
-	    shift
-	    continue;;
-
-	-m) chmodcmd="$chmodprog $2"
-	    shift
-	    shift
-	    continue;;
-
-	-o) chowncmd="$chownprog $2"
-	    shift
-	    shift
-	    continue;;
-
-	-g) chgrpcmd="$chgrpprog $2"
-	    shift
-	    shift
-	    continue;;
-
-	-s) stripcmd="$stripprog"
-	    shift
-	    continue;;
-
-	-t=*) transformarg=`echo $1 | sed 's/-t=//'`
-	    shift
-	    continue;;
-
-	-b=*) transformbasename=`echo $1 | sed 's/-b=//'`
-	    shift
-	    continue;;
-
-	*)  if [ x"$src" = x ]
-	    then
-		src=$1
-	    else
-		# this colon is to work around a 386BSD /bin/sh bug
-		:
-		dst=$1
-	    fi
-	    shift
-	    continue;;
-    esac
-done
-
-if [ x"$src" = x ]
-then
-	echo "install:	no input file specified"
-	exit 1
-else
-	true
-fi
-
-if [ x"$dir_arg" != x ]; then
-	dst=$src
-	src=""
-	
-	if [ -d $dst ]; then
-		instcmd=:
-	else
-		instcmd=mkdir
-	fi
-else
-
-# Waiting for this to be detected by the "$instcmd $src $dsttmp" command
-# might cause directories to be created, which would be especially bad 
-# if $src (and thus $dsttmp) contains '*'.
-
-	if [ -f $src -o -d $src ]
-	then
-		true
-	else
-		echo "install:  $src does not exist"
-		exit 1
-	fi
-	
-	if [ x"$dst" = x ]
-	then
-		echo "install:	no destination specified"
-		exit 1
-	else
-		true
-	fi
-
-# If destination is a directory, append the input filename; if your system
-# does not like double slashes in filenames, you may need to add some logic
-
-	if [ -d $dst ]
-	then
-		dst="$dst"/`basename $src`
-	else
-		true
-	fi
-fi
-
-## this sed command emulates the dirname command
-dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`
-
-# Make sure that the destination directory exists.
-#  this part is taken from Noah Friedman's mkinstalldirs script
-
-# Skip lots of stat calls in the usual case.
-if [ ! -d "$dstdir" ]; then
-defaultIFS='	
-'
-IFS="${IFS-${defaultIFS}}"
-
-oIFS="${IFS}"
-# Some sh's can't handle IFS=/ for some reason.
-IFS='%'
-set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`
-IFS="${oIFS}"
-
-pathcomp=''
-
-while [ $# -ne 0 ] ; do
-	pathcomp="${pathcomp}${1}"
-	shift
-
-	if [ ! -d "${pathcomp}" ] ;
-        then
-		$mkdirprog "${pathcomp}"
-	else
-		true
-	fi
-
-	pathcomp="${pathcomp}/"
-done
-fi
-
-if [ x"$dir_arg" != x ]
-then
-	$doit $instcmd $dst &&
-
-	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; else true ; fi &&
-	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&
-	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; else true ; fi &&
-	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; else true ; fi
-else
-
-# If we're going to rename the final executable, determine the name now.
-
-	if [ x"$transformarg" = x ] 
-	then
-		dstfile=`basename $dst`
-	else
-		dstfile=`basename $dst $transformbasename | 
-			sed $transformarg`$transformbasename
-	fi
-
-# don't allow the sed command to completely eliminate the filename
-
-	if [ x"$dstfile" = x ] 
-	then
-		dstfile=`basename $dst`
-	else
-		true
-	fi
-
-# Make a temp file name in the proper directory.
-
-	dsttmp=$dstdir/#inst.$$#
-
-# Move or copy the file name to the temp name
-
-	$doit $instcmd $src $dsttmp &&
-
-	trap "rm -f ${dsttmp}" 0 &&
-
-# and set any options; do chmod last to preserve setuid bits
-
-# If any of these fail, we abort the whole thing.  If we want to
-# ignore errors from any of these, just make sure not to ignore
-# errors from the above "$doit $instcmd $src $dsttmp" command.
-
-	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&
-	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&
-	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&
-	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&
-
-# Now rename the file to the real destination.
-
-	$doit $rmcmd -f $dstdir/$dstfile &&
-	$doit $mvcmd $dsttmp $dstdir/$dstfile 
-
-fi &&
-
-
-exit 0
diff --git a/main/editline/key.c b/main/editline/key.c
deleted file mode 100644
index 0dcdf41..0000000
--- a/main/editline/key.c
+++ /dev/null
@@ -1,687 +0,0 @@
-/*	$NetBSD: key.c,v 1.13 2002/03/18 16:00:55 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)key.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: key.c,v 1.13 2002/03/18 16:00:55 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * key.c: This module contains the procedures for maintaining
- *	  the extended-key map.
- *
- *      An extended-key (key) is a sequence of keystrokes introduced
- *	with an sequence introducer and consisting of an arbitrary
- *	number of characters.  This module maintains a map (the el->el_key.map)
- *	to convert these extended-key sequences into input strs
- *	(XK_STR), editor functions (XK_CMD), or unix commands (XK_EXE).
- *
- *      Warning:
- *	  If key is a substr of some other keys, then the longer
- *	  keys are lost!!  That is, if the keys "abcd" and "abcef"
- *	  are in el->el_key.map, adding the key "abc" will cause the first two
- *	  definitions to be lost.
- *
- *      Restrictions:
- *      -------------
- *      1) It is not possible to have one key that is a
- *	   substr of another.
- */
-#include <string.h>
-#include <stdlib.h>
-
-#include "el.h"
-
-/*
- * The Nodes of the el->el_key.map.  The el->el_key.map is a linked list
- * of these node elements
- */
-struct key_node_t {
-	char		ch;		/* single character of key 	 */
-	int		type;		/* node type			 */
-	key_value_t	val;		/* command code or pointer to str,  */
-					/* if this is a leaf 		 */
-	struct key_node_t *next;	/* ptr to next char of this key  */
-	struct key_node_t *sibling;	/* ptr to another key with same prefix*/
-};
-
-private int		 node_trav(EditLine *, key_node_t *, char *,
-    key_value_t *);
-private int		 node__try(EditLine *, key_node_t *, const char *,
-    key_value_t *, int);
-private key_node_t	*node__get(int);
-private void		 node__put(EditLine *, key_node_t *);
-private int		 node__delete(EditLine *, key_node_t **, const char *);
-private int		 node_lookup(EditLine *, const char *, key_node_t *,
-    int);
-private int		 node_enum(EditLine *, key_node_t *, int);
-private int		 key__decode_char(char *, int, int);
-
-#define	KEY_BUFSIZ	EL_BUFSIZ
-
-
-/* key_init():
- *	Initialize the key maps
- */
-protected int
-key_init(EditLine *el)
-{
-
-	el->el_key.buf = (char *) el_malloc(KEY_BUFSIZ);
-	if (el->el_key.buf == NULL)
-		return (-1);
-	el->el_key.map = NULL;
-	key_reset(el);
-	return (0);
-}
-
-
-/* key_end():
- *	Free the key maps
- */
-protected void
-key_end(EditLine *el)
-{
-
-	el_free((ptr_t) el->el_key.buf);
-	el->el_key.buf = NULL;
-	node__put(el, el->el_key.map);
-	el->el_key.map = NULL;
-}
-
-
-/* key_map_cmd():
- *	Associate cmd with a key value
- */
-protected key_value_t *
-key_map_cmd(EditLine *el, int cmd)
-{
-
-	el->el_key.val.cmd = (el_action_t) cmd;
-	return (&el->el_key.val);
-}
-
-
-/* key_map_str():
- *	Associate str with a key value
- */
-protected key_value_t *
-key_map_str(EditLine *el, char *str)
-{
-
-	el->el_key.val.str = str;
-	return (&el->el_key.val);
-}
-
-
-/* key_reset():
- *	Takes all nodes on el->el_key.map and puts them on free list.  Then
- *	initializes el->el_key.map with arrow keys
- *	[Always bind the ansi arrow keys?]
- */
-protected void
-key_reset(EditLine *el)
-{
-
-	node__put(el, el->el_key.map);
-	el->el_key.map = NULL;
-	return;
-}
-
-
-/* key_get():
- *	Calls the recursive function with entry point el->el_key.map
- *      Looks up *ch in map and then reads characters until a
- *      complete match is found or a mismatch occurs. Returns the
- *      type of the match found (XK_STR, XK_CMD, or XK_EXE).
- *      Returns NULL in val.str and XK_STR for no match.
- *      The last character read is returned in *ch.
- */
-protected int
-key_get(EditLine *el, char *ch, key_value_t *val)
-{
-
-	return (node_trav(el, el->el_key.map, ch, val));
-}
-
-
-/* key_add():
- *      Adds key to the el->el_key.map and associates the value in val with it.
- *      If key is already is in el->el_key.map, the new code is applied to the
- *      existing key. Ntype specifies if code is a command, an
- *      out str or a unix command.
- */
-protected void
-key_add(EditLine *el, const char *key, key_value_t *val, int ntype)
-{
-
-	if (key[0] == '\0') {
-		(void) fprintf(el->el_errfile,
-		    "key_add: Null extended-key not allowed.\n");
-		return;
-	}
-	if (ntype == XK_CMD && val->cmd == ED_SEQUENCE_LEAD_IN) {
-		(void) fprintf(el->el_errfile,
-		    "key_add: sequence-lead-in command not allowed\n");
-		return;
-	}
-	if (el->el_key.map == NULL)
-		/* tree is initially empty.  Set up new node to match key[0] */
-		el->el_key.map = node__get(key[0]);
-			/* it is properly initialized */
-
-	/* Now recurse through el->el_key.map */
-	(void) node__try(el, el->el_key.map, key, val, ntype);
-	return;
-}
-
-
-/* key_clear():
- *
- */
-protected void
-key_clear(EditLine *el, el_action_t *map, const char *in)
-{
-
-	if ((map[(unsigned char)*in] == ED_SEQUENCE_LEAD_IN) &&
-	    ((map == el->el_map.key &&
-	    el->el_map.alt[(unsigned char)*in] != ED_SEQUENCE_LEAD_IN) ||
-	    (map == el->el_map.alt &&
-	    el->el_map.key[(unsigned char)*in] != ED_SEQUENCE_LEAD_IN)))
-		(void) key_delete(el, in);
-}
-
-
-/* key_delete():
- *      Delete the key and all longer keys staring with key, if
- *      they exists.
- */
-protected int
-key_delete(EditLine *el, const char *key)
-{
-
-	if (key[0] == '\0') {
-		(void) fprintf(el->el_errfile,
-		    "key_delete: Null extended-key not allowed.\n");
-		return (-1);
-	}
-	if (el->el_key.map == NULL)
-		return (0);
-
-	(void) node__delete(el, &el->el_key.map, key);
-	return (0);
-}
-
-
-/* key_print():
- *	Print the binding associated with key key.
- *	Print entire el->el_key.map if null
- */
-protected void
-key_print(EditLine *el, const char *key)
-{
-
-	/* do nothing if el->el_key.map is empty and null key specified */
-	if (el->el_key.map == NULL && *key == 0)
-		return;
-
-	el->el_key.buf[0] = '"';
-	if (node_lookup(el, key, el->el_key.map, 1) <= -1)
-		/* key is not bound */
-		(void) fprintf(el->el_errfile, "Unbound extended key \"%s\"\n",
-		    key);
-	return;
-}
-
-
-/* node_trav():
- *	recursively traverses node in tree until match or mismatch is
- * 	found.  May read in more characters.
- */
-private int
-node_trav(EditLine *el, key_node_t *ptr, char *ch, key_value_t *val)
-{
-
-	if (ptr->ch == *ch) {
-		/* match found */
-		if (ptr->next) {
-			/* key not complete so get next char */
-			if (el_getc(el, ch) != 1) {	/* if EOF or error */
-				val->cmd = ED_END_OF_FILE;
-				return (XK_CMD);
-				/* PWP: Pretend we just read an end-of-file */
-			}
-			return (node_trav(el, ptr->next, ch, val));
-		} else {
-			*val = ptr->val;
-			if (ptr->type != XK_CMD)
-				*ch = '\0';
-			return (ptr->type);
-		}
-	} else {
-		/* no match found here */
-		if (ptr->sibling) {
-			/* try next sibling */
-			return (node_trav(el, ptr->sibling, ch, val));
-		} else {
-			/* no next sibling -- mismatch */
-			val->str = NULL;
-			return (XK_STR);
-		}
-	}
-}
-
-
-/* node__try():
- * 	Find a node that matches *str or allocate a new one
- */
-private int
-node__try(EditLine *el, key_node_t *ptr, const char *str, key_value_t *val, int ntype)
-{
-
-	if (ptr->ch != *str) {
-		key_node_t *xm;
-
-		for (xm = ptr; xm->sibling != NULL; xm = xm->sibling)
-			if (xm->sibling->ch == *str)
-				break;
-		if (xm->sibling == NULL)
-			xm->sibling = node__get(*str);	/* setup new node */
-		ptr = xm->sibling;
-	}
-	if (*++str == '\0') {
-		/* we're there */
-		if (ptr->next != NULL) {
-			node__put(el, ptr->next);
-				/* lose longer keys with this prefix */
-			ptr->next = NULL;
-		}
-		switch (ptr->type) {
-		case XK_CMD:
-		case XK_NOD:
-			break;
-		case XK_STR:
-		case XK_EXE:
-			if (ptr->val.str)
-				el_free((ptr_t) ptr->val.str);
-			break;
-		default:
-			EL_ABORT((el->el_errfile, "Bad XK_ type %d\n",
-			    ptr->type));
-			break;
-		}
-
-		switch (ptr->type = ntype) {
-		case XK_CMD:
-			ptr->val = *val;
-			break;
-		case XK_STR:
-		case XK_EXE:
-			ptr->val.str = strdup(val->str);
-			break;
-		default:
-			EL_ABORT((el->el_errfile, "Bad XK_ type %d\n", ntype));
-			break;
-		}
-	} else {
-		/* still more chars to go */
-		if (ptr->next == NULL)
-			ptr->next = node__get(*str);	/* setup new node */
-		(void) node__try(el, ptr->next, str, val, ntype);
-	}
-	return (0);
-}
-
-
-/* node__delete():
- *	Delete node that matches str
- */
-private int
-node__delete(EditLine *el, key_node_t **inptr, const char *str)
-{
-	key_node_t *ptr;
-	key_node_t *prev_ptr = NULL;
-
-	ptr = *inptr;
-
-	if (ptr->ch != *str) {
-		key_node_t *xm;
-
-		for (xm = ptr; xm->sibling != NULL; xm = xm->sibling)
-			if (xm->sibling->ch == *str)
-				break;
-		if (xm->sibling == NULL)
-			return (0);
-		prev_ptr = xm;
-		ptr = xm->sibling;
-	}
-	if (*++str == '\0') {
-		/* we're there */
-		if (prev_ptr == NULL)
-			*inptr = ptr->sibling;
-		else
-			prev_ptr->sibling = ptr->sibling;
-		ptr->sibling = NULL;
-		node__put(el, ptr);
-		return (1);
-	} else if (ptr->next != NULL &&
-	    node__delete(el, &ptr->next, str) == 1) {
-		if (ptr->next != NULL)
-			return (0);
-		if (prev_ptr == NULL)
-			*inptr = ptr->sibling;
-		else
-			prev_ptr->sibling = ptr->sibling;
-		ptr->sibling = NULL;
-		node__put(el, ptr);
-		return (1);
-	} else {
-		return (0);
-	}
-}
-
-
-/* node__put():
- *	Puts a tree of nodes onto free list using free(3).
- */
-private void
-node__put(EditLine *el, key_node_t *ptr)
-{
-	if (ptr == NULL)
-		return;
-
-	if (ptr->next != NULL) {
-		node__put(el, ptr->next);
-		ptr->next = NULL;
-	}
-	node__put(el, ptr->sibling);
-
-	switch (ptr->type) {
-	case XK_CMD:
-	case XK_NOD:
-		break;
-	case XK_EXE:
-	case XK_STR:
-		if (ptr->val.str != NULL)
-			el_free((ptr_t) ptr->val.str);
-		break;
-	default:
-		EL_ABORT((el->el_errfile, "Bad XK_ type %d\n", ptr->type));
-		break;
-	}
-	el_free((ptr_t) ptr);
-}
-
-
-/* node__get():
- *	Returns pointer to an key_node_t for ch.
- */
-private key_node_t *
-node__get(int ch)
-{
-	key_node_t *ptr;
-
-	ptr = (key_node_t *) el_malloc((size_t) sizeof(key_node_t));
-	if (ptr == NULL)
-		return NULL;
-	ptr->ch = ch;
-	ptr->type = XK_NOD;
-	ptr->val.str = NULL;
-	ptr->next = NULL;
-	ptr->sibling = NULL;
-	return (ptr);
-}
-
-
-
-/* node_lookup():
- *	look for the str starting at node ptr.
- *	Print if last node
- */
-private int
-node_lookup(EditLine *el, const char *str, key_node_t *ptr, int cnt)
-{
-	int ncnt;
-
-	if (ptr == NULL)
-		return (-1);	/* cannot have null ptr */
-
-	if (*str == 0) {
-		/* no more chars in str.  node_enum from here. */
-		(void) node_enum(el, ptr, cnt);
-		return (0);
-	} else {
-		/* If match put this char into el->el_key.buf.  Recurse */
-		if (ptr->ch == *str) {
-			/* match found */
-			ncnt = key__decode_char(el->el_key.buf, cnt,
-			    (unsigned char) ptr->ch);
-			if (ptr->next != NULL)
-				/* not yet at leaf */
-				return (node_lookup(el, str + 1, ptr->next,
-				    ncnt + 1));
-			else {
-			    /* next node is null so key should be complete */
-				if (str[1] == 0) {
-					el->el_key.buf[ncnt + 1] = '"';
-					el->el_key.buf[ncnt + 2] = '\0';
-					key_kprint(el, el->el_key.buf,
-					    &ptr->val, ptr->type);
-					return (0);
-				} else
-					return (-1);
-					/* mismatch -- str still has chars */
-			}
-		} else {
-			/* no match found try sibling */
-			if (ptr->sibling)
-				return (node_lookup(el, str, ptr->sibling,
-				    cnt));
-			else
-				return (-1);
-		}
-	}
-}
-
-
-/* node_enum():
- *	Traverse the node printing the characters it is bound in buffer
- */
-private int
-node_enum(EditLine *el, key_node_t *ptr, int cnt)
-{
-	int ncnt;
-
-	if (cnt >= KEY_BUFSIZ - 5) {	/* buffer too small */
-		el->el_key.buf[++cnt] = '"';
-		el->el_key.buf[++cnt] = '\0';
-		(void) fprintf(el->el_errfile,
-		    "Some extended keys too long for internal print buffer");
-		(void) fprintf(el->el_errfile, " \"%s...\"\n", el->el_key.buf);
-		return (0);
-	}
-	if (ptr == NULL) {
-#ifdef DEBUG_EDIT
-		(void) fprintf(el->el_errfile,
-		    "node_enum: BUG!! Null ptr passed\n!");
-#endif
-		return (-1);
-	}
-	/* put this char at end of str */
-	ncnt = key__decode_char(el->el_key.buf, cnt, (unsigned char) ptr->ch);
-	if (ptr->next == NULL) {
-		/* print this key and function */
-		el->el_key.buf[ncnt + 1] = '"';
-		el->el_key.buf[ncnt + 2] = '\0';
-		key_kprint(el, el->el_key.buf, &ptr->val, ptr->type);
-	} else
-		(void) node_enum(el, ptr->next, ncnt + 1);
-
-	/* go to sibling if there is one */
-	if (ptr->sibling)
-		(void) node_enum(el, ptr->sibling, cnt);
-	return (0);
-}
-
-
-/* key_kprint():
- *	Print the specified key and its associated
- *	function specified by val
- */
-protected void
-key_kprint(EditLine *el, const char *key, key_value_t *val, int ntype)
-{
-	el_bindings_t *fp;
-	char unparsbuf[EL_BUFSIZ];
-	static const char fmt[] = "%-15s->  %s\n";
-
-	if (val != NULL)
-		switch (ntype) {
-		case XK_STR:
-		case XK_EXE:
-			(void) fprintf(el->el_outfile, fmt, key,
-			    key__decode_str(val->str, unparsbuf,
-				ntype == XK_STR ? "\"\"" : "[]"));
-			break;
-		case XK_CMD:
-			for (fp = el->el_map.help; fp->name; fp++)
-				if (val->cmd == fp->func) {
-					(void) fprintf(el->el_outfile, fmt,
-					    key, fp->name);
-					break;
-				}
-#ifdef DEBUG_KEY
-			if (fp->name == NULL)
-				(void) fprintf(el->el_outfile,
-				    "BUG! Command not found.\n");
-#endif
-
-			break;
-		default:
-			EL_ABORT((el->el_errfile, "Bad XK_ type %d\n", ntype));
-			break;
-		}
-	else
-		(void) fprintf(el->el_outfile, fmt, key, "no input");
-}
-
-
-/* key__decode_char():
- *	Put a printable form of char in buf.
- */
-private int
-key__decode_char(char *buf, int cnt, int ch)
-{
-	if (ch == 0) {
-		buf[cnt++] = '^';
-		buf[cnt] = '@';
-		return (cnt);
-	}
-	if (iscntrl(ch)) {
-		buf[cnt++] = '^';
-		if (ch == '\177')
-			buf[cnt] = '?';
-		else
-			buf[cnt] = ch | 0100;
-	} else if (ch == '^') {
-		buf[cnt++] = '\\';
-		buf[cnt] = '^';
-	} else if (ch == '\\') {
-		buf[cnt++] = '\\';
-		buf[cnt] = '\\';
-	} else if (ch == ' ' || (isprint(ch) && !isspace(ch))) {
-		buf[cnt] = ch;
-	} else {
-		buf[cnt++] = '\\';
-		buf[cnt++] = (((unsigned int) ch >> 6) & 7) + '0';
-		buf[cnt++] = (((unsigned int) ch >> 3) & 7) + '0';
-		buf[cnt] = (ch & 7) + '0';
-	}
-	return (cnt);
-}
-
-
-/* key__decode_str():
- *	Make a printable version of the ey
- */
-protected char *
-key__decode_str(const char *str, char *buf, const char *sep)
-{
-	char *b;
-	const char *p;
-
-	b = buf;
-	if (sep[0] != '\0')
-		*b++ = sep[0];
-	if (*str == 0) {
-		*b++ = '^';
-		*b++ = '@';
-		if (sep[0] != '\0' && sep[1] != '\0')
-			*b++ = sep[1];
-		*b++ = 0;
-		return (buf);
-	}
-	for (p = str; *p != 0; p++) {
-		if (iscntrl((unsigned char) *p)) {
-			*b++ = '^';
-			if (*p == '\177')
-				*b++ = '?';
-			else
-				*b++ = *p | 0100;
-		} else if (*p == '^' || *p == '\\') {
-			*b++ = '\\';
-			*b++ = *p;
-		} else if (*p == ' ' || (isprint((unsigned char) *p) &&
-			!isspace((unsigned char) *p))) {
-			*b++ = *p;
-		} else {
-			*b++ = '\\';
-			*b++ = (((unsigned int) *p >> 6) & 7) + '0';
-			*b++ = (((unsigned int) *p >> 3) & 7) + '0';
-			*b++ = (*p & 7) + '0';
-		}
-	}
-	if (sep[0] != '\0' && sep[1] != '\0')
-		*b++ = sep[1];
-	*b++ = 0;
-	return (buf);		/* should check for overflow */
-}
diff --git a/main/editline/key.h b/main/editline/key.h
deleted file mode 100644
index 80d8626..0000000
--- a/main/editline/key.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/*	$NetBSD: key.h,v 1.6 2002/03/18 16:00:55 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)key.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.key.h: Key macro header
- */
-#ifndef _h_el_key
-#define	_h_el_key
-
-typedef union key_value_t {
-	el_action_t	 cmd;	/* If it is a command the #	*/
-	char		*str;	/* If it is a string...		*/
-} key_value_t;
-
-typedef struct key_node_t key_node_t;
-
-typedef struct el_key_t {
-	char		*buf;	/* Key print buffer		*/
-	key_node_t	*map;	/* Key map			*/
-	key_value_t	 val;	/* Local conversion buffer	*/
-} el_key_t;
-
-#define	XK_CMD	0
-#define	XK_STR	1
-#define	XK_NOD	2
-#define	XK_EXE	3
-
-protected int		 key_init(EditLine *);
-protected void		 key_end(EditLine *);
-protected key_value_t	*key_map_cmd(EditLine *, int);
-protected key_value_t	*key_map_str(EditLine *, char *);
-protected void		 key_reset(EditLine *);
-protected int		 key_get(EditLine *, char *, key_value_t *);
-protected void		 key_add(EditLine *, const char *, key_value_t *, int);
-protected void		 key_clear(EditLine *, el_action_t *, const char *);
-protected int		 key_delete(EditLine *, const char *);
-protected void		 key_print(EditLine *, const char *);
-protected void	         key_kprint(EditLine *, const char *, key_value_t *,
-    int);
-protected char		*key__decode_str(const char *, char *, const char *);
-
-#endif /* _h_el_key */
diff --git a/main/editline/makelist.in b/main/editline/makelist.in
deleted file mode 100644
index 9a44dc7..0000000
--- a/main/editline/makelist.in
+++ /dev/null
@@ -1,254 +0,0 @@
-#!/bin/sh -
-#	$NetBSD: makelist,v 1.7 2001/01/09 19:22:31 jdolecek Exp $
-#
-# Copyright (c) 1992, 1993
-#	The Regents of the University of California.  All rights reserved.
-#
-# This code is derived from software contributed to Berkeley by
-# Christos Zoulas of Cornell University.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions
-# are met:
-# 1. Redistributions of source code must retain the above copyright
-#    notice, this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright
-#    notice, this list of conditions and the following disclaimer in the
-#    documentation and/or other materials provided with the distribution.
-# 3. All advertising materials mentioning features or use of this software
-#    must display the following acknowledgement:
-#	This product includes software developed by the University of
-#	California, Berkeley and its contributors.
-# 4. Neither the name of the University nor the names of its contributors
-#    may be used to endorse or promote products derived from this software
-#    without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
-# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
-# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-# SUCH DAMAGE.
-#
-#	@(#)makelist	5.3 (Berkeley) 6/4/93
-
-# makelist.sh: Automatically generate header files...
-
-AWK=@AWK@
-USAGE="Usage: $0 -h|-e|-fc|-fh|-bc|-bh|-m <filenames>"
-
-if [ "x$1" = "x" ]
-then
-    echo $USAGE 1>&2
-    exit 1
-fi
-
-FLAG="$1"
-shift
-
-FILES="$@"
-
-case $FLAG in
-
-#	generate foo.h file from foo.c
-#
--h)
-    set - `echo $FILES | sed -e 's/\\./_/g'`
-    hdr="_h_`basename $1`"
-    cat $FILES | $AWK '
-	BEGIN {
-	    printf("/* Automatically generated file, do not edit */\n");
-	    printf("#ifndef %s\n#define %s\n", "'$hdr'", "'$hdr'");
-	}
-	/\(\):/ {
-	    pr = substr($2, 1, 2);
-	    if (pr == "vi" || pr == "em" || pr == "ed") {
-		name = substr($2, 1, length($2) - 3);
-#
-# XXX:	need a space between name and prototype so that -fc and -fh
-#	parsing is much easier
-#
-		printf("protected el_action_t\t%s (EditLine *, int);\n", name);
-	    }
-	}
-	END {
-	    printf("#endif /* %s */\n", "'$hdr'");
-	}'
-	;;
-
-#	generate help.c from various .c files
-#
--bc)
-    cat $FILES | $AWK '
-	BEGIN {
-	    printf("/* Automatically generated file, do not edit */\n");
-	    printf("#include \"sys.h\"\n#include \"el.h\"\n");
-	    printf("private const struct el_bindings_t el_func_help[] = {\n");
-	    low = "abcdefghijklmnopqrstuvwxyz_";
-	    high = "ABCDEFGHIJKLMNOPQRSTUVWXYZ_";
-	    for (i = 1; i <= length(low); i++)
-		tr[substr(low, i, 1)] = substr(high, i, 1);
-	}
-	/\(\):/ {
-	    pr = substr($2, 1, 2);
-	    if (pr == "vi" || pr == "em" || pr == "ed") {
-		name = substr($2, 1, length($2) - 3);
-		uname = "";
-		fname = "";
-		for (i = 1; i <= length(name); i++) {
-		    s = substr(name, i, 1);
-		    uname = uname tr[s];
-		    if (s == "_")
-			s = "-";
-		    fname = fname s;
-		}
-
-		printf("    { %-30.30s %-30.30s\n","\"" fname "\",", uname ",");
-		ok = 1;
-	    }
-	}
-	/^ \*/ {
-	    if (ok) {
-		printf("      \"");
-		for (i = 2; i < NF; i++)
-		    printf("%s ", $i);
-		printf("%s\" },\n", $i);
-		ok = 0;
-	    }
-	}
-	END {
-	    printf("    { NULL, 0, NULL }\n");
-	    printf("};\n");
-	    printf("\nprotected const el_bindings_t* help__get()");
-	    printf("{ return el_func_help; }\n");
-	}'
-	;;
-
-#	generate help.h from various .c files
-#
--bh)
-    $AWK '
-	BEGIN {
-	    printf("/* Automatically generated file, do not edit */\n");
-	    printf("#ifndef _h_help_c\n#define _h_help_c\n");
-	    printf("protected const el_bindings_t *help__get(void);\n");
-	    printf("#endif /* _h_help_c */\n");
-	}' /dev/null
-	;;
-
-#	generate fcns.h from various .h files
-#
--fh)
-    cat $FILES | $AWK '/el_action_t/ { print $3 }' | \
-    sort | tr '[:lower:]' '[:upper:]' | $AWK '
-	BEGIN {
-	    printf("/* Automatically generated file, do not edit */\n");
-	    printf("#ifndef _h_fcns_c\n#define _h_fcns_c\n");
-	    count = 0;
-	}
-	{
-	    printf("#define\t%-30.30s\t%3d\n", $1, count++);
-	}
-	END {
-	    printf("#define\t%-30.30s\t%3d\n", "EL_NUM_FCNS", count);
-
-	    printf("typedef el_action_t (*el_func_t)(EditLine *, int);");
-	    printf("\nprotected const el_func_t* func__get(void);\n");
-	    printf("#endif /* _h_fcns_c */\n");
-	}'
-	;;
-
-#	generate fcns.c from various .h files
-#
--fc)
-    cat $FILES | $AWK '/el_action_t/ { print $3 }' | sort | $AWK '
-	BEGIN {
-	    printf("/* Automatically generated file, do not edit */\n");
-	    printf("#include \"sys.h\"\n#include \"el.h\"\n");
-	    printf("private const el_func_t el_func[] = {");
-	    maxlen = 80;
-	    needn = 1;
-	    len = 0;
-	}
-	{
-	    clen = 25 + 2;
-	    len += clen;
-	    if (len >= maxlen)
-		needn = 1;
-	    if (needn) {
-		printf("\n    ");
-		needn = 0;
-		len = 4 + clen;
-	    }
-	    s = $1 ",";
-	    printf("%-26.26s ", s);
-	}
-	END {
-	    printf("\n};\n");
-	    printf("\nprotected const el_func_t* func__get() { return el_func; }\n");
-	}'
-	;;
-
-#	generate editline.c from various .c files
-#
--e)
-	echo "$FILES" | tr ' ' '\012' | $AWK '
-	BEGIN {
-	    printf("/* Automatically generated file, do not edit */\n");
-	    printf("#define protected static\n");
-	    printf("#define SCCSID\n");
-	}
-	{
-	    printf("#include \"%s\"\n", $1);
-	}'
-	;;
-
-#	generate man page fragment from various .c files
-#
--m)
-    cat $FILES | $AWK '
-	BEGIN {
-	    printf(".\\\" Section automatically generated with makelist\n");
-	    printf(".Bl -tag -width 4n\n");
-	}
-	/\(\):/ {
-	    pr = substr($2, 1, 2);
-	    if (pr == "vi" || pr == "em" || pr == "ed") {
-		name = substr($2, 1, length($2) - 3);
-		fname = "";
-		for (i = 1; i <= length(name); i++) {
-		    s = substr(name, i, 1);
-		    if (s == "_")
-			s = "-";
-		    fname = fname s;
-		}
-
-		printf(".It Ic %s\n", fname);
-		ok = 1;
-	    }
-	}
-	/^ \*/ {
-	    if (ok) {
-		for (i = 2; i < NF; i++)
-		    printf("%s ", $i);
-		printf("%s.\n", $i);
-		ok = 0;
-	    }
-	}
-	END {
-	    printf(".El\n");
-	    printf(".\\\" End of section automatically generated with makelist\n");
-	}'
-	;;
-
-*)
-    echo $USAGE 1>&2
-    exit 1
-    ;;
-
-esac
diff --git a/main/editline/map.c b/main/editline/map.c
deleted file mode 100644
index 4187cb5..0000000
--- a/main/editline/map.c
+++ /dev/null
@@ -1,1418 +0,0 @@
-/*	$NetBSD: map.c,v 1.15 2002/03/18 16:00:55 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)map.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: map.c,v 1.15 2002/03/18 16:00:55 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * map.c: Editor function definitions
- */
-#include <stdlib.h>
-#include "el.h"
-
-#define	N_KEYS 256
-
-private void	map_print_key(EditLine *, el_action_t *, const char *);
-private void	map_print_some_keys(EditLine *, el_action_t *, int, int);
-private void	map_print_all_keys(EditLine *);
-private void	map_init_nls(EditLine *);
-private void	map_init_meta(EditLine *);
-
-/* keymap tables ; should be N_KEYS*sizeof(KEYCMD) bytes long */
-
-
-private const el_action_t  el_map_emacs[] = {
-	/*   0 */	EM_SET_MARK,		/* ^@ */
-	/*   1 */	ED_MOVE_TO_BEG,		/* ^A */
-	/*   2 */	ED_PREV_CHAR,		/* ^B */
-	/*   3 */	ED_TTY_SIGINT,		/* ^C */
-	/*   4 */	EM_DELETE_OR_LIST,	/* ^D */
-	/*   5 */	ED_MOVE_TO_END,		/* ^E */
-	/*   6 */	ED_NEXT_CHAR,		/* ^F */
-	/*   7 */	ED_UNASSIGNED,		/* ^G */
-	/*   8 */	ED_DELETE_PREV_CHAR,	/* ^H */
-	/*   9 */	ED_UNASSIGNED,		/* ^I */
-	/*  10 */	ED_NEWLINE,		/* ^J */
-	/*  11 */	ED_KILL_LINE,		/* ^K */
-	/*  12 */	ED_CLEAR_SCREEN,	/* ^L */
-	/*  13 */	ED_NEWLINE,		/* ^M */
-	/*  14 */	ED_NEXT_HISTORY,	/* ^N */
-	/*  15 */	ED_TTY_FLUSH_OUTPUT,	/* ^O */
-	/*  16 */	ED_PREV_HISTORY,	/* ^P */
-	/*  17 */	ED_TTY_START_OUTPUT,	/* ^Q */
-	/*  18 */	ED_REDISPLAY,		/* ^R */
-	/*  19 */	ED_TTY_STOP_OUTPUT,	/* ^S */
-	/*  20 */	ED_TRANSPOSE_CHARS,	/* ^T */
-	/*  21 */	EM_KILL_LINE,		/* ^U */
-	/*  22 */	ED_QUOTED_INSERT,	/* ^V */
-	/*  23 */	EM_KILL_REGION,		/* ^W */
-	/*  24 */	ED_SEQUENCE_LEAD_IN,	/* ^X */
-	/*  25 */	EM_YANK,		/* ^Y */
-	/*  26 */	ED_TTY_SIGTSTP,		/* ^Z */
-	/*  27 */	EM_META_NEXT,		/* ^[ */
-	/*  28 */	ED_TTY_SIGQUIT,		/* ^\ */
-	/*  29 */	ED_TTY_DSUSP,		/* ^] */
-	/*  30 */	ED_UNASSIGNED,		/* ^^ */
-	/*  31 */	ED_UNASSIGNED,		/* ^_ */
-	/*  32 */	ED_INSERT,		/* SPACE */
-	/*  33 */	ED_INSERT,		/* ! */
-	/*  34 */	ED_INSERT,		/* " */
-	/*  35 */	ED_INSERT,		/* # */
-	/*  36 */	ED_INSERT,		/* $ */
-	/*  37 */	ED_INSERT,		/* % */
-	/*  38 */	ED_INSERT,		/* & */
-	/*  39 */	ED_INSERT,		/* ' */
-	/*  40 */	ED_INSERT,		/* ( */
-	/*  41 */	ED_INSERT,		/* ) */
-	/*  42 */	ED_INSERT,		/* * */
-	/*  43 */	ED_INSERT,		/* + */
-	/*  44 */	ED_INSERT,		/* , */
-	/*  45 */	ED_INSERT,		/* - */
-	/*  46 */	ED_INSERT,		/* . */
-	/*  47 */	ED_INSERT,		/* / */
-	/*  48 */	ED_DIGIT,		/* 0 */
-	/*  49 */	ED_DIGIT,		/* 1 */
-	/*  50 */	ED_DIGIT,		/* 2 */
-	/*  51 */	ED_DIGIT,		/* 3 */
-	/*  52 */	ED_DIGIT,		/* 4 */
-	/*  53 */	ED_DIGIT,		/* 5 */
-	/*  54 */	ED_DIGIT,		/* 6 */
-	/*  55 */	ED_DIGIT,		/* 7 */
-	/*  56 */	ED_DIGIT,		/* 8 */
-	/*  57 */	ED_DIGIT,		/* 9 */
-	/*  58 */	ED_INSERT,		/* : */
-	/*  59 */	ED_INSERT,		/* ; */
-	/*  60 */	ED_INSERT,		/* < */
-	/*  61 */	ED_INSERT,		/* = */
-	/*  62 */	ED_INSERT,		/* > */
-	/*  63 */	ED_INSERT,		/* ? */
-	/*  64 */	ED_INSERT,		/* @ */
-	/*  65 */	ED_INSERT,		/* A */
-	/*  66 */	ED_INSERT,		/* B */
-	/*  67 */	ED_INSERT,		/* C */
-	/*  68 */	ED_INSERT,		/* D */
-	/*  69 */	ED_INSERT,		/* E */
-	/*  70 */	ED_INSERT,		/* F */
-	/*  71 */	ED_INSERT,		/* G */
-	/*  72 */	ED_INSERT,		/* H */
-	/*  73 */	ED_INSERT,		/* I */
-	/*  74 */	ED_INSERT,		/* J */
-	/*  75 */	ED_INSERT,		/* K */
-	/*  76 */	ED_INSERT,		/* L */
-	/*  77 */	ED_INSERT,		/* M */
-	/*  78 */	ED_INSERT,		/* N */
-	/*  79 */	ED_INSERT,		/* O */
-	/*  80 */	ED_INSERT,		/* P */
-	/*  81 */	ED_INSERT,		/* Q */
-	/*  82 */	ED_INSERT,		/* R */
-	/*  83 */	ED_INSERT,		/* S */
-	/*  84 */	ED_INSERT,		/* T */
-	/*  85 */	ED_INSERT,		/* U */
-	/*  86 */	ED_INSERT,		/* V */
-	/*  87 */	ED_INSERT,		/* W */
-	/*  88 */	ED_INSERT,		/* X */
-	/*  89 */	ED_INSERT,		/* Y */
-	/*  90 */	ED_INSERT,		/* Z */
-	/*  91 */	ED_INSERT,		/* [ */
-	/*  92 */	ED_INSERT,		/* \ */
-	/*  93 */	ED_INSERT,		/* ] */
-	/*  94 */	ED_INSERT,		/* ^ */
-	/*  95 */	ED_INSERT,		/* _ */
-	/*  96 */	ED_INSERT,		/* ` */
-	/*  97 */	ED_INSERT,		/* a */
-	/*  98 */	ED_INSERT,		/* b */
-	/*  99 */	ED_INSERT,		/* c */
-	/* 100 */	ED_INSERT,		/* d */
-	/* 101 */	ED_INSERT,		/* e */
-	/* 102 */	ED_INSERT,		/* f */
-	/* 103 */	ED_INSERT,		/* g */
-	/* 104 */	ED_INSERT,		/* h */
-	/* 105 */	ED_INSERT,		/* i */
-	/* 106 */	ED_INSERT,		/* j */
-	/* 107 */	ED_INSERT,		/* k */
-	/* 108 */	ED_INSERT,		/* l */
-	/* 109 */	ED_INSERT,		/* m */
-	/* 110 */	ED_INSERT,		/* n */
-	/* 111 */	ED_INSERT,		/* o */
-	/* 112 */	ED_INSERT,		/* p */
-	/* 113 */	ED_INSERT,		/* q */
-	/* 114 */	ED_INSERT,		/* r */
-	/* 115 */	ED_INSERT,		/* s */
-	/* 116 */	ED_INSERT,		/* t */
-	/* 117 */	ED_INSERT,		/* u */
-	/* 118 */	ED_INSERT,		/* v */
-	/* 119 */	ED_INSERT,		/* w */
-	/* 120 */	ED_INSERT,		/* x */
-	/* 121 */	ED_INSERT,		/* y */
-	/* 122 */	ED_INSERT,		/* z */
-	/* 123 */	ED_INSERT,		/* { */
-	/* 124 */	ED_INSERT,		/* | */
-	/* 125 */	ED_INSERT,		/* } */
-	/* 126 */	ED_INSERT,		/* ~ */
-	/* 127 */	ED_DELETE_PREV_CHAR,	/* ^? */
-	/* 128 */	ED_UNASSIGNED,		/* M-^@ */
-	/* 129 */	ED_UNASSIGNED,		/* M-^A */
-	/* 130 */	ED_UNASSIGNED,		/* M-^B */
-	/* 131 */	ED_UNASSIGNED,		/* M-^C */
-	/* 132 */	ED_UNASSIGNED,		/* M-^D */
-	/* 133 */	ED_UNASSIGNED,		/* M-^E */
-	/* 134 */	ED_UNASSIGNED,		/* M-^F */
-	/* 135 */	ED_UNASSIGNED,		/* M-^G */
-	/* 136 */	ED_DELETE_PREV_WORD,	/* M-^H */
-	/* 137 */	ED_UNASSIGNED,		/* M-^I */
-	/* 138 */	ED_UNASSIGNED,		/* M-^J */
-	/* 139 */	ED_UNASSIGNED,		/* M-^K */
-	/* 140 */	ED_CLEAR_SCREEN,	/* M-^L */
-	/* 141 */	ED_UNASSIGNED,		/* M-^M */
-	/* 142 */	ED_UNASSIGNED,		/* M-^N */
-	/* 143 */	ED_UNASSIGNED,		/* M-^O */
-	/* 144 */	ED_UNASSIGNED,		/* M-^P */
-	/* 145 */	ED_UNASSIGNED,		/* M-^Q */
-	/* 146 */	ED_UNASSIGNED,		/* M-^R */
-	/* 147 */	ED_UNASSIGNED,		/* M-^S */
-	/* 148 */	ED_UNASSIGNED,		/* M-^T */
-	/* 149 */	ED_UNASSIGNED,		/* M-^U */
-	/* 150 */	ED_UNASSIGNED,		/* M-^V */
-	/* 151 */	ED_UNASSIGNED,		/* M-^W */
-	/* 152 */	ED_UNASSIGNED,		/* M-^X */
-	/* 153 */	ED_UNASSIGNED,		/* M-^Y */
-	/* 154 */	ED_UNASSIGNED,		/* M-^Z */
-	/* 155 */	ED_UNASSIGNED,		/* M-^[ */
-	/* 156 */	ED_UNASSIGNED,		/* M-^\ */
-	/* 157 */	ED_UNASSIGNED,		/* M-^] */
-	/* 158 */	ED_UNASSIGNED,		/* M-^^ */
-	/* 159 */	EM_COPY_PREV_WORD,	/* M-^_ */
-	/* 160 */	ED_UNASSIGNED,		/* M-SPACE */
-	/* 161 */	ED_UNASSIGNED,		/* M-! */
-	/* 162 */	ED_UNASSIGNED,		/* M-" */
-	/* 163 */	ED_UNASSIGNED,		/* M-# */
-	/* 164 */	ED_UNASSIGNED,		/* M-$ */
-	/* 165 */	ED_UNASSIGNED,		/* M-% */
-	/* 166 */	ED_UNASSIGNED,		/* M-& */
-	/* 167 */	ED_UNASSIGNED,		/* M-' */
-	/* 168 */	ED_UNASSIGNED,		/* M-( */
-	/* 169 */	ED_UNASSIGNED,		/* M-) */
-	/* 170 */	ED_UNASSIGNED,		/* M-* */
-	/* 171 */	ED_UNASSIGNED,		/* M-+ */
-	/* 172 */	ED_UNASSIGNED,		/* M-, */
-	/* 173 */	ED_UNASSIGNED,		/* M-- */
-	/* 174 */	ED_UNASSIGNED,		/* M-. */
-	/* 175 */	ED_UNASSIGNED,		/* M-/ */
-	/* 176 */	ED_ARGUMENT_DIGIT,	/* M-0 */
-	/* 177 */	ED_ARGUMENT_DIGIT,	/* M-1 */
-	/* 178 */	ED_ARGUMENT_DIGIT,	/* M-2 */
-	/* 179 */	ED_ARGUMENT_DIGIT,	/* M-3 */
-	/* 180 */	ED_ARGUMENT_DIGIT,	/* M-4 */
-	/* 181 */	ED_ARGUMENT_DIGIT,	/* M-5 */
-	/* 182 */	ED_ARGUMENT_DIGIT,	/* M-6 */
-	/* 183 */	ED_ARGUMENT_DIGIT,	/* M-7 */
-	/* 184 */	ED_ARGUMENT_DIGIT,	/* M-8 */
-	/* 185 */	ED_ARGUMENT_DIGIT,	/* M-9 */
-	/* 186 */	ED_UNASSIGNED,		/* M-: */
-	/* 187 */	ED_UNASSIGNED,		/* M-; */
-	/* 188 */	ED_UNASSIGNED,		/* M-< */
-	/* 189 */	ED_UNASSIGNED,		/* M-= */
-	/* 190 */	ED_UNASSIGNED,		/* M-> */
-	/* 191 */	ED_UNASSIGNED,		/* M-? */
-	/* 192 */	ED_UNASSIGNED,		/* M-@ */
-	/* 193 */	ED_UNASSIGNED,		/* M-A */
-	/* 194 */	ED_PREV_WORD,		/* M-B */
-	/* 195 */	EM_CAPITOL_CASE,	/* M-C */
-	/* 196 */	EM_DELETE_NEXT_WORD,	/* M-D */
-	/* 197 */	ED_UNASSIGNED,		/* M-E */
-	/* 198 */	EM_NEXT_WORD,		/* M-F */
-	/* 199 */	ED_UNASSIGNED,		/* M-G */
-	/* 200 */	ED_UNASSIGNED,		/* M-H */
-	/* 201 */	ED_UNASSIGNED,		/* M-I */
-	/* 202 */	ED_UNASSIGNED,		/* M-J */
-	/* 203 */	ED_UNASSIGNED,		/* M-K */
-	/* 204 */	EM_LOWER_CASE,		/* M-L */
-	/* 205 */	ED_UNASSIGNED,		/* M-M */
-	/* 206 */	ED_SEARCH_NEXT_HISTORY,	/* M-N */
-	/* 207 */	ED_SEQUENCE_LEAD_IN,	/* M-O */
-	/* 208 */	ED_SEARCH_PREV_HISTORY,	/* M-P */
-	/* 209 */	ED_UNASSIGNED,		/* M-Q */
-	/* 210 */	ED_UNASSIGNED,		/* M-R */
-	/* 211 */	ED_UNASSIGNED,		/* M-S */
-	/* 212 */	ED_UNASSIGNED,		/* M-T */
-	/* 213 */	EM_UPPER_CASE,		/* M-U */
-	/* 214 */	ED_UNASSIGNED,		/* M-V */
-	/* 215 */	EM_COPY_REGION,		/* M-W */
-	/* 216 */	ED_COMMAND,		/* M-X */
-	/* 217 */	ED_UNASSIGNED,		/* M-Y */
-	/* 218 */	ED_UNASSIGNED,		/* M-Z */
-	/* 219 */	ED_SEQUENCE_LEAD_IN,	/* M-[ */
-	/* 220 */	ED_UNASSIGNED,		/* M-\ */
-	/* 221 */	ED_UNASSIGNED,		/* M-] */
-	/* 222 */	ED_UNASSIGNED,		/* M-^ */
-	/* 223 */	ED_UNASSIGNED,		/* M-_ */
-	/* 223 */	ED_UNASSIGNED,		/* M-` */
-	/* 224 */	ED_UNASSIGNED,		/* M-a */
-	/* 225 */	ED_PREV_WORD,		/* M-b */
-	/* 226 */	EM_CAPITOL_CASE,	/* M-c */
-	/* 227 */	EM_DELETE_NEXT_WORD,	/* M-d */
-	/* 228 */	ED_UNASSIGNED,		/* M-e */
-	/* 229 */	EM_NEXT_WORD,		/* M-f */
-	/* 230 */	ED_UNASSIGNED,		/* M-g */
-	/* 231 */	ED_UNASSIGNED,		/* M-h */
-	/* 232 */	ED_UNASSIGNED,		/* M-i */
-	/* 233 */	ED_UNASSIGNED,		/* M-j */
-	/* 234 */	ED_UNASSIGNED,		/* M-k */
-	/* 235 */	EM_LOWER_CASE,		/* M-l */
-	/* 236 */	ED_UNASSIGNED,		/* M-m */
-	/* 237 */	ED_SEARCH_NEXT_HISTORY,	/* M-n */
-	/* 238 */	ED_UNASSIGNED,		/* M-o */
-	/* 239 */	ED_SEARCH_PREV_HISTORY,	/* M-p */
-	/* 240 */	ED_UNASSIGNED,		/* M-q */
-	/* 241 */	ED_UNASSIGNED,		/* M-r */
-	/* 242 */	ED_UNASSIGNED,		/* M-s */
-	/* 243 */	ED_UNASSIGNED,		/* M-t */
-	/* 244 */	EM_UPPER_CASE,		/* M-u */
-	/* 245 */	ED_UNASSIGNED,		/* M-v */
-	/* 246 */	EM_COPY_REGION,		/* M-w */
-	/* 247 */	ED_COMMAND,		/* M-x */
-	/* 248 */	ED_UNASSIGNED,		/* M-y */
-	/* 249 */	ED_UNASSIGNED,		/* M-z */
-	/* 250 */	ED_UNASSIGNED,		/* M-{ */
-	/* 251 */	ED_UNASSIGNED,		/* M-| */
-	/* 252 */	ED_UNASSIGNED,		/* M-} */
-	/* 253 */	ED_UNASSIGNED,		/* M-~ */
-	/* 254 */	ED_DELETE_PREV_WORD	/* M-^? */
-	/* 255 */
-};
-
-
-/*
- * keymap table for vi.  Each index into above tbl; should be
- * N_KEYS entries long.  Vi mode uses a sticky-extend to do command mode:
- * insert mode characters are in the normal keymap, and command mode
- * in the extended keymap.
- */
-private const el_action_t  el_map_vi_insert[] = {
-#ifdef KSHVI
-	/*   0 */	ED_UNASSIGNED,		/* ^@ */
-	/*   1 */	ED_INSERT,		/* ^A */
-	/*   2 */	ED_INSERT,		/* ^B */
-	/*   3 */	ED_INSERT,		/* ^C */
-	/*   4 */	VI_LIST_OR_EOF,		/* ^D */
-	/*   5 */	ED_INSERT,		/* ^E */
-	/*   6 */	ED_INSERT,		/* ^F */
-	/*   7 */	ED_INSERT,		/* ^G */
-	/*   8 */	VI_DELETE_PREV_CHAR,	/* ^H */   /* BackSpace key */
-	/*   9 */	ED_INSERT,		/* ^I */   /* Tab Key  */
-	/*  10 */	ED_NEWLINE,		/* ^J */
-	/*  11 */	ED_INSERT,		/* ^K */
-	/*  12 */	ED_INSERT,		/* ^L */
-	/*  13 */	ED_NEWLINE,		/* ^M */
-	/*  14 */	ED_INSERT,		/* ^N */
-	/*  15 */	ED_INSERT,		/* ^O */
-	/*  16 */	ED_INSERT,		/* ^P */
-	/*  17 */	ED_TTY_START_OUTPUT,	/* ^Q */
-	/*  18 */	ED_INSERT,		/* ^R */
-	/*  19 */	ED_TTY_STOP_OUTPUT,	/* ^S */
-	/*  20 */	ED_INSERT,		/* ^T */
-	/*  21 */	VI_KILL_LINE_PREV,	/* ^U */
-	/*  22 */	ED_QUOTED_INSERT,	/* ^V */
-	/*  23 */	ED_DELETE_PREV_WORD,	/* ^W */
-		/* ED_DELETE_PREV_WORD: Only until strt edit pos */
-	/*  24 */	ED_INSERT,		/* ^X */
-	/*  25 */	ED_INSERT,		/* ^Y */
-	/*  26 */	ED_INSERT,		/* ^Z */
-	/*  27 */	VI_COMMAND_MODE,	/* ^[ */  /* [ Esc ] key */
-	/*  28 */	ED_TTY_SIGQUIT,		/* ^\ */
-	/*  29 */	ED_INSERT,		/* ^] */
-	/*  30 */	ED_INSERT,		/* ^^ */
-	/*  31 */	ED_INSERT,		/* ^_ */
-#else /* !KSHVI */
-				/*
-				 * NOTE: These mappings do NOT Correspond well
-				 * to the KSH VI editing assignments.
-				 * On the other and they are convenient and
-				 * many people have have gotten used to them.
-				 */
-	/*   0 */	ED_UNASSIGNED,		/* ^@ */
-	/*   1 */	ED_MOVE_TO_BEG,		/* ^A */
-	/*   2 */	ED_PREV_CHAR,		/* ^B */
-	/*   3 */	ED_TTY_SIGINT,		/* ^C */
-	/*   4 */	VI_LIST_OR_EOF,		/* ^D */
-	/*   5 */	ED_MOVE_TO_END,		/* ^E */
-	/*   6 */	ED_NEXT_CHAR,		/* ^F */
-	/*   7 */	ED_UNASSIGNED,		/* ^G */
-	/*   8 */	ED_DELETE_PREV_CHAR,	/* ^H */   /* BackSpace key */
-	/*   9 */	ED_UNASSIGNED,		/* ^I */   /* Tab Key */
-	/*  10 */	ED_NEWLINE,		/* ^J */
-	/*  11 */	ED_KILL_LINE,		/* ^K */
-	/*  12 */	ED_CLEAR_SCREEN,	/* ^L */
-	/*  13 */	ED_NEWLINE,		/* ^M */
-	/*  14 */	ED_NEXT_HISTORY,	/* ^N */
-	/*  15 */	ED_TTY_FLUSH_OUTPUT,	/* ^O */
-	/*  16 */	ED_PREV_HISTORY,	/* ^P */
-	/*  17 */	ED_TTY_START_OUTPUT,	/* ^Q */
-	/*  18 */	ED_REDISPLAY,		/* ^R */
-	/*  19 */	ED_TTY_STOP_OUTPUT,	/* ^S */
-	/*  20 */	ED_TRANSPOSE_CHARS,	/* ^T */
-	/*  21 */	VI_KILL_LINE_PREV,	/* ^U */
-	/*  22 */	ED_QUOTED_INSERT,	/* ^V */
-	/*  23 */	ED_DELETE_PREV_WORD,	/* ^W */
-	/*  24 */	ED_UNASSIGNED,		/* ^X */
-	/*  25 */	ED_TTY_DSUSP,		/* ^Y */
-	/*  26 */	ED_TTY_SIGTSTP,		/* ^Z */
-	/*  27 */	VI_COMMAND_MODE,	/* ^[ */
-	/*  28 */	ED_TTY_SIGQUIT,		/* ^\ */
-	/*  29 */	ED_UNASSIGNED,		/* ^] */
-	/*  30 */	ED_UNASSIGNED,		/* ^^ */
-	/*  31 */	ED_UNASSIGNED,		/* ^_ */
-#endif  /* KSHVI */
-	/*  32 */	ED_INSERT,		/* SPACE */
-	/*  33 */	ED_INSERT,		/* ! */
-	/*  34 */	ED_INSERT,		/* " */
-	/*  35 */	ED_INSERT,		/* # */
-	/*  36 */	ED_INSERT,		/* $ */
-	/*  37 */	ED_INSERT,		/* % */
-	/*  38 */	ED_INSERT,		/* & */
-	/*  39 */	ED_INSERT,		/* ' */
-	/*  40 */	ED_INSERT,		/* ( */
-	/*  41 */	ED_INSERT,		/* ) */
-	/*  42 */	ED_INSERT,		/* * */
-	/*  43 */	ED_INSERT,		/* + */
-	/*  44 */	ED_INSERT,		/* , */
-	/*  45 */	ED_INSERT,		/* - */
-	/*  46 */	ED_INSERT,		/* . */
-	/*  47 */	ED_INSERT,		/* / */
-	/*  48 */	ED_INSERT,		/* 0 */
-	/*  49 */	ED_INSERT,		/* 1 */
-	/*  50 */	ED_INSERT,		/* 2 */
-	/*  51 */	ED_INSERT,		/* 3 */
-	/*  52 */	ED_INSERT,		/* 4 */
-	/*  53 */	ED_INSERT,		/* 5 */
-	/*  54 */	ED_INSERT,		/* 6 */
-	/*  55 */	ED_INSERT,		/* 7 */
-	/*  56 */	ED_INSERT,		/* 8 */
-	/*  57 */	ED_INSERT,		/* 9 */
-	/*  58 */	ED_INSERT,		/* : */
-	/*  59 */	ED_INSERT,		/* ; */
-	/*  60 */	ED_INSERT,		/* < */
-	/*  61 */	ED_INSERT,		/* = */
-	/*  62 */	ED_INSERT,		/* > */
-	/*  63 */	ED_INSERT,		/* ? */
-	/*  64 */	ED_INSERT,		/* @ */
-	/*  65 */	ED_INSERT,		/* A */
-	/*  66 */	ED_INSERT,		/* B */
-	/*  67 */	ED_INSERT,		/* C */
-	/*  68 */	ED_INSERT,		/* D */
-	/*  69 */	ED_INSERT,		/* E */
-	/*  70 */	ED_INSERT,		/* F */
-	/*  71 */	ED_INSERT,		/* G */
-	/*  72 */	ED_INSERT,		/* H */
-	/*  73 */	ED_INSERT,		/* I */
-	/*  74 */	ED_INSERT,		/* J */
-	/*  75 */	ED_INSERT,		/* K */
-	/*  76 */	ED_INSERT,		/* L */
-	/*  77 */	ED_INSERT,		/* M */
-	/*  78 */	ED_INSERT,		/* N */
-	/*  79 */	ED_INSERT,		/* O */
-	/*  80 */	ED_INSERT,		/* P */
-	/*  81 */	ED_INSERT,		/* Q */
-	/*  82 */	ED_INSERT,		/* R */
-	/*  83 */	ED_INSERT,		/* S */
-	/*  84 */	ED_INSERT,		/* T */
-	/*  85 */	ED_INSERT,		/* U */
-	/*  86 */	ED_INSERT,		/* V */
-	/*  87 */	ED_INSERT,		/* W */
-	/*  88 */	ED_INSERT,		/* X */
-	/*  89 */	ED_INSERT,		/* Y */
-	/*  90 */	ED_INSERT,		/* Z */
-	/*  91 */	ED_INSERT,		/* [ */
-	/*  92 */	ED_INSERT,		/* \ */
-	/*  93 */	ED_INSERT,		/* ] */
-	/*  94 */	ED_INSERT,		/* ^ */
-	/*  95 */	ED_INSERT,		/* _ */
-	/*  96 */	ED_INSERT,		/* ` */
-	/*  97 */	ED_INSERT,		/* a */
-	/*  98 */	ED_INSERT,		/* b */
-	/*  99 */	ED_INSERT,		/* c */
-	/* 100 */	ED_INSERT,		/* d */
-	/* 101 */	ED_INSERT,		/* e */
-	/* 102 */	ED_INSERT,		/* f */
-	/* 103 */	ED_INSERT,		/* g */
-	/* 104 */	ED_INSERT,		/* h */
-	/* 105 */	ED_INSERT,		/* i */
-	/* 106 */	ED_INSERT,		/* j */
-	/* 107 */	ED_INSERT,		/* k */
-	/* 108 */	ED_INSERT,		/* l */
-	/* 109 */	ED_INSERT,		/* m */
-	/* 110 */	ED_INSERT,		/* n */
-	/* 111 */	ED_INSERT,		/* o */
-	/* 112 */	ED_INSERT,		/* p */
-	/* 113 */	ED_INSERT,		/* q */
-	/* 114 */	ED_INSERT,		/* r */
-	/* 115 */	ED_INSERT,		/* s */
-	/* 116 */	ED_INSERT,		/* t */
-	/* 117 */	ED_INSERT,		/* u */
-	/* 118 */	ED_INSERT,		/* v */
-	/* 119 */	ED_INSERT,		/* w */
-	/* 120 */	ED_INSERT,		/* x */
-	/* 121 */	ED_INSERT,		/* y */
-	/* 122 */	ED_INSERT,		/* z */
-	/* 123 */	ED_INSERT,		/* { */
-	/* 124 */	ED_INSERT,		/* | */
-	/* 125 */	ED_INSERT,		/* } */
-	/* 126 */	ED_INSERT,		/* ~ */
-	/* 127 */	ED_DELETE_PREV_CHAR,	/* ^? */
-	/* 128 */	ED_UNASSIGNED,		/* M-^@ */
-	/* 129 */	ED_UNASSIGNED,		/* M-^A */
-	/* 130 */	ED_UNASSIGNED,		/* M-^B */
-	/* 131 */	ED_UNASSIGNED,		/* M-^C */
-	/* 132 */	ED_UNASSIGNED,		/* M-^D */
-	/* 133 */	ED_UNASSIGNED,		/* M-^E */
-	/* 134 */	ED_UNASSIGNED,		/* M-^F */
-	/* 135 */	ED_UNASSIGNED,		/* M-^G */
-	/* 136 */	ED_UNASSIGNED,		/* M-^H */
-	/* 137 */	ED_UNASSIGNED,		/* M-^I */
-	/* 138 */	ED_UNASSIGNED,		/* M-^J */
-	/* 139 */	ED_UNASSIGNED,		/* M-^K */
-	/* 140 */	ED_UNASSIGNED,		/* M-^L */
-	/* 141 */	ED_UNASSIGNED,		/* M-^M */
-	/* 142 */	ED_UNASSIGNED,		/* M-^N */
-	/* 143 */	ED_UNASSIGNED,		/* M-^O */
-	/* 144 */	ED_UNASSIGNED,		/* M-^P */
-	/* 145 */	ED_UNASSIGNED,		/* M-^Q */
-	/* 146 */	ED_UNASSIGNED,		/* M-^R */
-	/* 147 */	ED_UNASSIGNED,		/* M-^S */
-	/* 148 */	ED_UNASSIGNED,		/* M-^T */
-	/* 149 */	ED_UNASSIGNED,		/* M-^U */
-	/* 150 */	ED_UNASSIGNED,		/* M-^V */
-	/* 151 */	ED_UNASSIGNED,		/* M-^W */
-	/* 152 */	ED_UNASSIGNED,		/* M-^X */
-	/* 153 */	ED_UNASSIGNED,		/* M-^Y */
-	/* 154 */	ED_UNASSIGNED,		/* M-^Z */
-	/* 155 */	ED_UNASSIGNED,		/* M-^[ */
-	/* 156 */	ED_UNASSIGNED,		/* M-^\ */
-	/* 157 */	ED_UNASSIGNED,		/* M-^] */
-	/* 158 */	ED_UNASSIGNED,		/* M-^^ */
-	/* 159 */	ED_UNASSIGNED,		/* M-^_ */
-	/* 160 */	ED_UNASSIGNED,		/* M-SPACE */
-	/* 161 */	ED_UNASSIGNED,		/* M-! */
-	/* 162 */	ED_UNASSIGNED,		/* M-" */
-	/* 163 */	ED_UNASSIGNED,		/* M-# */
-	/* 164 */	ED_UNASSIGNED,		/* M-$ */
-	/* 165 */	ED_UNASSIGNED,		/* M-% */
-	/* 166 */	ED_UNASSIGNED,		/* M-& */
-	/* 167 */	ED_UNASSIGNED,		/* M-' */
-	/* 168 */	ED_UNASSIGNED,		/* M-( */
-	/* 169 */	ED_UNASSIGNED,		/* M-) */
-	/* 170 */	ED_UNASSIGNED,		/* M-* */
-	/* 171 */	ED_UNASSIGNED,		/* M-+ */
-	/* 172 */	ED_UNASSIGNED,		/* M-, */
-	/* 173 */	ED_UNASSIGNED,		/* M-- */
-	/* 174 */	ED_UNASSIGNED,		/* M-. */
-	/* 175 */	ED_UNASSIGNED,		/* M-/ */
-	/* 176 */	ED_UNASSIGNED,		/* M-0 */
-	/* 177 */	ED_UNASSIGNED,		/* M-1 */
-	/* 178 */	ED_UNASSIGNED,		/* M-2 */
-	/* 179 */	ED_UNASSIGNED,		/* M-3 */
-	/* 180 */	ED_UNASSIGNED,		/* M-4 */
-	/* 181 */	ED_UNASSIGNED,		/* M-5 */
-	/* 182 */	ED_UNASSIGNED,		/* M-6 */
-	/* 183 */	ED_UNASSIGNED,		/* M-7 */
-	/* 184 */	ED_UNASSIGNED,		/* M-8 */
-	/* 185 */	ED_UNASSIGNED,		/* M-9 */
-	/* 186 */	ED_UNASSIGNED,		/* M-: */
-	/* 187 */	ED_UNASSIGNED,		/* M-; */
-	/* 188 */	ED_UNASSIGNED,		/* M-< */
-	/* 189 */	ED_UNASSIGNED,		/* M-= */
-	/* 190 */	ED_UNASSIGNED,		/* M-> */
-	/* 191 */	ED_UNASSIGNED,		/* M-? */
-	/* 192 */	ED_UNASSIGNED,		/* M-@ */
-	/* 193 */	ED_UNASSIGNED,		/* M-A */
-	/* 194 */	ED_UNASSIGNED,		/* M-B */
-	/* 195 */	ED_UNASSIGNED,		/* M-C */
-	/* 196 */	ED_UNASSIGNED,		/* M-D */
-	/* 197 */	ED_UNASSIGNED,		/* M-E */
-	/* 198 */	ED_UNASSIGNED,		/* M-F */
-	/* 199 */	ED_UNASSIGNED,		/* M-G */
-	/* 200 */	ED_UNASSIGNED,		/* M-H */
-	/* 201 */	ED_UNASSIGNED,		/* M-I */
-	/* 202 */	ED_UNASSIGNED,		/* M-J */
-	/* 203 */	ED_UNASSIGNED,		/* M-K */
-	/* 204 */	ED_UNASSIGNED,		/* M-L */
-	/* 205 */	ED_UNASSIGNED,		/* M-M */
-	/* 206 */	ED_UNASSIGNED,		/* M-N */
-	/* 207 */	ED_UNASSIGNED,		/* M-O */
-	/* 208 */	ED_UNASSIGNED,		/* M-P */
-	/* 209 */	ED_UNASSIGNED,		/* M-Q */
-	/* 210 */	ED_UNASSIGNED,		/* M-R */
-	/* 211 */	ED_UNASSIGNED,		/* M-S */
-	/* 212 */	ED_UNASSIGNED,		/* M-T */
-	/* 213 */	ED_UNASSIGNED,		/* M-U */
-	/* 214 */	ED_UNASSIGNED,		/* M-V */
-	/* 215 */	ED_UNASSIGNED,		/* M-W */
-	/* 216 */	ED_UNASSIGNED,		/* M-X */
-	/* 217 */	ED_UNASSIGNED,		/* M-Y */
-	/* 218 */	ED_UNASSIGNED,		/* M-Z */
-	/* 219 */	ED_UNASSIGNED,		/* M-[ */
-	/* 220 */	ED_UNASSIGNED,		/* M-\ */
-	/* 221 */	ED_UNASSIGNED,		/* M-] */
-	/* 222 */	ED_UNASSIGNED,		/* M-^ */
-	/* 223 */	ED_UNASSIGNED,		/* M-_ */
-	/* 224 */	ED_UNASSIGNED,		/* M-` */
-	/* 225 */	ED_UNASSIGNED,		/* M-a */
-	/* 226 */	ED_UNASSIGNED,		/* M-b */
-	/* 227 */	ED_UNASSIGNED,		/* M-c */
-	/* 228 */	ED_UNASSIGNED,		/* M-d */
-	/* 229 */	ED_UNASSIGNED,		/* M-e */
-	/* 230 */	ED_UNASSIGNED,		/* M-f */
-	/* 231 */	ED_UNASSIGNED,		/* M-g */
-	/* 232 */	ED_UNASSIGNED,		/* M-h */
-	/* 233 */	ED_UNASSIGNED,		/* M-i */
-	/* 234 */	ED_UNASSIGNED,		/* M-j */
-	/* 235 */	ED_UNASSIGNED,		/* M-k */
-	/* 236 */	ED_UNASSIGNED,		/* M-l */
-	/* 237 */	ED_UNASSIGNED,		/* M-m */
-	/* 238 */	ED_UNASSIGNED,		/* M-n */
-	/* 239 */	ED_UNASSIGNED,		/* M-o */
-	/* 240 */	ED_UNASSIGNED,		/* M-p */
-	/* 241 */	ED_UNASSIGNED,		/* M-q */
-	/* 242 */	ED_UNASSIGNED,		/* M-r */
-	/* 243 */	ED_UNASSIGNED,		/* M-s */
-	/* 244 */	ED_UNASSIGNED,		/* M-t */
-	/* 245 */	ED_UNASSIGNED,		/* M-u */
-	/* 246 */	ED_UNASSIGNED,		/* M-v */
-	/* 247 */	ED_UNASSIGNED,		/* M-w */
-	/* 248 */	ED_UNASSIGNED,		/* M-x */
-	/* 249 */	ED_UNASSIGNED,		/* M-y */
-	/* 250 */	ED_UNASSIGNED,		/* M-z */
-	/* 251 */	ED_UNASSIGNED,		/* M-{ */
-	/* 252 */	ED_UNASSIGNED,		/* M-| */
-	/* 253 */	ED_UNASSIGNED,		/* M-} */
-	/* 254 */	ED_UNASSIGNED,		/* M-~ */
-	/* 255 */	ED_UNASSIGNED		/* M-^? */
-};
-
-private const el_action_t el_map_vi_command[] = {
-	/*   0 */	ED_UNASSIGNED,		/* ^@ */
-	/*   1 */	ED_MOVE_TO_BEG,		/* ^A */
-	/*   2 */	ED_UNASSIGNED,		/* ^B */
-	/*   3 */	ED_TTY_SIGINT,		/* ^C */
-	/*   4 */	ED_UNASSIGNED,		/* ^D */
-	/*   5 */	ED_MOVE_TO_END,		/* ^E */
-	/*   6 */	ED_UNASSIGNED,		/* ^F */
-	/*   7 */	ED_UNASSIGNED,		/* ^G */
-	/*   8 */	ED_PREV_CHAR,		/* ^H */
-	/*   9 */	ED_UNASSIGNED,		/* ^I */
-	/*  10 */	ED_NEWLINE,		/* ^J */
-	/*  11 */	ED_KILL_LINE,		/* ^K */
-	/*  12 */	ED_CLEAR_SCREEN,	/* ^L */
-	/*  13 */	ED_NEWLINE,		/* ^M */
-	/*  14 */	ED_NEXT_HISTORY,	/* ^N */
-	/*  15 */	ED_TTY_FLUSH_OUTPUT,	/* ^O */
-	/*  16 */	ED_PREV_HISTORY,	/* ^P */
-	/*  17 */	ED_TTY_START_OUTPUT,	/* ^Q */
-	/*  18 */	ED_REDISPLAY,		/* ^R */
-	/*  19 */	ED_TTY_STOP_OUTPUT,	/* ^S */
-	/*  20 */	ED_UNASSIGNED,		/* ^T */
-	/*  21 */	VI_KILL_LINE_PREV,	/* ^U */
-	/*  22 */	ED_UNASSIGNED,		/* ^V */
-	/*  23 */	ED_DELETE_PREV_WORD,	/* ^W */
-	/*  24 */	ED_UNASSIGNED,		/* ^X */
-	/*  25 */	ED_UNASSIGNED,		/* ^Y */
-	/*  26 */	ED_UNASSIGNED,		/* ^Z */
-	/*  27 */	EM_META_NEXT,		/* ^[ */
-	/*  28 */	ED_TTY_SIGQUIT,		/* ^\ */
-	/*  29 */	ED_UNASSIGNED,		/* ^] */
-	/*  30 */	ED_UNASSIGNED,		/* ^^ */
-	/*  31 */	ED_UNASSIGNED,		/* ^_ */
-	/*  32 */	ED_NEXT_CHAR,		/* SPACE */
-	/*  33 */	ED_UNASSIGNED,		/* ! */
-	/*  34 */	ED_UNASSIGNED,		/* " */
-	/*  35 */	ED_UNASSIGNED,		/* # */
-	/*  36 */	ED_MOVE_TO_END,		/* $ */
-	/*  37 */	ED_UNASSIGNED,		/* % */
-	/*  38 */	ED_UNASSIGNED,		/* & */
-	/*  39 */	ED_UNASSIGNED,		/* ' */
-	/*  40 */	ED_UNASSIGNED,		/* ( */
-	/*  41 */	ED_UNASSIGNED,		/* ) */
-	/*  42 */	ED_UNASSIGNED,		/* * */
-	/*  43 */	ED_NEXT_HISTORY,	/* + */
-	/*  44 */	VI_REPEAT_PREV_CHAR,	/* , */
-	/*  45 */	ED_PREV_HISTORY,	/* - */
-	/*  46 */	ED_UNASSIGNED,		/* . */
-	/*  47 */	VI_SEARCH_PREV,		/* / */
-	/*  48 */	VI_ZERO,		/* 0 */
-	/*  49 */	ED_ARGUMENT_DIGIT,	/* 1 */
-	/*  50 */	ED_ARGUMENT_DIGIT,	/* 2 */
-	/*  51 */	ED_ARGUMENT_DIGIT,	/* 3 */
-	/*  52 */	ED_ARGUMENT_DIGIT,	/* 4 */
-	/*  53 */	ED_ARGUMENT_DIGIT,	/* 5 */
-	/*  54 */	ED_ARGUMENT_DIGIT,	/* 6 */
-	/*  55 */	ED_ARGUMENT_DIGIT,	/* 7 */
-	/*  56 */	ED_ARGUMENT_DIGIT,	/* 8 */
-	/*  57 */	ED_ARGUMENT_DIGIT,	/* 9 */
-	/*  58 */	ED_COMMAND,		/* : */
-	/*  59 */	VI_REPEAT_NEXT_CHAR,	/* ; */
-	/*  60 */	ED_UNASSIGNED,		/* < */
-	/*  61 */	ED_UNASSIGNED,		/* = */
-	/*  62 */	ED_UNASSIGNED,		/* > */
-	/*  63 */	VI_SEARCH_NEXT,		/* ? */
-	/*  64 */	ED_UNASSIGNED,		/* @ */
-	/*  65 */	VI_ADD_AT_EOL,		/* A */
-	/*  66 */	VI_PREV_SPACE_WORD,	/* B */
-	/*  67 */	VI_CHANGE_TO_EOL,	/* C */
-	/*  68 */	ED_KILL_LINE,		/* D */
-	/*  69 */	VI_TO_END_WORD,		/* E */
-	/*  70 */	VI_PREV_CHAR,		/* F */
-	/*  71 */	ED_UNASSIGNED,		/* G */
-	/*  72 */	ED_UNASSIGNED,		/* H */
-	/*  73 */	VI_INSERT_AT_BOL,	/* I */
-	/*  74 */	ED_SEARCH_NEXT_HISTORY,	/* J */
-	/*  75 */	ED_SEARCH_PREV_HISTORY,	/* K */
-	/*  76 */	ED_UNASSIGNED,		/* L */
-	/*  77 */	ED_UNASSIGNED,		/* M */
-	/*  78 */	VI_REPEAT_SEARCH_PREV,	/* N */
-	/*  79 */	ED_SEQUENCE_LEAD_IN,	/* O */
-	/*  80 */	VI_PASTE_PREV,		/* P */
-	/*  81 */	ED_UNASSIGNED,		/* Q */
-	/*  82 */	VI_REPLACE_MODE,	/* R */
-	/*  83 */	VI_SUBSTITUTE_LINE,	/* S */
-	/*  84 */	VI_TO_PREV_CHAR,	/* T */
-	/*  85 */	ED_UNASSIGNED,		/* U */
-	/*  86 */	ED_UNASSIGNED,		/* V */
-	/*  87 */	VI_NEXT_SPACE_WORD,	/* W */
-	/*  88 */	ED_DELETE_PREV_CHAR,	/* X */
-	/*  89 */	ED_UNASSIGNED,		/* Y */
-	/*  90 */	ED_UNASSIGNED,		/* Z */
-	/*  91 */	ED_SEQUENCE_LEAD_IN,	/* [ */
-	/*  92 */	ED_UNASSIGNED,		/* \ */
-	/*  93 */	ED_UNASSIGNED,		/* ] */
-	/*  94 */	ED_MOVE_TO_BEG,		/* ^ */
-	/*  95 */	ED_UNASSIGNED,		/* _ */
-	/*  96 */	ED_UNASSIGNED,		/* ` */
-	/*  97 */	VI_ADD,			/* a */
-	/*  98 */	VI_PREV_WORD,		/* b */
-	/*  99 */	VI_CHANGE_META,		/* c */
-	/* 100 */	VI_DELETE_META,		/* d */
-	/* 101 */	VI_END_WORD,		/* e */
-	/* 102 */	VI_NEXT_CHAR,		/* f */
-	/* 103 */	ED_UNASSIGNED,		/* g */
-	/* 104 */	ED_PREV_CHAR,		/* h */
-	/* 105 */	VI_INSERT,		/* i */
-	/* 106 */	ED_NEXT_HISTORY,	/* j */
-	/* 107 */	ED_PREV_HISTORY,	/* k */
-	/* 108 */	ED_NEXT_CHAR,		/* l */
-	/* 109 */	ED_UNASSIGNED,		/* m */
-	/* 110 */	VI_REPEAT_SEARCH_NEXT,	/* n */
-	/* 111 */	ED_UNASSIGNED,		/* o */
-	/* 112 */	VI_PASTE_NEXT,		/* p */
-	/* 113 */	ED_UNASSIGNED,		/* q */
-	/* 114 */	VI_REPLACE_CHAR,	/* r */
-	/* 115 */	VI_SUBSTITUTE_CHAR,	/* s */
-	/* 116 */	VI_TO_NEXT_CHAR,	/* t */
-	/* 117 */	VI_UNDO,		/* u */
-	/* 118 */	ED_UNASSIGNED,		/* v */
-	/* 119 */	VI_NEXT_WORD,		/* w */
-	/* 120 */	ED_DELETE_NEXT_CHAR,	/* x */
-	/* 121 */	ED_UNASSIGNED,		/* y */
-	/* 122 */	ED_UNASSIGNED,		/* z */
-	/* 123 */	ED_UNASSIGNED,		/* { */
-	/* 124 */	ED_UNASSIGNED,		/* | */
-	/* 125 */	ED_UNASSIGNED,		/* } */
-	/* 126 */	VI_CHANGE_CASE,		/* ~ */
-	/* 127 */	ED_DELETE_PREV_CHAR,	/* ^? */
-	/* 128 */	ED_UNASSIGNED,		/* M-^@ */
-	/* 129 */	ED_UNASSIGNED,		/* M-^A */
-	/* 130 */	ED_UNASSIGNED,		/* M-^B */
-	/* 131 */	ED_UNASSIGNED,		/* M-^C */
-	/* 132 */	ED_UNASSIGNED,		/* M-^D */
-	/* 133 */	ED_UNASSIGNED,		/* M-^E */
-	/* 134 */	ED_UNASSIGNED,		/* M-^F */
-	/* 135 */	ED_UNASSIGNED,		/* M-^G */
-	/* 136 */	ED_UNASSIGNED,		/* M-^H */
-	/* 137 */	ED_UNASSIGNED,		/* M-^I */
-	/* 138 */	ED_UNASSIGNED,		/* M-^J */
-	/* 139 */	ED_UNASSIGNED,		/* M-^K */
-	/* 140 */	ED_UNASSIGNED,		/* M-^L */
-	/* 141 */	ED_UNASSIGNED,		/* M-^M */
-	/* 142 */	ED_UNASSIGNED,		/* M-^N */
-	/* 143 */	ED_UNASSIGNED,		/* M-^O */
-	/* 144 */	ED_UNASSIGNED,		/* M-^P */
-	/* 145 */	ED_UNASSIGNED,		/* M-^Q */
-	/* 146 */	ED_UNASSIGNED,		/* M-^R */
-	/* 147 */	ED_UNASSIGNED,		/* M-^S */
-	/* 148 */	ED_UNASSIGNED,		/* M-^T */
-	/* 149 */	ED_UNASSIGNED,		/* M-^U */
-	/* 150 */	ED_UNASSIGNED,		/* M-^V */
-	/* 151 */	ED_UNASSIGNED,		/* M-^W */
-	/* 152 */	ED_UNASSIGNED,		/* M-^X */
-	/* 153 */	ED_UNASSIGNED,		/* M-^Y */
-	/* 154 */	ED_UNASSIGNED,		/* M-^Z */
-	/* 155 */	ED_UNASSIGNED,		/* M-^[ */
-	/* 156 */	ED_UNASSIGNED,		/* M-^\ */
-	/* 157 */	ED_UNASSIGNED,		/* M-^] */
-	/* 158 */	ED_UNASSIGNED,		/* M-^^ */
-	/* 159 */	ED_UNASSIGNED,		/* M-^_ */
-	/* 160 */	ED_UNASSIGNED,		/* M-SPACE */
-	/* 161 */	ED_UNASSIGNED,		/* M-! */
-	/* 162 */	ED_UNASSIGNED,		/* M-" */
-	/* 163 */	ED_UNASSIGNED,		/* M-# */
-	/* 164 */	ED_UNASSIGNED,		/* M-$ */
-	/* 165 */	ED_UNASSIGNED,		/* M-% */
-	/* 166 */	ED_UNASSIGNED,		/* M-& */
-	/* 167 */	ED_UNASSIGNED,		/* M-' */
-	/* 168 */	ED_UNASSIGNED,		/* M-( */
-	/* 169 */	ED_UNASSIGNED,		/* M-) */
-	/* 170 */	ED_UNASSIGNED,		/* M-* */
-	/* 171 */	ED_UNASSIGNED,		/* M-+ */
-	/* 172 */	ED_UNASSIGNED,		/* M-, */
-	/* 173 */	ED_UNASSIGNED,		/* M-- */
-	/* 174 */	ED_UNASSIGNED,		/* M-. */
-	/* 175 */	ED_UNASSIGNED,		/* M-/ */
-	/* 176 */	ED_UNASSIGNED,		/* M-0 */
-	/* 177 */	ED_UNASSIGNED,		/* M-1 */
-	/* 178 */	ED_UNASSIGNED,		/* M-2 */
-	/* 179 */	ED_UNASSIGNED,		/* M-3 */
-	/* 180 */	ED_UNASSIGNED,		/* M-4 */
-	/* 181 */	ED_UNASSIGNED,		/* M-5 */
-	/* 182 */	ED_UNASSIGNED,		/* M-6 */
-	/* 183 */	ED_UNASSIGNED,		/* M-7 */
-	/* 184 */	ED_UNASSIGNED,		/* M-8 */
-	/* 185 */	ED_UNASSIGNED,		/* M-9 */
-	/* 186 */	ED_UNASSIGNED,		/* M-: */
-	/* 187 */	ED_UNASSIGNED,		/* M-; */
-	/* 188 */	ED_UNASSIGNED,		/* M-< */
-	/* 189 */	ED_UNASSIGNED,		/* M-= */
-	/* 190 */	ED_UNASSIGNED,		/* M-> */
-	/* 191 */	ED_UNASSIGNED,		/* M-? */
-	/* 192 */	ED_UNASSIGNED,		/* M-@ */
-	/* 193 */	ED_UNASSIGNED,		/* M-A */
-	/* 194 */	ED_UNASSIGNED,		/* M-B */
-	/* 195 */	ED_UNASSIGNED,		/* M-C */
-	/* 196 */	ED_UNASSIGNED,		/* M-D */
-	/* 197 */	ED_UNASSIGNED,		/* M-E */
-	/* 198 */	ED_UNASSIGNED,		/* M-F */
-	/* 199 */	ED_UNASSIGNED,		/* M-G */
-	/* 200 */	ED_UNASSIGNED,		/* M-H */
-	/* 201 */	ED_UNASSIGNED,		/* M-I */
-	/* 202 */	ED_UNASSIGNED,		/* M-J */
-	/* 203 */	ED_UNASSIGNED,		/* M-K */
-	/* 204 */	ED_UNASSIGNED,		/* M-L */
-	/* 205 */	ED_UNASSIGNED,		/* M-M */
-	/* 206 */	ED_UNASSIGNED,		/* M-N */
-	/* 207 */	ED_SEQUENCE_LEAD_IN,	/* M-O */
-	/* 208 */	ED_UNASSIGNED,		/* M-P */
-	/* 209 */	ED_UNASSIGNED,		/* M-Q */
-	/* 210 */	ED_UNASSIGNED,		/* M-R */
-	/* 211 */	ED_UNASSIGNED,		/* M-S */
-	/* 212 */	ED_UNASSIGNED,		/* M-T */
-	/* 213 */	ED_UNASSIGNED,		/* M-U */
-	/* 214 */	ED_UNASSIGNED,		/* M-V */
-	/* 215 */	ED_UNASSIGNED,		/* M-W */
-	/* 216 */	ED_UNASSIGNED,		/* M-X */
-	/* 217 */	ED_UNASSIGNED,		/* M-Y */
-	/* 218 */	ED_UNASSIGNED,		/* M-Z */
-	/* 219 */	ED_SEQUENCE_LEAD_IN,	/* M-[ */
-	/* 220 */	ED_UNASSIGNED,		/* M-\ */
-	/* 221 */	ED_UNASSIGNED,		/* M-] */
-	/* 222 */	ED_UNASSIGNED,		/* M-^ */
-	/* 223 */	ED_UNASSIGNED,		/* M-_ */
-	/* 224 */	ED_UNASSIGNED,		/* M-` */
-	/* 225 */	ED_UNASSIGNED,		/* M-a */
-	/* 226 */	ED_UNASSIGNED,		/* M-b */
-	/* 227 */	ED_UNASSIGNED,		/* M-c */
-	/* 228 */	ED_UNASSIGNED,		/* M-d */
-	/* 229 */	ED_UNASSIGNED,		/* M-e */
-	/* 230 */	ED_UNASSIGNED,		/* M-f */
-	/* 231 */	ED_UNASSIGNED,		/* M-g */
-	/* 232 */	ED_UNASSIGNED,		/* M-h */
-	/* 233 */	ED_UNASSIGNED,		/* M-i */
-	/* 234 */	ED_UNASSIGNED,		/* M-j */
-	/* 235 */	ED_UNASSIGNED,		/* M-k */
-	/* 236 */	ED_UNASSIGNED,		/* M-l */
-	/* 237 */	ED_UNASSIGNED,		/* M-m */
-	/* 238 */	ED_UNASSIGNED,		/* M-n */
-	/* 239 */	ED_UNASSIGNED,		/* M-o */
-	/* 240 */	ED_UNASSIGNED,		/* M-p */
-	/* 241 */	ED_UNASSIGNED,		/* M-q */
-	/* 242 */	ED_UNASSIGNED,		/* M-r */
-	/* 243 */	ED_UNASSIGNED,		/* M-s */
-	/* 244 */	ED_UNASSIGNED,		/* M-t */
-	/* 245 */	ED_UNASSIGNED,		/* M-u */
-	/* 246 */	ED_UNASSIGNED,		/* M-v */
-	/* 247 */	ED_UNASSIGNED,		/* M-w */
-	/* 248 */	ED_UNASSIGNED,		/* M-x */
-	/* 249 */	ED_UNASSIGNED,		/* M-y */
-	/* 250 */	ED_UNASSIGNED,		/* M-z */
-	/* 251 */	ED_UNASSIGNED,		/* M-{ */
-	/* 252 */	ED_UNASSIGNED,		/* M-| */
-	/* 253 */	ED_UNASSIGNED,		/* M-} */
-	/* 254 */	ED_UNASSIGNED,		/* M-~ */
-	/* 255 */	ED_UNASSIGNED		/* M-^? */
-};
-
-
-/* map_init():
- *	Initialize and allocate the maps
- */
-protected int
-map_init(EditLine *el)
-{
-
-	/*
-         * Make sure those are correct before starting.
-         */
-#ifdef MAP_DEBUG
-	if (sizeof(el_map_emacs) != N_KEYS * sizeof(el_action_t))
-		EL_ABORT((el->errfile, "Emacs map incorrect\n"));
-	if (sizeof(el_map_vi_command) != N_KEYS * sizeof(el_action_t))
-		EL_ABORT((el->errfile, "Vi command map incorrect\n"));
-	if (sizeof(el_map_vi_insert) != N_KEYS * sizeof(el_action_t))
-		EL_ABORT((el->errfile, "Vi insert map incorrect\n"));
-#endif
-
-	el->el_map.alt = (el_action_t *)el_malloc(sizeof(el_action_t) * N_KEYS);
-	if (el->el_map.alt == NULL)
-		return (-1);
-	el->el_map.key = (el_action_t *)el_malloc(sizeof(el_action_t) * N_KEYS);
-	if (el->el_map.key == NULL)
-		return (-1);
-	el->el_map.emacs = el_map_emacs;
-	el->el_map.vic = el_map_vi_command;
-	el->el_map.vii = el_map_vi_insert;
-	el->el_map.help = (el_bindings_t *) el_malloc(sizeof(el_bindings_t) *
-	    EL_NUM_FCNS);
-	if (el->el_map.help == NULL)
-		return (-1);
-	(void) memcpy(el->el_map.help, help__get(),
-	    sizeof(el_bindings_t) * EL_NUM_FCNS);
-	el->el_map.func = (el_func_t *)el_malloc(sizeof(el_func_t) *
-	    EL_NUM_FCNS);
-	if (el->el_map.func == NULL)
-		return (-1);
-	memcpy(el->el_map.func, func__get(), sizeof(el_func_t) * EL_NUM_FCNS);
-	el->el_map.nfunc = EL_NUM_FCNS;
-
-#ifdef VIDEFAULT
-	map_init_vi(el);
-#else
-	map_init_emacs(el);
-#endif /* VIDEFAULT */
-	return (0);
-}
-
-
-/* map_end():
- *	Free the space taken by the editor maps
- */
-protected void
-map_end(EditLine *el)
-{
-
-	el_free((ptr_t) el->el_map.alt);
-	el->el_map.alt = NULL;
-	el_free((ptr_t) el->el_map.key);
-	el->el_map.key = NULL;
-	el->el_map.emacs = NULL;
-	el->el_map.vic = NULL;
-	el->el_map.vii = NULL;
-	el_free((ptr_t) el->el_map.help);
-	el->el_map.help = NULL;
-	el_free((ptr_t) el->el_map.func);
-	el->el_map.func = NULL;
-}
-
-
-/* map_init_nls():
- *	Find all the printable keys and bind them to self insert
- */
-private void
-map_init_nls(EditLine *el)
-{
-	int i;
-
-	el_action_t *map = el->el_map.key;
-
-	for (i = 0200; i <= 0377; i++)
-		if (isprint(i))
-			map[i] = ED_INSERT;
-}
-
-
-/* map_init_meta():
- *	Bind all the meta keys to the appropriate ESC-<key> sequence
- */
-private void
-map_init_meta(EditLine *el)
-{
-	char buf[3];
-	int i;
-	el_action_t *map = el->el_map.key;
-	el_action_t *alt = el->el_map.alt;
-
-	for (i = 0; i <= 0377 && map[i] != EM_META_NEXT; i++)
-		continue;
-
-	if (i > 0377) {
-		for (i = 0; i <= 0377 && alt[i] != EM_META_NEXT; i++)
-			continue;
-		if (i > 0377) {
-			i = 033;
-			if (el->el_map.type == MAP_VI)
-				map = alt;
-		} else
-			map = alt;
-	}
-	buf[0] = (char) i;
-	buf[2] = 0;
-	for (i = 0200; i <= 0377; i++)
-		switch (map[i]) {
-		case ED_INSERT:
-		case ED_UNASSIGNED:
-		case ED_SEQUENCE_LEAD_IN:
-			break;
-		default:
-			buf[1] = i & 0177;
-			key_add(el, buf, key_map_cmd(el, (int) map[i]), XK_CMD);
-			break;
-		}
-	map[(int) buf[0]] = ED_SEQUENCE_LEAD_IN;
-}
-
-
-/* map_init_vi():
- *	Initialize the vi bindings
- */
-protected void
-map_init_vi(EditLine *el)
-{
-	int i;
-	el_action_t *key = el->el_map.key;
-	el_action_t *alt = el->el_map.alt;
-	const el_action_t *vii = el->el_map.vii;
-	const el_action_t *vic = el->el_map.vic;
-
-	el->el_map.type = MAP_VI;
-	el->el_map.current = el->el_map.key;
-
-	key_reset(el);
-
-	for (i = 0; i < N_KEYS; i++) {
-		key[i] = vii[i];
-		alt[i] = vic[i];
-	}
-
-	map_init_meta(el);
-	map_init_nls(el);
-
-	tty_bind_char(el, 1);
-	term_bind_arrow(el);
-}
-
-
-/* map_init_emacs():
- *	Initialize the emacs bindings
- */
-protected void
-map_init_emacs(EditLine *el)
-{
-	int i;
-	char buf[3];
-	el_action_t *key = el->el_map.key;
-	el_action_t *alt = el->el_map.alt;
-	const el_action_t *emacs = el->el_map.emacs;
-
-	el->el_map.type = MAP_EMACS;
-	el->el_map.current = el->el_map.key;
-	key_reset(el);
-
-	for (i = 0; i < N_KEYS; i++) {
-		key[i] = emacs[i];
-		alt[i] = ED_UNASSIGNED;
-	}
-
-	map_init_meta(el);
-	map_init_nls(el);
-
-	buf[0] = CONTROL('X');
-	buf[1] = CONTROL('X');
-	buf[2] = 0;
-	key_add(el, buf, key_map_cmd(el, EM_EXCHANGE_MARK), XK_CMD);
-
-	tty_bind_char(el, 1);
-	term_bind_arrow(el);
-}
-
-
-/* map_set_editor():
- *	Set the editor
- */
-protected int
-map_set_editor(EditLine *el, char *editor)
-{
-
-	if (strcmp(editor, "emacs") == 0) {
-		map_init_emacs(el);
-		return (0);
-	}
-	if (strcmp(editor, "vi") == 0) {
-		map_init_vi(el);
-		return (0);
-	}
-	return (-1);
-}
-
-
-/* map_get_editor():
- *	Retrieve the editor
- */
-protected int
-map_get_editor(EditLine *el, const char **editor)
-{
-
-	if (editor == NULL)
-		return (-1);
-	switch (el->el_map.type) {
-	case MAP_EMACS:
-		*editor = "emacs";
-		return (0);
-	case MAP_VI:
-		*editor = "vi";
-		return (0);
-	}
-	return (-1);
-}
-
-
-/* map_print_key():
- *	Print the function description for 1 key
- */
-private void
-map_print_key(EditLine *el, el_action_t *map, const char *in)
-{
-	char outbuf[EL_BUFSIZ];
-	el_bindings_t *bp;
-
-	if (in[0] == '\0' || in[1] == '\0') {
-		(void) key__decode_str(in, outbuf, "");
-		for (bp = el->el_map.help; bp->name != NULL; bp++)
-			if (bp->func == map[(unsigned char) *in]) {
-				(void) fprintf(el->el_outfile,
-				    "%s\t->\t%s\n", outbuf, bp->name);
-				return;
-			}
-	} else
-		key_print(el, in);
-}
-
-
-/* map_print_some_keys():
- *	Print keys from first to last
- */
-private void
-map_print_some_keys(EditLine *el, el_action_t *map, int first, int last)
-{
-	el_bindings_t *bp;
-	char firstbuf[2], lastbuf[2];
-	char unparsbuf[EL_BUFSIZ], extrabuf[EL_BUFSIZ];
-
-	firstbuf[0] = first;
-	firstbuf[1] = 0;
-	lastbuf[0] = last;
-	lastbuf[1] = 0;
-	if (map[first] == ED_UNASSIGNED) {
-		if (first == last)
-			(void) fprintf(el->el_outfile,
-			    "%-15s->  is undefined\n",
-			    key__decode_str(firstbuf, unparsbuf, STRQQ));
-		return;
-	}
-	for (bp = el->el_map.help; bp->name != NULL; bp++) {
-		if (bp->func == map[first]) {
-			if (first == last) {
-				(void) fprintf(el->el_outfile, "%-15s->  %s\n",
-				    key__decode_str(firstbuf, unparsbuf, STRQQ),
-				    bp->name);
-			} else {
-				(void) fprintf(el->el_outfile,
-				    "%-4s to %-7s->  %s\n",
-				    key__decode_str(firstbuf, unparsbuf, STRQQ),
-				    key__decode_str(lastbuf, extrabuf, STRQQ),
-				    bp->name);
-			}
-			return;
-		}
-	}
-#ifdef MAP_DEBUG
-	if (map == el->el_map.key) {
-		(void) fprintf(el->el_outfile,
-		    "BUG!!! %s isn't bound to anything.\n",
-		    key__decode_str(firstbuf, unparsbuf, STRQQ));
-		(void) fprintf(el->el_outfile, "el->el_map.key[%d] == %d\n",
-		    first, el->el_map.key[first]);
-	} else {
-		(void) fprintf(el->el_outfile,
-		    "BUG!!! %s isn't bound to anything.\n",
-		    key__decode_str(firstbuf, unparsbuf, STRQQ));
-		(void) fprintf(el->el_outfile, "el->el_map.alt[%d] == %d\n",
-		    first, el->el_map.alt[first]);
-	}
-#endif
-	EL_ABORT((el->el_errfile, "Error printing keys\n"));
-}
-
-
-/* map_print_all_keys():
- *	Print the function description for all keys.
- */
-private void
-map_print_all_keys(EditLine *el)
-{
-	int prev, i;
-
-	(void) fprintf(el->el_outfile, "Standard key bindings\n");
-	prev = 0;
-	for (i = 0; i < N_KEYS; i++) {
-		if (el->el_map.key[prev] == el->el_map.key[i])
-			continue;
-		map_print_some_keys(el, el->el_map.key, prev, i - 1);
-		prev = i;
-	}
-	map_print_some_keys(el, el->el_map.key, prev, i - 1);
-
-	(void) fprintf(el->el_outfile, "Alternative key bindings\n");
-	prev = 0;
-	for (i = 0; i < N_KEYS; i++) {
-		if (el->el_map.alt[prev] == el->el_map.alt[i])
-			continue;
-		map_print_some_keys(el, el->el_map.alt, prev, i - 1);
-		prev = i;
-	}
-	map_print_some_keys(el, el->el_map.alt, prev, i - 1);
-
-	(void) fprintf(el->el_outfile, "Multi-character bindings\n");
-	key_print(el, "");
-	(void) fprintf(el->el_outfile, "Arrow key bindings\n");
-	term_print_arrow(el, "");
-}
-
-
-/* map_bind():
- *	Add/remove/change bindings
- */
-protected int
-map_bind(EditLine *el, int argc, const char **argv)
-{
-	el_action_t *map;
-	int ntype, rem;
-	const char *p;
-	char inbuf[EL_BUFSIZ];
-	char outbuf[EL_BUFSIZ];
-	const char *in = NULL;
-	char *out = NULL;
-	el_bindings_t *bp;
-	int cmd;
-	int key;
-
-	if (argv == NULL)
-		return (-1);
-
-	map = el->el_map.key;
-	ntype = XK_CMD;
-	key = rem = 0;
-	for (argc = 1; (p = argv[argc]) != NULL; argc++)
-		if (p[0] == '-')
-			switch (p[1]) {
-			case 'a':
-				map = el->el_map.alt;
-				break;
-
-			case 's':
-				ntype = XK_STR;
-				break;
-#ifdef notyet
-			case 'c':
-				ntype = XK_EXE;
-				break;
-#endif
-			case 'k':
-				key = 1;
-				break;
-
-			case 'r':
-				rem = 1;
-				break;
-
-			case 'v':
-				map_init_vi(el);
-				return (0);
-
-			case 'e':
-				map_init_emacs(el);
-				return (0);
-
-			case 'l':
-				for (bp = el->el_map.help; bp->name != NULL;
-				    bp++)
-					(void) fprintf(el->el_outfile,
-					    "%s\n\t%s\n",
-					    bp->name, bp->description);
-				return (0);
-			default:
-				(void) fprintf(el->el_errfile,
-				    "%s: Invalid switch `%c'.\n",
-				    argv[0], p[1]);
-			}
-		else
-			break;
-
-	if (argv[argc] == NULL) {
-		map_print_all_keys(el);
-		return (0);
-	}
-	if (key)
-		in = argv[argc++];
-	else if ((in = parse__string(inbuf, argv[argc++])) == NULL) {
-		(void) fprintf(el->el_errfile,
-		    "%s: Invalid \\ or ^ in instring.\n",
-		    argv[0]);
-		return (-1);
-	}
-	if (rem) {
-		if (key) {
-			(void) term_clear_arrow(el, in);
-			return (-1);
-		}
-		if (in[1])
-			(void) key_delete(el, in);
-		else if (map[(unsigned char) *in] == ED_SEQUENCE_LEAD_IN)
-			(void) key_delete(el, in);
-		else
-			map[(unsigned char) *in] = ED_UNASSIGNED;
-		return (0);
-	}
-	if (argv[argc] == NULL) {
-		if (key)
-			term_print_arrow(el, in);
-		else
-			map_print_key(el, map, in);
-		return (0);
-	}
-#ifdef notyet
-	if (argv[argc + 1] != NULL) {
-		bindkey_usage();
-		return (-1);
-	}
-#endif
-
-	switch (ntype) {
-	case XK_STR:
-	case XK_EXE:
-		if ((out = parse__string(outbuf, argv[argc])) == NULL) {
-			(void) fprintf(el->el_errfile,
-			    "%s: Invalid \\ or ^ in outstring.\n", argv[0]);
-			return (-1);
-		}
-		if (key)
-			term_set_arrow(el, in, key_map_str(el, out), ntype);
-		else
-			key_add(el, in, key_map_str(el, out), ntype);
-		map[(unsigned char) *in] = ED_SEQUENCE_LEAD_IN;
-		break;
-
-	case XK_CMD:
-		if ((cmd = parse_cmd(el, argv[argc])) == -1) {
-			(void) fprintf(el->el_errfile,
-			    "%s: Invalid command `%s'.\n", argv[0], argv[argc]);
-			return (-1);
-		}
-		if (key)
-			term_set_arrow(el, in, key_map_str(el, out), ntype);
-		else {
-			if (in[1]) {
-				key_add(el, in, key_map_cmd(el, cmd), ntype);
-				map[(unsigned char) *in] = ED_SEQUENCE_LEAD_IN;
-			} else {
-				key_clear(el, map, in);
-				map[(unsigned char) *in] = cmd;
-			}
-		}
-		break;
-
-	default:
-		EL_ABORT((el->el_errfile, "Bad XK_ type\n", ntype));
-		break;
-	}
-	return (0);
-}
-
-
-/* map_addfunc():
- *	add a user defined function
- */
-protected int
-map_addfunc(EditLine *el, const char *name, const char *help, el_func_t func)
-{
-	void *p;
-	int nf = el->el_map.nfunc + 2;
-
-	if (name == NULL || help == NULL || func == NULL)
-		return (-1);
-
-	if ((p = el_realloc(el->el_map.func, nf * sizeof(el_func_t))) == NULL)
-		return (-1);
-	el->el_map.func = (el_func_t *) p;
-	if ((p = el_realloc(el->el_map.help, nf * sizeof(el_bindings_t)))
-	    == NULL)
-		return (-1);
-	el->el_map.help = (el_bindings_t *) p;
-
-	nf = el->el_map.nfunc;
-	el->el_map.func[nf] = func;
-
-	el->el_map.help[nf].name = name;
-	el->el_map.help[nf].func = nf;
-	el->el_map.help[nf].description = help;
-	el->el_map.help[++nf].name = NULL;
-	el->el_map.nfunc++;
-
-	return (0);
-}
diff --git a/main/editline/map.h b/main/editline/map.h
deleted file mode 100644
index 3c9948c..0000000
--- a/main/editline/map.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/*	$NetBSD: map.h,v 1.7 2002/03/18 16:00:56 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)map.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.map.h:	Editor maps
- */
-#ifndef _h_el_map
-#define	_h_el_map
-
-typedef struct el_bindings_t {	/* for the "bind" shell command */
-	const char	*name;		/* function name for bind command */
-	int		 func;		/* function numeric value */
-	const char	*description;	/* description of function */
-} el_bindings_t;
-
-
-typedef struct el_map_t {
-	el_action_t	*alt;		/* The current alternate key map */
-	el_action_t	*key;		/* The current normal key map	*/
-	el_action_t	*current;	/* The keymap we are using	*/
-	const el_action_t *emacs;	/* The default emacs key map	*/
-	const el_action_t *vic;		/* The vi command mode key map	*/
-	const el_action_t *vii;		/* The vi insert mode key map	*/
-	int		 type;		/* Emacs or vi			*/
-	el_bindings_t	*help;		/* The help for the editor functions */
-	el_func_t	*func;		/* List of available functions	*/
-	int		 nfunc;		/* The number of functions/help items */
-} el_map_t;
-
-#define	MAP_EMACS	0
-#define	MAP_VI		1
-
-protected int	map_bind(EditLine *, int, const char **);
-protected int	map_init(EditLine *);
-protected void	map_end(EditLine *);
-protected void	map_init_vi(EditLine *);
-protected void	map_init_emacs(EditLine *);
-protected int	map_set_editor(EditLine *, char *);
-protected int	map_get_editor(EditLine *, const char **);
-protected int	map_addfunc(EditLine *, const char *, const char *, el_func_t);
-
-#endif /* _h_el_map */
diff --git a/main/editline/np/fgetln.c b/main/editline/np/fgetln.c
deleted file mode 100644
index 93da991..0000000
--- a/main/editline/np/fgetln.c
+++ /dev/null
@@ -1,88 +0,0 @@
-/*	$NetBSD: fgetln.c,v 1.1.1.1 1999/04/12 07:43:21 crooksa Exp $	*/
-
-/*-
- * Copyright (c) 1998 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Christos Zoulas.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-#include <string.h>
-
-char *
-fgetln(fp, len)
-	FILE *fp;
-	size_t *len;
-{
-	static char *buf = NULL;
-	static size_t bufsiz = 0;
-	char *ptr;
-
-
-	if (buf == NULL) {
-		bufsiz = BUFSIZ;
-		if ((buf = malloc(bufsiz)) == NULL)
-			return NULL;
-	}
-
-	if (fgets(buf, bufsiz, fp) == NULL)
-		return NULL;
-	*len = 0;
-
-	while ((ptr = strchr(&buf[*len], '\n')) == NULL) {
-		size_t nbufsiz = bufsiz + BUFSIZ;
-		char *nbuf = realloc(buf, nbufsiz);
-
-		if (nbuf == NULL) {
-			int oerrno = errno;
-			free(buf);
-			errno = oerrno;
-			buf = NULL;
-			return NULL;
-		} else
-			buf = nbuf;
-
-		*len = bufsiz;
-		if (fgets(&buf[bufsiz], BUFSIZ, fp) == NULL)
-			return buf;
-
-		bufsiz = nbufsiz;
-	}
-
-	*len = (ptr - buf) + 1;
-	return buf;
-}
diff --git a/main/editline/np/strlcat.c b/main/editline/np/strlcat.c
deleted file mode 100644
index 6c9f1e9..0000000
--- a/main/editline/np/strlcat.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
- * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
- * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
- * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#if defined(LIBC_SCCS) && !defined(lint)
-static char *rcsid = "$OpenBSD: strlcat.c,v 1.2 1999/06/17 16:28:58 millert Exp $";
-#endif /* LIBC_SCCS and not lint */
-#ifndef lint
-static const char rcsid[] =
-  "$FreeBSD: src/lib/libc/string/strlcat.c,v 1.2.4.2 2001/07/09 23:30:06 obrien Exp $";
-#endif
-
-#include <sys/types.h>
-#include <string.h>
-
-/*
- * Appends src to string dst of size siz (unlike strncat, siz is the
- * full size of dst, not space left).  At most siz-1 characters
- * will be copied.  Always NUL terminates (unless siz <= strlen(dst)).
- * Returns strlen(initial dst) + strlen(src); if retval >= siz,
- * truncation occurred.
- */
-size_t strlcat(dst, src, siz)
-	char *dst;
-	const char *src;
-	size_t siz;
-{
-	register char *d = dst;
-	register const char *s = src;
-	register size_t n = siz;
-	size_t dlen;
-
-	/* Find the end of dst and adjust bytes left but don't go past end */
-	while (n-- != 0 && *d != '\0')
-		d++;
-	dlen = d - dst;
-	n = siz - dlen;
-
-	if (n == 0)
-		return(dlen + strlen(s));
-	while (*s != '\0') {
-		if (n != 1) {
-			*d++ = *s;
-			n--;
-		}
-		s++;
-	}
-	*d = '\0';
-
-	return(dlen + (s - src));	/* count does not include NUL */
-}
diff --git a/main/editline/np/strlcpy.c b/main/editline/np/strlcpy.c
deleted file mode 100644
index 1f154bc..0000000
--- a/main/editline/np/strlcpy.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/*	$OpenBSD: strlcpy.c,v 1.4 1999/05/01 18:56:41 millert Exp $	*/
-
-/*
- * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
- * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
- * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
- * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#if defined(LIBC_SCCS) && !defined(lint)
-#if 0
-static char *rcsid = "$OpenBSD: strlcpy.c,v 1.4 1999/05/01 18:56:41 millert Exp $";
-#endif
-#endif /* LIBC_SCCS and not lint */
-#ifndef lint
-static const char rcsid[] =
-  "$FreeBSD: src/lib/libc/string/strlcpy.c,v 1.2.4.1 2001/07/09 23:30:06 obrien Exp $";
-#endif
-
-#include <sys/types.h>
-#include <string.h>
-
-/*
- * Copy src to string dst of size siz.  At most siz-1 characters
- * will be copied.  Always NUL terminates (unless siz == 0).
- * Returns strlen(src); if retval >= siz, truncation occurred.
- */
-size_t strlcpy(dst, src, siz)
-	char *dst;
-	const char *src;
-	size_t siz;
-{
-	register char *d = dst;
-	register const char *s = src;
-	register size_t n = siz;
-
-	/* Copy as many bytes as will fit */
-	if (n != 0 && --n != 0) {
-		do {
-			if ((*d++ = *s++) == 0)
-				break;
-		} while (--n != 0);
-	}
-
-	/* Not enough room in dst, add NUL and traverse rest of src */
-	if (n == 0) {
-		if (siz != 0)
-			*d = '\0';		/* NUL-terminate dst */
-		while (*s++)
-			;
-	}
-
-	return(s - src - 1);	/* count does not include NUL */
-}
diff --git a/main/editline/np/unvis.c b/main/editline/np/unvis.c
deleted file mode 100644
index 844a558..0000000
--- a/main/editline/np/unvis.c
+++ /dev/null
@@ -1,322 +0,0 @@
-/*	$NetBSD: unvis.c,v 1.22 2002/03/23 17:38:27 christos Exp $	*/
-
-/*-
- * Copyright (c) 1989, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include <sys/cdefs.h>
-#if defined(LIBC_SCCS) && !defined(lint)
-#if 0
-static char sccsid[] = "@(#)unvis.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: unvis.c,v 1.22 2002/03/23 17:38:27 christos Exp $");
-#endif
-#endif /* LIBC_SCCS and not lint */
-
-#define __LIBC12_SOURCE__
-
-#include <sys/types.h>
-
-#include <assert.h>
-#include <ctype.h>
-#include <stdio.h>
-#include "np/vis.h"
-
-#ifdef __weak_alias
-__weak_alias(strunvis,_strunvis)
-__weak_alias(unvis,_unvis)
-#endif
-
-#ifdef __warn_references
-__warn_references(unvis,
-    "warning: reference to compatibility unvis(); include <vis.h> for correct reference")
-#endif
-
-#ifndef HAVE_VIS_H
-/*
- * decode driven by state machine
- */
-#define	S_GROUND	0	/* haven't seen escape char */
-#define	S_START		1	/* start decoding special sequence */
-#define	S_META		2	/* metachar started (M) */
-#define	S_META1		3	/* metachar more, regular char (-) */
-#define	S_CTRL		4	/* control char started (^) */
-#define	S_OCTAL2	5	/* octal digit 2 */
-#define	S_OCTAL3	6	/* octal digit 3 */
-#define S_HEX1		7	/* hex digit */
-#define S_HEX2		8	/* hex digit 2 */
-
-#define	isoctal(c)	(((u_char)(c)) >= '0' && ((u_char)(c)) <= '7')
-#define xtod(c)		(isdigit(c) ? (c - '0') : ((tolower(c) - 'a') + 10))
-
-int
-unvis(cp, c, astate, flag)
-	char *cp;
-	int c;
-	int *astate, flag;
-{
-	return __unvis13(cp, (int)c, astate, flag);
-}
-
-/*
- * unvis - decode characters previously encoded by vis
- */
-int
-__unvis13(cp, c, astate, flag)
-	char *cp;
-	int c;
-	int *astate, flag;
-{
-
-	_DIAGASSERT(cp != NULL);
-	_DIAGASSERT(astate != NULL);
-
-	if (flag & UNVIS_END) {
-		if (*astate == S_OCTAL2 || *astate == S_OCTAL3
-		    || *astate == S_HEX2) {
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		} 
-		return (*astate == S_GROUND ? UNVIS_NOCHAR : UNVIS_SYNBAD);
-	}
-
-	switch (*astate) {
-
-	case S_GROUND:
-		*cp = 0;
-		if (c == '\\') {
-			*astate = S_START;
-			return (0);
-		} 
-		if ((flag & VIS_HTTPSTYLE) && c == '%') {
-			*astate = S_HEX1;
-			return (0);
-		}
-		*cp = c;
-		return (UNVIS_VALID);
-
-	case S_START:
-		switch(c) {
-		case '\\':
-			*cp = c;
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case '0': case '1': case '2': case '3':
-		case '4': case '5': case '6': case '7':
-			*cp = (c - '0');
-			*astate = S_OCTAL2;
-			return (0);
-		case 'M':
-			*cp = (char)0200;
-			*astate = S_META;
-			return (0);
-		case '^':
-			*astate = S_CTRL;
-			return (0);
-		case 'n':
-			*cp = '\n';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 'r':
-			*cp = '\r';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 'b':
-			*cp = '\b';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 'a':
-			*cp = '\007';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 'v':
-			*cp = '\v';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 't':
-			*cp = '\t';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 'f':
-			*cp = '\f';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 's':
-			*cp = ' ';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 'E':
-			*cp = '\033';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case '\n':
-			/*
-			 * hidden newline
-			 */
-			*astate = S_GROUND;
-			return (UNVIS_NOCHAR);
-		case '$':
-			/*
-			 * hidden marker
-			 */
-			*astate = S_GROUND;
-			return (UNVIS_NOCHAR);
-		}
-		*astate = S_GROUND;
-		return (UNVIS_SYNBAD);
-		 
-	case S_META:
-		if (c == '-')
-			*astate = S_META1;
-		else if (c == '^')
-			*astate = S_CTRL;
-		else {
-			*astate = S_GROUND;
-			return (UNVIS_SYNBAD);
-		}
-		return (0);
-		 
-	case S_META1:
-		*astate = S_GROUND;
-		*cp |= c;
-		return (UNVIS_VALID);
-		 
-	case S_CTRL:
-		if (c == '?')
-			*cp |= 0177;
-		else
-			*cp |= c & 037;
-		*astate = S_GROUND;
-		return (UNVIS_VALID);
-
-	case S_OCTAL2:	/* second possible octal digit */
-		if (isoctal(c)) {
-			/* 
-			 * yes - and maybe a third 
-			 */
-			*cp = (*cp << 3) + (c - '0');
-			*astate = S_OCTAL3;	
-			return (0);
-		} 
-		/* 
-		 * no - done with current sequence, push back passed char 
-		 */
-		*astate = S_GROUND;
-		return (UNVIS_VALIDPUSH);
-
-	case S_OCTAL3:	/* third possible octal digit */
-		*astate = S_GROUND;
-		if (isoctal(c)) {
-			*cp = (*cp << 3) + (c - '0');
-			return (UNVIS_VALID);
-		}
-		/*
-		 * we were done, push back passed char
-		 */
-		return (UNVIS_VALIDPUSH);
-	case S_HEX1:
-		if (isxdigit(c)) {
-			*cp = xtod(c);
-			*astate = S_HEX2;
-			return (0);
-		}
-		/* 
-		 * no - done with current sequence, push back passed char 
-		 */
-		*astate = S_GROUND;
-		return (UNVIS_VALIDPUSH);
-	case S_HEX2:
-                *astate = S_GROUND;
-                if (isxdigit(c)) {
-                        *cp = xtod(c) | (*cp << 4);
-			return (UNVIS_VALID);
-		}
-                return (UNVIS_VALIDPUSH);
-	default:	
-		/* 
-		 * decoder in unknown state - (probably uninitialized) 
-		 */
-		*astate = S_GROUND;
-		return (UNVIS_SYNBAD);
-	}
-}
-
-/*
- * strunvis - decode src into dst 
- *
- *	Number of chars decoded into dst is returned, -1 on error.
- *	Dst is null terminated.
- */
-
-int
-strunvisx(dst, src, flag)
-	char *dst;
-	const char *src;
-	int flag;
-{
-	char c;
-	char *start = dst;
-	int state = 0;
-
-	_DIAGASSERT(src != NULL);
-	_DIAGASSERT(dst != NULL);
-
-	while ((c = *src++) != '\0') {
-	again:
-		switch (__unvis13(dst, c, &state, flag)) {
-		case UNVIS_VALID:
-			dst++;
-			break;
-		case UNVIS_VALIDPUSH:
-			dst++;
-			goto again;
-		case 0:
-		case UNVIS_NOCHAR:
-			break;
-		default:
-			return (-1);
-		}
-	}
-	if (__unvis13(dst, c, &state, UNVIS_END) == UNVIS_VALID)
-		dst++;
-	*dst = '\0';
-	return (dst - start);
-}
-
-int
-strunvis(dst, src)
-	char *dst;
-	const char *src;
-{
-	return strunvisx(dst, src, 0);
-}
-#endif
diff --git a/main/editline/np/vis.c b/main/editline/np/vis.c
deleted file mode 100644
index bd81924..0000000
--- a/main/editline/np/vis.c
+++ /dev/null
@@ -1,348 +0,0 @@
-/*	$NetBSD: vis.c,v 1.22 2002/03/23 17:38:27 christos Exp $	*/
-
-/*-
- * Copyright (c) 1999 The NetBSD Foundation, Inc.
- * Copyright (c) 1989, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include <sys/cdefs.h>
-#if defined(LIBC_SCCS) && !defined(lint)
-__RCSID("$NetBSD: vis.c,v 1.22 2002/03/23 17:38:27 christos Exp $");
-#endif /* LIBC_SCCS and not lint */
-
-#include <sys/types.h>
-
-#include <assert.h>
-#include "np/vis.h"
-#include <stdlib.h>
-#include <stdint.h>
-
-#ifdef __weak_alias
-__weak_alias(strsvis,_strsvis)
-__weak_alias(strsvisx,_strsvisx)
-__weak_alias(strvis,_strvis)
-__weak_alias(strvisx,_strvisx)
-__weak_alias(svis,_svis)
-__weak_alias(vis,_vis)
-#endif
-
-#ifndef HAVE_VIS_H
-#include <ctype.h>
-#include <limits.h>
-#include <stdio.h>
-#include <string.h>
-
-#undef BELL
-#if defined(__STDC__)
-#define BELL '\a'
-#else
-#define BELL '\007'
-#endif
-
-#ifdef SOLARIS
-#include <alloca.h>
-#endif
-
-#define isoctal(c)	(((u_char)(c)) >= '0' && ((u_char)(c)) <= '7')
-#define iswhite(c)	(c == ' ' || c == '\t' || c == '\n')
-#define issafe(c)	(c == '\b' || c == BELL || c == '\r')
-#define xtoa(c)		"0123456789abcdef"[c]
-
-#define MAXEXTRAS       5
-
-
-#define MAKEEXTRALIST(flag, extra, orig)				      \
-do {									      \
-	const char *o = orig;						      \
-	char *e;						      	      \
-	while (*o++)							      \
-		continue;						      \
-	extra = alloca((size_t)((o - orig) + MAXEXTRAS));	      	      \
-	for (o = orig, e = extra; (*e++ = *o++) != '\0';)		      \
-		continue;						      \
-	e--;								      \
-	if (flag & VIS_SP) *e++ = ' ';				      	      \
-	if (flag & VIS_TAB) *e++ = '\t';				      \
-	if (flag & VIS_NL) *e++ = '\n';				      	      \
-	if ((flag & VIS_NOSLASH) == 0) *e++ = '\\';		      	      \
-	*e = '\0';							      \
-} while (/*CONSTCOND*/0)
-
-
-/*
- * This is HVIS, the macro of vis used to HTTP style (RFC 1808)
- */
-#define HVIS(dst, c, flag, nextc, extra)				      \
-do 									      \
-	if (!isascii(c) || !isalnum(c) || strchr("$-_.+!*'(),", c) != NULL) { \
-		*dst++ = '%';						      \
-		*dst++ = xtoa(((unsigned int)c >> 4) & 0xf);		      \
-		*dst++ = xtoa((unsigned int)c & 0xf);			      \
-	} else {							      \
-		SVIS(dst, c, flag, nextc, extra);			      \
-	}								      \
-while (/*CONSTCOND*/0)
-	
-/*
- * This is SVIS, the central macro of vis.
- * dst:	      Pointer to the destination buffer
- * c:	      Character to encode
- * flag:      Flag word
- * nextc:     The character following 'c'
- * extra:     Pointer to the list of extra characters to be
- *	      backslash-protected.
- */
-#define SVIS(dst, c, flag, nextc, extra)				      \
-do {									      \
-	int isextra, isc;						      \
-	isextra = strchr(extra, c) != NULL;				      \
-	if (!isextra && isascii(c) && (isgraph(c) || iswhite(c) ||	      \
-	    ((flag & VIS_SAFE) && issafe(c)))) {			      \
-		*dst++ = c;						      \
-		break;							      \
-	}								      \
-	isc = 0;							      \
-	if (flag & VIS_CSTYLE) {					      \
-		switch (c) {						      \
-		case '\n':						      \
-			isc = 1; *dst++ = '\\'; *dst++ = 'n';		      \
-			break;						      \
-		case '\r':						      \
-			isc = 1; *dst++ = '\\'; *dst++ = 'r';		      \
-			break;						      \
-		case '\b':						      \
-			isc = 1; *dst++ = '\\'; *dst++ = 'b';		      \
-			break;						      \
-		case BELL:						      \
-			isc = 1; *dst++ = '\\'; *dst++ = 'a';		      \
-			break;						      \
-		case '\v':						      \
-			isc = 1; *dst++ = '\\'; *dst++ = 'v';		      \
-			break;						      \
-		case '\t':						      \
-			isc = 1; *dst++ = '\\'; *dst++ = 't';		      \
-			break;						      \
-		case '\f':						      \
-			isc = 1; *dst++ = '\\'; *dst++ = 'f';		      \
-			break;						      \
-		case ' ':						      \
-			isc = 1; *dst++ = '\\'; *dst++ = 's';		      \
-			break;						      \
-		case '\0':						      \
-			isc = 1; *dst++ = '\\'; *dst++ = '0';		      \
-			if (isoctal(nextc)) {				      \
-				*dst++ = '0';				      \
-				*dst++ = '0';				      \
-			}						      \
-		}							      \
-	}								      \
-	if (isc) break;							      \
-	if (isextra || ((c & 0177) == ' ') || (flag & VIS_OCTAL)) {	      \
-		*dst++ = '\\';						      \
-		*dst++ = (u_char)(((uint32_t)(u_char)c >> 6) & 03) + '0';     \
-		*dst++ = (u_char)(((uint32_t)(u_char)c >> 3) & 07) + '0';     \
-		*dst++ =			     (c	      & 07) + '0';    \
-	} else {							      \
-		if ((flag & VIS_NOSLASH) == 0) *dst++ = '\\';		      \
-		if (c & 0200) {						      \
-			c &= 0177; *dst++ = 'M';			      \
-		}							      \
-		if (iscntrl(c)) {					      \
-			*dst++ = '^';					      \
-			if (c == 0177)					      \
-				*dst++ = '?';				      \
-			else						      \
-				*dst++ = c + '@';			      \
-		} else {						      \
-			*dst++ = '-'; *dst++ = c;			      \
-		}							      \
-	}								      \
-} while (/*CONSTCOND*/0)
-
-
-/*
- * svis - visually encode characters, also encoding the characters
- * 	  pointed to by `extra'
- */
-char *
-svis(dst, c, flag, nextc, extra)
-	char *dst;
-	int c, flag, nextc;
-	const char *extra;
-{
-	char *nextra;
-	_DIAGASSERT(dst != NULL);
-	_DIAGASSERT(extra != NULL);
-	MAKEEXTRALIST(flag, nextra, extra);
-	if (flag & VIS_HTTPSTYLE)
-		HVIS(dst, c, flag, nextc, nextra);
-	else
-		SVIS(dst, c, flag, nextc, nextra);
-	*dst = '\0';
-	return(dst);
-}
-
-
-/*
- * strsvis, strsvisx - visually encode characters from src into dst
- *
- *	Extra is a pointer to a \0-terminated list of characters to
- *	be encoded, too. These functions are useful e. g. to
- *	encode strings in such a way so that they are not interpreted
- *	by a shell.
- *	
- *	Dst must be 4 times the size of src to account for possible
- *	expansion.  The length of dst, not including the trailing NULL,
- *	is returned. 
- *
- *	Strsvisx encodes exactly len bytes from src into dst.
- *	This is useful for encoding a block of data.
- */
-int
-strsvis(dst, src, flag, extra)
-	char *dst;
-	const char *src;
-	int flag;
-	const char *extra;
-{
-	char c;
-	char *start;
-	char *nextra;
-
-	_DIAGASSERT(dst != NULL);
-	_DIAGASSERT(src != NULL);
-	_DIAGASSERT(extra != NULL);
-	MAKEEXTRALIST(flag, nextra, extra);
-	if (flag & VIS_HTTPSTYLE) {
-		for (start = dst; (c = *src++) != '\0'; /* empty */)
-			HVIS(dst, c, flag, *src, nextra);
-	} else {
-		for (start = dst; (c = *src++) != '\0'; /* empty */)
-			SVIS(dst, c, flag, *src, nextra);
-	}
-	*dst = '\0';
-	return (dst - start);
-}
-
-
-int
-strsvisx(dst, src, len, flag, extra)
-	char *dst;
-	const char *src;
-	size_t len;
-	int flag;
-	const char *extra;
-{
-	char c;
-	char *start;
-	char *nextra;
-
-	_DIAGASSERT(dst != NULL);
-	_DIAGASSERT(src != NULL);
-	_DIAGASSERT(extra != NULL);
-	MAKEEXTRALIST(flag, nextra, extra);
-
-	if (flag & VIS_HTTPSTYLE) {
-		for (start = dst; len > 0; len--) {
-			c = *src++;
-			HVIS(dst, c, flag, len ? *src : '\0', nextra);
-		}
-	} else {
-		for (start = dst; len > 0; len--) {
-			c = *src++;
-			SVIS(dst, c, flag, len ? *src : '\0', nextra);
-		}
-	}
-	*dst = '\0';
-	return (dst - start);
-}
-
-
-/*
- * vis - visually encode characters
- */
-char *
-vis(dst, c, flag, nextc)
-	char *dst;
-	int c, flag, nextc;
-	
-{
-	char *extra;
-
-	_DIAGASSERT(dst != NULL);
-
-	MAKEEXTRALIST(flag, extra, "");
-	if (flag & VIS_HTTPSTYLE)
-	    HVIS(dst, c, flag, nextc, extra);
-	else
-	    SVIS(dst, c, flag, nextc, extra);
-	*dst = '\0';
-	return (dst);
-}
-
-
-/*
- * strvis, strvisx - visually encode characters from src into dst
- *	
- *	Dst must be 4 times the size of src to account for possible
- *	expansion.  The length of dst, not including the trailing NULL,
- *	is returned. 
- *
- *	Strvisx encodes exactly len bytes from src into dst.
- *	This is useful for encoding a block of data.
- */
-int
-strvis(dst, src, flag)
-	char *dst;
-	const char *src;
-	int flag;
-{
-	char *extra;
-
-	MAKEEXTRALIST(flag, extra, "");
-	return (strsvis(dst, src, flag, extra));
-}
-
-
-int
-strvisx(dst, src, len, flag)
-	char *dst;
-	const char *src;
-	size_t len;
-	int flag;
-{
-	char *extra;
-
-	MAKEEXTRALIST(flag, extra, "");
-	return (strsvisx(dst, src, len, flag, extra));
-}
-#endif
diff --git a/main/editline/np/vis.h b/main/editline/np/vis.h
deleted file mode 100644
index 0739c1d..0000000
--- a/main/editline/np/vis.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/*	$NetBSD: vis.h,v 1.12 2002/03/23 17:39:05 christos Exp $	*/
-
-/*-
- * Copyright (c) 1990, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)vis.h	8.1 (Berkeley) 6/2/93
- */
-
-#ifndef _VIS_H_
-#define	_VIS_H_
-
-/*
- * to select alternate encoding format
- */
-#define	VIS_OCTAL	0x01	/* use octal \ddd format */
-#define	VIS_CSTYLE	0x02	/* use \[nrft0..] where appropiate */
-
-/*
- * to alter set of characters encoded (default is to encode all
- * non-graphic except space, tab, and newline).
- */
-#define	VIS_SP		0x04	/* also encode space */
-#define	VIS_TAB		0x08	/* also encode tab */
-#define	VIS_NL		0x10	/* also encode newline */
-#define	VIS_WHITE	(VIS_SP | VIS_TAB | VIS_NL)
-#define	VIS_SAFE	0x20	/* only encode "unsafe" characters */
-
-/*
- * other
- */
-#define	VIS_NOSLASH	0x40	/* inhibit printing '\' */
-#define	VIS_HTTPSTYLE	0x80	/* http-style escape % HEX HEX */
-
-/*
- * unvis return codes
- */
-#define	UNVIS_VALID	 1	/* character valid */
-#define	UNVIS_VALIDPUSH	 2	/* character valid, push back passed char */
-#define	UNVIS_NOCHAR	 3	/* valid sequence, no character produced */
-#define	UNVIS_SYNBAD	-1	/* unrecognized escape sequence */
-#define	UNVIS_ERROR	-2	/* decoder in unknown state (unrecoverable) */
-
-/*
- * unvis flags
- */
-#define	UNVIS_END	1	/* no more characters */
-
-#include <sys/cdefs.h>
-
-__BEGIN_DECLS
-char	*vis __P((char *, int, int, int));
-char	*svis __P((char *, int, int, int, const char *));
-int	strvis __P((char *, const char *, int));
-int	strsvis __P((char *, const char *, int, const char *));
-int	strvisx __P((char *, const char *, size_t, int));
-int	strsvisx __P((char *, const char *, size_t, int, const char *));
-int	strunvis __P((char *, const char *));
-int	strunvisx __P((char *, const char *, int));
-#ifdef __LIBC12_SOURCE__
-int	unvis __P((char *, int, int *, int));
-int	__unvis13 __P((char *, int, int *, int));
-#else
-int	unvis __P((char *, int, int *, int))	__RENAME(__unvis13);
-#endif
-__END_DECLS
-
-#endif /* !_VIS_H_ */
diff --git a/main/editline/parse.c b/main/editline/parse.c
deleted file mode 100644
index 0a34f0b..0000000
--- a/main/editline/parse.c
+++ /dev/null
@@ -1,259 +0,0 @@
-/*	$NetBSD: parse.c,v 1.15 2002/03/18 16:00:56 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)parse.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: parse.c,v 1.15 2002/03/18 16:00:56 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * parse.c: parse an editline extended command
- *
- * commands are:
- *
- *	bind
- *	echotc
- *	edit
- *	gettc
- *	history
- *	settc
- *	setty
- */
-#include "el.h"
-#include "tokenizer.h"
-#include <stdlib.h>
-
-private const struct {
-	const char *name;
-	int (*func)(EditLine *, int, const char **);
-} cmds[] = {
-	{ "bind",	map_bind	},
-	{ "echotc",	term_echotc	},
-	{ "edit",	el_editmode	},
-	{ "history",	hist_list	},
-	{ "telltc",	term_telltc	},
-	{ "settc",	term_settc	},
-	{ "setty",	tty_stty	},
-	{ NULL,		NULL		}
-};
-
-
-/* parse_line():
- *	Parse a line and dispatch it
- */
-protected int
-parse_line(EditLine *el, const char *line)
-{
-	const char **argv;
-	int argc;
-	Tokenizer *tok;
-
-	tok = tok_init(NULL);
-	tok_line(tok, line, &argc, &argv);
-	argc = el_parse(el, argc, argv);
-	tok_end(tok);
-	return (argc);
-}
-
-
-/* el_parse():
- *	Command dispatcher
- */
-public int
-el_parse(EditLine *el, int argc, const char *argv[])
-{
-	const char *ptr;
-	int i;
-
-	if (argc < 1)
-		return (-1);
-	ptr = strchr(argv[0], ':');
-	if (ptr != NULL) {
-		char *tprog;
-		size_t l;
-
-		if (ptr == argv[0])
-			return (0);
-		l = ptr - argv[0] - 1;
-		tprog = (char *) el_malloc(l + 1);
-		if (tprog == NULL)
-			return (0);
-		(void) strncpy(tprog, argv[0], l);
-		tprog[l] = '\0';
-		ptr++;
-		l = el_match(el->el_prog, tprog);
-		el_free(tprog);
-		if (!l)
-			return (0);
-	} else
-		ptr = argv[0];
-
-	for (i = 0; cmds[i].name != NULL; i++)
-		if (strcmp(cmds[i].name, ptr) == 0) {
-			i = (*cmds[i].func) (el, argc, argv);
-			return (-i);
-		}
-	return (-1);
-}
-
-
-/* parse__escape():
- *	Parse a string of the form ^<char> \<odigit> \<char> and return
- *	the appropriate character or -1 if the escape is not valid
- */
-protected int
-parse__escape(const char **const ptr)
-{
-	const char *p;
-	int c;
-
-	p = *ptr;
-
-	if (p[1] == 0)
-		return (-1);
-
-	if (*p == '\\') {
-		p++;
-		switch (*p) {
-		case 'a':
-			c = '\007';	/* Bell */
-			break;
-		case 'b':
-			c = '\010';	/* Backspace */
-			break;
-		case 't':
-			c = '\011';	/* Horizontal Tab */
-			break;
-		case 'n':
-			c = '\012';	/* New Line */
-			break;
-		case 'v':
-			c = '\013';	/* Vertical Tab */
-			break;
-		case 'f':
-			c = '\014';	/* Form Feed */
-			break;
-		case 'r':
-			c = '\015';	/* Carriage Return */
-			break;
-		case 'e':
-			c = '\033';	/* Escape */
-			break;
-		case '0':
-		case '1':
-		case '2':
-		case '3':
-		case '4':
-		case '5':
-		case '6':
-		case '7':
-		{
-			int cnt, ch;
-
-			for (cnt = 0, c = 0; cnt < 3; cnt++) {
-				ch = *p++;
-				if (ch < '0' || ch > '7') {
-					p--;
-					break;
-				}
-				c = (c << 3) | (ch - '0');
-			}
-			if ((c & 0xffffff00) != 0)
-				return (-1);
-			--p;
-			break;
-		}
-		default:
-			c = *p;
-			break;
-		}
-	} else if (*p == '^' && isalpha((unsigned char) p[1])) {
-		p++;
-		c = (*p == '?') ? '\177' : (*p & 0237);
-	} else
-		c = *p;
-	*ptr = ++p;
-	return (c);
-}
-/* parse__string():
- *	Parse the escapes from in and put the raw string out
- */
-protected char *
-parse__string(char *out, const char *in)
-{
-	char *rv = out;
-	int n;
-
-	for (;;)
-		switch (*in) {
-		case '\0':
-			*out = '\0';
-			return (rv);
-
-		case '\\':
-		case '^':
-			if ((n = parse__escape(&in)) == -1)
-				return (NULL);
-			*out++ = n;
-			break;
-
-		default:
-			*out++ = *in++;
-			break;
-		}
-}
-
-
-/* parse_cmd():
- *	Return the command number for the command string given
- *	or -1 if one is not found
- */
-protected int
-parse_cmd(EditLine *el, const char *cmd)
-{
-	el_bindings_t *b;
-
-	for (b = el->el_map.help; b->name != NULL; b++)
-		if (strcmp(b->name, cmd) == 0)
-			return (b->func);
-	return (-1);
-}
diff --git a/main/editline/parse.h b/main/editline/parse.h
deleted file mode 100644
index 4aaef2f..0000000
--- a/main/editline/parse.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*	$NetBSD: parse.h,v 1.4 2000/09/04 22:06:31 lukem Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)parse.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.parse.h: Parser functions
- */
-#ifndef _h_el_parse
-#define	_h_el_parse
-
-protected int	 parse_line(EditLine *, const char *);
-protected int	 parse__escape(const char ** const);
-protected char	*parse__string(char *, const char *);
-protected int	 parse_cmd(EditLine *, const char *);
-
-#endif /* _h_el_parse */
diff --git a/main/editline/prompt.c b/main/editline/prompt.c
deleted file mode 100644
index 5c069e1..0000000
--- a/main/editline/prompt.c
+++ /dev/null
@@ -1,174 +0,0 @@
-/*	$NetBSD: prompt.c,v 1.9 2002/03/18 16:00:56 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)prompt.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: prompt.c,v 1.9 2002/03/18 16:00:56 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * prompt.c: Prompt printing functions
- */
-#include <stdio.h>
-#include "el.h"
-
-private char	*prompt_default(EditLine *);
-private char	*prompt_default_r(EditLine *);
-
-/* prompt_default():
- *	Just a default prompt, in case the user did not provide one
- */
-private char *
-/*ARGSUSED*/
-prompt_default(EditLine *el)
-{
-	static char a[3] = {'?', ' ', '\0'};
-
-	return (a);
-}
-
-
-/* prompt_default_r():
- *	Just a default rprompt, in case the user did not provide one
- */
-private char *
-/*ARGSUSED*/
-prompt_default_r(EditLine *el)
-{
-	static char a[1] = {'\0'};
-
-	return (a);
-}
-
-
-/* prompt_print():
- *	Print the prompt and update the prompt position.
- *	We use an array of integers in case we want to pass
- * 	literal escape sequences in the prompt and we want a
- *	bit to flag them
- */
-protected void
-prompt_print(EditLine *el, int op)
-{
-	el_prompt_t *elp;
-	char *p;
-
-	if (op == EL_PROMPT)
-		elp = &el->el_prompt;
-	else
-		elp = &el->el_rprompt;
-	p = (elp->p_func) (el);
-	while (*p)
-		re_putc(el, *p++, 1);
-
-	elp->p_pos.v = el->el_refresh.r_cursor.v;
-	elp->p_pos.h = el->el_refresh.r_cursor.h;
-}
-
-
-/* prompt_init():
- *	Initialize the prompt stuff
- */
-protected int
-prompt_init(EditLine *el)
-{
-
-	el->el_prompt.p_func = prompt_default;
-	el->el_prompt.p_pos.v = 0;
-	el->el_prompt.p_pos.h = 0;
-	el->el_rprompt.p_func = prompt_default_r;
-	el->el_rprompt.p_pos.v = 0;
-	el->el_rprompt.p_pos.h = 0;
-	return (0);
-}
-
-
-/* prompt_end():
- *	Clean up the prompt stuff
- */
-protected void
-/*ARGSUSED*/
-prompt_end(EditLine *el)
-{
-}
-
-
-/* prompt_set():
- *	Install a prompt printing function
- */
-protected int
-prompt_set(EditLine *el, el_pfunc_t prf, int op)
-{
-	el_prompt_t *p;
-
-	if (op == EL_PROMPT)
-		p = &el->el_prompt;
-	else
-		p = &el->el_rprompt;
-	if (prf == NULL) {
-		if (op == EL_PROMPT)
-			p->p_func = prompt_default;
-		else
-			p->p_func = prompt_default_r;
-	} else
-		p->p_func = prf;
-	p->p_pos.v = 0;
-	p->p_pos.h = 0;
-	return (0);
-}
-
-
-/* prompt_get():
- *	Retrieve the prompt printing function
- */
-protected int
-prompt_get(EditLine *el, el_pfunc_t *prf, int op)
-{
-
-	if (prf == NULL)
-		return (-1);
-	if (op == EL_PROMPT)
-		*prf = el->el_prompt.p_func;
-	else
-		*prf = el->el_rprompt.p_func;
-	return (0);
-}
diff --git a/main/editline/prompt.h b/main/editline/prompt.h
deleted file mode 100644
index 08810e2..0000000
--- a/main/editline/prompt.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/*	$NetBSD: prompt.h,v 1.5 2000/09/04 22:06:31 lukem Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)prompt.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.prompt.h: Prompt printing stuff
- */
-#ifndef _h_el_prompt
-#define	_h_el_prompt
-
-#include "histedit.h"
-
-typedef char * (*el_pfunc_t)(EditLine*);
-
-typedef struct el_prompt_t {
-	el_pfunc_t	p_func;	/* Function to return the prompt	*/
-	coord_t		p_pos;	/* position in the line after prompt	*/
-} el_prompt_t;
-
-protected void	prompt_print(EditLine *, int);
-protected int	prompt_set(EditLine *, el_pfunc_t, int);
-protected int	prompt_get(EditLine *, el_pfunc_t *, int);
-protected int	prompt_init(EditLine *);
-protected void	prompt_end(EditLine *);
-
-#endif /* _h_el_prompt */
diff --git a/main/editline/read.c b/main/editline/read.c
deleted file mode 100644
index 80d51da..0000000
--- a/main/editline/read.c
+++ /dev/null
@@ -1,558 +0,0 @@
-/*	$NetBSD: read.c,v 1.21 2002/03/18 16:00:57 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)read.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: read.c,v 1.21 2002/03/18 16:00:57 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * read.c: Clean this junk up! This is horrible code.
- *	   Terminal read functions
- */
-#include <errno.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include "el.h"
-
-#define	OKCMD	-1
-
-private int	read__fixio(int, int);
-private int	read_preread(EditLine *);
-private int	read_char(EditLine *, char *);
-private int	read_getcmd(EditLine *, el_action_t *, char *);
-
-/* read_init():
- *	Initialize the read stuff
- */
-protected int
-read_init(EditLine *el)
-{
-	/* builtin read_char */
-	el->el_read.read_char = read_char;
-	return 0;
-}
-
-
-/* el_read_setfn():
- *	Set the read char function to the one provided.
- *	If it is set to EL_BUILTIN_GETCFN, then reset to the builtin one.
- */
-protected int
-el_read_setfn(EditLine *el, el_rfunc_t rc)
-{
-	el->el_read.read_char = (rc == EL_BUILTIN_GETCFN) ? read_char : rc;
-	return 0;
-}
-
-
-/* el_read_getfn():
- *	return the current read char function, or EL_BUILTIN_GETCFN
- *	if it is the default one
- */
-protected el_rfunc_t
-el_read_getfn(EditLine *el)
-{
-       return (el->el_read.read_char == read_char) ?
-	    EL_BUILTIN_GETCFN : el->el_read.read_char;
-}
-
-
-#ifdef DEBUG_EDIT
-private void
-read_debug(EditLine *el)
-{
-
-	if (el->el_line.cursor > el->el_line.lastchar)
-		(void) fprintf(el->el_errfile, "cursor > lastchar\r\n");
-	if (el->el_line.cursor < el->el_line.buffer)
-		(void) fprintf(el->el_errfile, "cursor < buffer\r\n");
-	if (el->el_line.cursor > el->el_line.limit)
-		(void) fprintf(el->el_errfile, "cursor > limit\r\n");
-	if (el->el_line.lastchar > el->el_line.limit)
-		(void) fprintf(el->el_errfile, "lastchar > limit\r\n");
-	if (el->el_line.limit != &el->el_line.buffer[EL_BUFSIZ - 2])
-		(void) fprintf(el->el_errfile, "limit != &buffer[EL_BUFSIZ-2]\r\n");
-}
-#endif /* DEBUG_EDIT */
-
-
-/* read__fixio():
- *	Try to recover from a read error
- */
-/* ARGSUSED */
-private int
-read__fixio(int fd, int e)
-{
-
-	switch (e) {
-	case -1:		/* Make sure that the code is reachable */
-
-#ifdef EWOULDBLOCK
-	case EWOULDBLOCK:
-#ifndef TRY_AGAIN
-#define	TRY_AGAIN
-#endif
-#endif /* EWOULDBLOCK */
-
-#if defined(POSIX) && defined(EAGAIN)
-#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
-	case EAGAIN:
-#ifndef TRY_AGAIN
-#define	TRY_AGAIN
-#endif
-#endif /* EWOULDBLOCK && EWOULDBLOCK != EAGAIN */
-#endif /* POSIX && EAGAIN */
-
-		e = 0;
-#ifdef TRY_AGAIN
-#if defined(F_SETFL) && defined(O_NDELAY)
-		if ((e = fcntl(fd, F_GETFL, 0)) == -1)
-			return (-1);
-
-		if (fcntl(fd, F_SETFL, e & ~O_NDELAY) == -1)
-			return (-1);
-		else
-			e = 1;
-#endif /* F_SETFL && O_NDELAY */
-
-#ifdef FIONBIO
-		{
-			int zero = 0;
-
-			if (ioctl(fd, FIONBIO, (ioctl_t) & zero) == -1)
-				return (-1);
-			else
-				e = 1;
-		}
-#endif /* FIONBIO */
-
-#endif /* TRY_AGAIN */
-		return (e ? 0 : -1);
-
-	case EINTR:
-		return (0);
-
-	default:
-		return (-1);
-	}
-}
-
-
-/* read_preread():
- *	Try to read the stuff in the input queue;
- */
-private int
-read_preread(EditLine *el)
-{
-	int chrs = 0;
-
-	if (el->el_chared.c_macro.nline) {
-		el_free((ptr_t) el->el_chared.c_macro.nline);
-		el->el_chared.c_macro.nline = NULL;
-	}
-	if (el->el_tty.t_mode == ED_IO)
-		return (0);
-
-#ifdef FIONREAD
-	(void) ioctl(el->el_infd, FIONREAD, (ioctl_t) & chrs);
-	if (chrs > 0) {
-		char buf[EL_BUFSIZ];
-
-		chrs = read(el->el_infd, buf,
-		    (size_t) MIN(chrs, EL_BUFSIZ - 1));
-		if (chrs > 0) {
-			buf[chrs] = '\0';
-			el->el_chared.c_macro.nline = strdup(buf);
-			el_push(el, el->el_chared.c_macro.nline);
-		}
-	}
-#endif /* FIONREAD */
-
-	return (chrs > 0);
-}
-
-
-/* el_push():
- *	Push a macro
- */
-public void
-el_push(EditLine *el, char *str)
-{
-	c_macro_t *ma = &el->el_chared.c_macro;
-
-	if (str != NULL && ma->level + 1 < EL_MAXMACRO) {
-		ma->level++;
-		ma->macro[ma->level] = str;
-	} else {
-		term_beep(el);
-		term__flush();
-	}
-}
-
-
-/* read_getcmd():
- *	Return next command from the input stream.
- */
-private int
-read_getcmd(EditLine *el, el_action_t *cmdnum, char *ch)
-{
-	el_action_t cmd = ED_UNASSIGNED;
-	int num;
-
-	while (cmd == ED_UNASSIGNED || cmd == ED_SEQUENCE_LEAD_IN) {
-		if ((num = el_getc(el, ch)) != 1)	/* if EOF or error */
-			return (num);
-
-#ifdef	KANJI
-		if ((*ch & 0200)) {
-			el->el_state.metanext = 0;
-			cmd = CcViMap[' '];
-			break;
-		} else
-#endif /* KANJI */
-
-		if (el->el_state.metanext) {
-			el->el_state.metanext = 0;
-			*ch |= 0200;
-		}
-		cmd = el->el_map.current[(unsigned char) *ch];
-		if (cmd == ED_SEQUENCE_LEAD_IN) {
-			key_value_t val;
-			switch (key_get(el, ch, &val)) {
-			case XK_CMD:
-				cmd = val.cmd;
-				break;
-			case XK_STR:
-				el_push(el, val.str);
-				break;
-#ifdef notyet
-			case XK_EXE:
-				/* XXX: In the future to run a user function */
-				RunCommand(val.str);
-				break;
-#endif
-			default:
-				EL_ABORT((el->el_errfile, "Bad XK_ type \n"));
-				break;
-			}
-		}
-		if (el->el_map.alt == NULL)
-			el->el_map.current = el->el_map.key;
-	}
-	*cmdnum = cmd;
-	return (OKCMD);
-}
-
-
-/* read_char():
- *	Read a character from the tty.
- *	XXX This routine is the default, but what you are actually looking for
- *	is in main/asterisk.c, in ast_el_read_char(). XXX
- */
-private int
-read_char(EditLine *el, char *cp)
-{
-	int num_read;
-	int tried = 0;
-
-	while ((num_read = read(el->el_infd, cp, 1)) == -1)
-		if (!tried && read__fixio(el->el_infd, errno) == 0)
-			tried = 1;
-		else {
-			*cp = '\0';
-			return (-1);
-		}
-
-	return (num_read);
-}
-
-
-/* el_getc():
- *	Read a character
- */
-public int
-el_getc(EditLine *el, char *cp)
-{
-	int num_read;
-	c_macro_t *ma = &el->el_chared.c_macro;
-
-	term__flush();
-	for (;;) {
-		if (ma->level < 0) {
-			if (!read_preread(el))
-				break;
-		}
-		if (ma->level < 0)
-			break;
-
-		if (*ma->macro[ma->level] == 0) {
-			ma->level--;
-			continue;
-		}
-		*cp = *ma->macro[ma->level]++ & 0377;
-		if (*ma->macro[ma->level] == 0) {	/* Needed for QuoteMode
-							 * On */
-			ma->level--;
-		}
-		return (1);
-	}
-
-#ifdef DEBUG_READ
-	(void) fprintf(el->el_errfile, "Turning raw mode on\n");
-#endif /* DEBUG_READ */
-	if (tty_rawmode(el) < 0)/* make sure the tty is set up correctly */
-		return (0);
-
-#ifdef DEBUG_READ
-	(void) fprintf(el->el_errfile, "Reading a character\n");
-#endif /* DEBUG_READ */
-	/* See main/asterisk.c: ast_el_read_char() */
-	num_read = (*el->el_read.read_char)(el, cp);
-#ifdef DEBUG_READ
-	(void) fprintf(el->el_errfile, "Got it %c\n", *cp);
-#endif /* DEBUG_READ */
-	return (num_read);
-}
-
-
-public const char *
-el_gets(EditLine *el, int *nread)
-{
-	int retval;
-	el_action_t cmdnum = 0;
-	int num;		/* how many chars we have read at NL */
-	char ch;
-#ifdef FIONREAD
-	c_macro_t *ma = &el->el_chared.c_macro;
-#endif /* FIONREAD */
-
-	if (el->el_flags & HANDLE_SIGNALS)
-		sig_set(el);
-
-	if (el->el_flags & NO_TTY) {
-		char *cp = el->el_line.buffer;
-		size_t idx;
-
-		while ((*el->el_read.read_char)(el, cp) == 1) {
-			/* make sure there is space for next character */
-			if (cp + 1 >= el->el_line.limit) {
-				idx = (cp - el->el_line.buffer);
-				if (!ch_enlargebufs(el, 2))
-					break;
-				cp = &el->el_line.buffer[idx];
-			}
-			cp++;
-			if (cp[-1] == '\r' || cp[-1] == '\n')
-				break;
-		}
-
-		el->el_line.cursor = el->el_line.lastchar = cp;
-		*cp = '\0';
-		if (nread)
-			*nread = el->el_line.cursor - el->el_line.buffer;
-		return (el->el_line.buffer);
-	}
-	re_clear_display(el);	/* reset the display stuff */
-	ch_reset(el);
-
-#ifdef FIONREAD
-	if (el->el_tty.t_mode == EX_IO && ma->level < 0) {
-		long chrs = 0;
-
-		(void) ioctl(el->el_infd, FIONREAD, (ioctl_t) & chrs);
-		if (chrs == 0) {
-			if (tty_rawmode(el) < 0) {
-				if (nread)
-					*nread = 0;
-				return (NULL);
-			}
-		}
-	}
-#endif /* FIONREAD */
-
-	re_refresh(el);		/* print the prompt */
-
-	if (el->el_flags & EDIT_DISABLED) {
-		char *cp = el->el_line.buffer;
-		size_t idx;
-
-		term__flush();
-
-		while ((*el->el_read.read_char)(el, cp) == 1) {
-			/* make sure there is space next character */
-			if (cp + 1 >= el->el_line.limit) {
-				idx = (cp - el->el_line.buffer);
-				if (!ch_enlargebufs(el, 2))
-					break;
-				cp = &el->el_line.buffer[idx];
-			}
-			cp++;
-			if (cp[-1] == '\r' || cp[-1] == '\n')
-				break;
-		}
-
-		el->el_line.cursor = el->el_line.lastchar = cp;
-		*cp = '\0';
-		if (nread)
-			*nread = el->el_line.cursor - el->el_line.buffer;
-		return (el->el_line.buffer);
-	}
-	for (num = OKCMD; num == OKCMD;) {	/* while still editing this
-						 * line */
-#ifdef DEBUG_EDIT
-		read_debug(el);
-#endif /* DEBUG_EDIT */
-		/* if EOF or error */
-		if ((num = read_getcmd(el, &cmdnum, &ch)) != OKCMD) {
-#ifdef DEBUG_READ
-			(void) fprintf(el->el_errfile,
-			    "Returning from el_gets %d\n", num);
-#endif /* DEBUG_READ */
-			break;
-		}
-		if ((int) cmdnum >= el->el_map.nfunc) {	/* BUG CHECK command */
-#ifdef DEBUG_EDIT
-			(void) fprintf(el->el_errfile,
-			    "ERROR: illegal command from key 0%o\r\n", ch);
-#endif /* DEBUG_EDIT */
-			continue;	/* try again */
-		}
-		/* now do the real command */
-#ifdef DEBUG_READ
-		{
-			el_bindings_t *b;
-			for (b = el->el_map.help; b->name; b++)
-				if (b->func == cmdnum)
-					break;
-			if (b->name)
-				(void) fprintf(el->el_errfile,
-				    "Executing %s\n", b->name);
-			else
-				(void) fprintf(el->el_errfile,
-				    "Error command = %d\n", cmdnum);
-		}
-#endif /* DEBUG_READ */
-		retval = (*el->el_map.func[cmdnum]) (el, ch);
-
-		/* save the last command here */
-		el->el_state.lastcmd = cmdnum;
-
-		/* use any return value */
-		switch (retval) {
-		case CC_CURSOR:
-			el->el_state.argument = 1;
-			el->el_state.doingarg = 0;
-			re_refresh_cursor(el);
-			break;
-
-		case CC_REDISPLAY:
-			re_clear_lines(el);
-			re_clear_display(el);
-			/* FALLTHROUGH */
-
-		case CC_REFRESH:
-			el->el_state.argument = 1;
-			el->el_state.doingarg = 0;
-			re_refresh(el);
-			break;
-
-		case CC_REFRESH_BEEP:
-			el->el_state.argument = 1;
-			el->el_state.doingarg = 0;
-			re_refresh(el);
-			term_beep(el);
-			break;
-
-		case CC_NORM:	/* normal char */
-			el->el_state.argument = 1;
-			el->el_state.doingarg = 0;
-			break;
-
-		case CC_ARGHACK:	/* Suggested by Rich Salz */
-			/* <rsalz@pineapple.bbn.com> */
-			break;	/* keep going... */
-
-		case CC_EOF:	/* end of file typed */
-			num = 0;
-			break;
-
-		case CC_NEWLINE:	/* normal end of line */
-			num = el->el_line.lastchar - el->el_line.buffer;
-			break;
-
-		case CC_FATAL:	/* fatal error, reset to known state */
-#ifdef DEBUG_READ
-			(void) fprintf(el->el_errfile,
-			    "*** editor fatal ERROR ***\r\n\n");
-#endif /* DEBUG_READ */
-			/* put (real) cursor in a known place */
-			re_clear_display(el);	/* reset the display stuff */
-			ch_reset(el);	/* reset the input pointers */
-			re_refresh(el);	/* print the prompt again */
-			el->el_state.argument = 1;
-			el->el_state.doingarg = 0;
-			break;
-
-		case CC_ERROR:
-		default:	/* functions we don't know about */
-#ifdef DEBUG_READ
-			(void) fprintf(el->el_errfile,
-			    "*** editor ERROR ***\r\n\n");
-#endif /* DEBUG_READ */
-			el->el_state.argument = 1;
-			el->el_state.doingarg = 0;
-			term_beep(el);
-			term__flush();
-			break;
-		}
-	}
-
-				/* make sure the tty is set up correctly */
-	(void) tty_cookedmode(el);
-	term__flush();		/* flush any buffered output */
-	if (el->el_flags & HANDLE_SIGNALS)
-		sig_clr(el);
-	if (nread)
-		*nread = num;
-	return (num ? el->el_line.buffer : NULL);
-}
diff --git a/main/editline/read.h b/main/editline/read.h
deleted file mode 100644
index b01e77d..0000000
--- a/main/editline/read.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*	$NetBSD: read.h,v 1.1 2001/09/27 19:29:50 christos Exp $	*/
-
-/*-
- * Copyright (c) 2001 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Anthony Mallet.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * el.read.h: Character reading functions
- */
-#ifndef	_h_el_read
-#define	_h_el_read
-
-typedef int (*el_rfunc_t)(EditLine *, char *);
-
-typedef struct el_read_t {
-	el_rfunc_t	read_char;	/* Function to read a character */
-} el_read_t;
- 
-protected int		read_init(EditLine *);
-protected int		el_read_setfn(EditLine *, el_rfunc_t);
-protected el_rfunc_t	el_read_getfn(EditLine *);
-
-#endif /* _h_el_read */
diff --git a/main/editline/readline.c b/main/editline/readline.c
deleted file mode 100644
index 4729fa9..0000000
--- a/main/editline/readline.c
+++ /dev/null
@@ -1,1665 +0,0 @@
-/*	$NetBSD: readline.c,v 1.21 2002/03/18 16:20:36 christos Exp $	*/
-
-/*-
- * Copyright (c) 1997 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Jaromir Dolecek.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the NetBSD
- *	Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "asterisk.h"
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-__RCSID("$NetBSD: readline.c,v 1.21 2002/03/18 16:20:36 christos Exp $");
-#endif /* not lint && not SCCSID */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <stdio.h>
-#include <dirent.h>
-#include <string.h>
-#include <pwd.h>
-#include <ctype.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <limits.h>
-
-#ifdef SOLARIS
-#include <alloca.h>
-#endif
-
-#include "histedit.h"
-#include "readline/readline.h"
-#include "el.h"
-#include "fcns.h"		/* for EL_NUM_FCNS */
-
-/* for rl_complete() */
-#define	TAB		'\r'
-
-/* see comment at the #ifdef for sense of this */
-#define	GDB_411_HACK
-
-/* readline compatibility stuff - look at readline sources/documentation */
-/* to see what these variables mean */
-const char *rl_library_version = "EditLine wrapper";
-static char empty[] = { '\0' };
-static char expand_chars[] = { ' ', '\t', '\n', '=', '(', '\0' };
-static char break_chars[] = { ' ', '\t', '\n', '"', '\\', '\'', '`', '@', '$',
-    '>', '<', '=', ';', '|', '&', '{', '(', '\0' };
-char *rl_readline_name = empty;
-FILE *rl_instream = NULL;
-FILE *rl_outstream = NULL;
-int rl_point = 0;
-int rl_end = 0;
-char *rl_line_buffer = NULL;
-
-int history_base = 1;		/* probably never subject to change */
-int history_length = 0;
-int max_input_history = 0;
-char history_expansion_char = '!';
-char history_subst_char = '^';
-char *history_no_expand_chars = expand_chars;
-Function *history_inhibit_expansion_function = NULL;
-
-int rl_inhibit_completion = 0;
-int rl_attempted_completion_over = 0;
-char *rl_basic_word_break_characters = break_chars;
-char *rl_completer_word_break_characters = NULL;
-char *rl_completer_quote_characters = NULL;
-CPFunction *rl_completion_entry_function = NULL;
-CPPFunction *rl_attempted_completion_function = NULL;
-
-/*
- * This is set to character indicating type of completion being done by
- * rl_complete_internal(); this is available for application completion
- * functions.
- */
-int rl_completion_type = 0;
-
-/*
- * If more than this number of items results from query for possible
- * completions, we ask user if they are sure to really display the list.
- */
-int rl_completion_query_items = 100;
-
-/*
- * List of characters which are word break characters, but should be left
- * in the parsed text when it is passed to the completion function.
- * Shell uses this to help determine what kind of completing to do.
- */
-char *rl_special_prefixes = (char *)NULL;
-
-/*
- * This is the character appended to the completed words if at the end of
- * the line. Default is ' ' (a space).
- */
-int rl_completion_append_character = ' ';
-
-/* stuff below is used internally by libedit for readline emulation */
-
-/* if not zero, non-unique completions always show list of possible matches */
-static int _rl_complete_show_all = 0;
-
-static History *h = NULL;
-static EditLine *e = NULL;
-static int el_rl_complete_cmdnum = 0;
-
-/* internal functions */
-static unsigned char	 _el_rl_complete(EditLine *, int);
-static char		*_get_prompt(EditLine *);
-static HIST_ENTRY	*_move_history(int);
-static int		 _history_search_gen(const char *, int, int);
-static int		 _history_expand_command(const char *, size_t, char **);
-static char		*_rl_compat_sub(const char *, const char *,
-			    const char *, int);
-static int		 rl_complete_internal(int);
-static int		 _rl_qsort_string_compare(const void *, const void *);
-
-/*
- * needed for prompt switching in readline()
- */
-static char *el_rl_prompt = NULL;
-
-
-/* ARGSUSED */
-static char *
-_get_prompt(EditLine *el)
-{
-	return (el_rl_prompt);
-}
-
-
-/*
- * generic function for moving around history
- */
-static HIST_ENTRY *
-_move_history(int op)
-{
-	HistEvent ev;
-	static HIST_ENTRY rl_he;
-
-	if (history(h, &ev, op) != 0)
-		return (HIST_ENTRY *) NULL;
-
-	rl_he.line = ev.str;
-	rl_he.data = "";
-
-	return (&rl_he);
-}
-
-
-/*
- * READLINE compatibility stuff
- */
-
-/*
- * initialize rl compat stuff
- */
-int
-rl_initialize(void)
-{
-	HistEvent ev;
-	const LineInfo *li;
-	int i;
-	int editmode = 1;
-	struct termios t;
-
-	if (e != NULL)
-		el_end(e);
-	if (h != NULL)
-		history_end(h);
-
-	if (!rl_instream)
-		rl_instream = stdin;
-	if (!rl_outstream)
-		rl_outstream = stdout;
-
-	/*
-	 * See if we don't really want to run the editor
-	 */
-	if (tcgetattr(fileno(rl_instream), &t) != -1 && (t.c_lflag & ECHO) == 0)
-		editmode = 0;
-
-	e = el_init(rl_readline_name, rl_instream, rl_outstream, stderr);
-
-	if (!editmode)
-		el_set(e, EL_EDITMODE, 0);
-
-	h = history_init();
-	if (!e || !h)
-		return (-1);
-
-	history(h, &ev, H_SETSIZE, INT_MAX);	/* unlimited */
-	history_length = 0;
-	max_input_history = INT_MAX;
-	el_set(e, EL_HIST, history, h);
-
-	/* for proper prompt printing in readline() */
-	el_rl_prompt = strdup("");
-	el_set(e, EL_PROMPT, _get_prompt);
-	el_set(e, EL_SIGNAL, 1);
-
-	/* set default mode to "emacs"-style and read setting afterwards */
-	/* so this can be overriden */
-	el_set(e, EL_EDITOR, "emacs");
-
-	/*
-	 * Word completition - this has to go AFTER rebinding keys
-	 * to emacs-style.
-	 */
-	el_set(e, EL_ADDFN, "rl_complete",
-	    "ReadLine compatible completition function",
-	    _el_rl_complete);
-	el_set(e, EL_BIND, "^I", "rl_complete", NULL);
-
-	/*
-	 * Find out where the rl_complete function was added; this is
-	 * used later to detect that lastcmd was also rl_complete.
-	 */
-	for(i=EL_NUM_FCNS; i < e->el_map.nfunc; i++) {
-		if (e->el_map.func[i] == _el_rl_complete) {
-			el_rl_complete_cmdnum = i;
-			break;
-		}
-	}
-		
-	/* read settings from configuration file */
-	el_source(e, NULL);
-
-	/*
-	 * Unfortunately, some applications really do use rl_point
-	 * and rl_line_buffer directly.
-	 */
-	li = el_line(e);
-	/* a cheesy way to get rid of const cast. */
-	rl_line_buffer = memchr(li->buffer, *li->buffer, 1);
-	rl_point = rl_end = 0;
-
-	return (0);
-}
-
-
-/*
- * read one line from input stream and return it, chomping
- * trailing newline (if there is any)
- */
-char *
-readline(const char *prompt)
-{
-	HistEvent ev;
-	int count;
-	const char *ret;
-	char *buf;
-
-	if (e == NULL || h == NULL)
-		rl_initialize();
-
-	/* update prompt accordingly to what has been passed */
-	if (!prompt)
-		prompt = "";
-	if (strcmp(el_rl_prompt, prompt) != 0) {
-		free(el_rl_prompt);
-		el_rl_prompt = strdup(prompt);
-	}
-	/* get one line from input stream */
-	ret = el_gets(e, &count);
-
-	if (ret && count > 0) {
-		int lastidx;
-
-		buf = strdup(ret);
-		lastidx = count - 1;
-		if (buf[lastidx] == '\n')
-			buf[lastidx] = '\0';
-	} else
-		buf = NULL;
-
-	history(h, &ev, H_GETSIZE);
-	history_length = ev.num;
-
-	return buf;
-}
-
-/*
- * history functions
- */
-
-/*
- * is normally called before application starts to use
- * history expansion functions
- */
-void
-using_history(void)
-{
-	if (h == NULL || e == NULL)
-		rl_initialize();
-}
-
-
-/*
- * substitute ``what'' with ``with'', returning resulting string; if
- * globally == 1, substitutes all occurences of what, otherwise only the
- * first one
- */
-static char *
-_rl_compat_sub(const char *str, const char *what, const char *with,
-    int globally)
-{
-	char *result;
-	const char *temp, *new;
-	int len, with_len, what_len, add;
-	size_t size, i;
-
-	result = malloc((size = 16));
-	temp = str;
-	with_len = strlen(with);
-	what_len = strlen(what);
-	len = 0;
-	do {
-		new = strstr(temp, what);
-		if (new) {
-			i = new - temp;
-			add = i + with_len;
-			if (i + add + 1 >= size) {
-				size += add + 1;
-				result = realloc(result, size);
-			}
-			(void) strncpy(&result[len], temp, i);
-			len += i;
-			(void) strcpy(&result[len], with);	/* safe */
-			len += with_len;
-			temp = new + what_len;
-		} else {
-			add = strlen(temp);
-			if (len + add + 1 >= size) {
-				size += add + 1;
-				result = realloc(result, size);
-			}
-			(void) strcpy(&result[len], temp);	/* safe */
-			len += add;
-			temp = NULL;
-		}
-	} while (temp && globally);
-	result[len] = '\0';
-
-	return (result);
-}
-
-
-/*
- * the real function doing history expansion - takes as argument command
- * to do and data upon which the command should be executed
- * does expansion the way I've understood readline documentation
- * word designator ``%'' isn't supported (yet ?)
- *
- * returns 0 if data was not modified, 1 if it was and 2 if the string
- * should be only printed and not executed; in case of error,
- * returns -1 and *result points to NULL
- * it's callers responsibility to free() string returned in *result
- */
-static int
-_history_expand_command(const char *command, size_t cmdlen, char **result)
-{
-	char **arr, *tempcmd, *line, *search = NULL, *cmd;
-	const char *event_data = NULL;
-	static char *from = NULL, *to = NULL;
-	int start = -1, end = -1, max, i, idx;
-	int h_on = 0, t_on = 0, r_on = 0, e_on = 0, p_on = 0, g_on = 0;
-	int event_num = 0, retval;
-	size_t cmdsize;
-
-	*result = NULL;
-
-	cmd = alloca(cmdlen + 1);
-	(void) strncpy(cmd, command, cmdlen);
-	cmd[cmdlen] = 0;
-
-	idx = 1;
-	/* find out which event to take */
-	if (cmd[idx] == history_expansion_char) {
-		event_num = history_length;
-		idx++;
-	} else {
-		int off, num;
-		size_t len;
-		off = idx;
-		while (cmd[off] && !strchr(":^$*-%", cmd[off]))
-			off++;
-		num = atoi(&cmd[idx]);
-		if (num != 0) {
-			event_num = num;
-			if (num < 0)
-				event_num += history_length + 1;
-		} else {
-			int prefix = 1, curr_num;
-			HistEvent ev;
-
-			len = off - idx;
-			if (cmd[idx] == '?') {
-				idx++, len--;
-				if (cmd[off - 1] == '?')
-					len--;
-				else if (cmd[off] != '\n' && cmd[off] != '\0')
-					return (-1);
-				prefix = 0;
-			}
-			search = alloca(len + 1);
-			(void) strncpy(search, &cmd[idx], len);
-			search[len] = '\0';
-
-			if (history(h, &ev, H_CURR) != 0)
-				return (-1);
-			curr_num = ev.num;
-
-			if (prefix)
-				retval = history_search_prefix(search, -1);
-			else
-				retval = history_search(search, -1);
-
-			if (retval == -1) {
-				fprintf(rl_outstream, "%s: Event not found\n",
-				    search);
-				return (-1);
-			}
-			if (history(h, &ev, H_CURR) != 0)
-				return (-1);
-			event_data = ev.str;
-
-			/* roll back to original position */
-			history(h, &ev, H_NEXT_EVENT, curr_num);
-		}
-		idx = off;
-	}
-
-	if (!event_data && event_num >= 0) {
-		HIST_ENTRY *rl_he;
-		rl_he = history_get(event_num);
-		if (!rl_he)
-			return (0);
-		event_data = rl_he->line;
-	} else
-		return (-1);
-
-	if (cmd[idx] != ':')
-		return (-1);
-	cmd += idx + 1;
-
-	/* recognize cmd */
-	if (*cmd == '^')
-		start = end = 1, cmd++;
-	else if (*cmd == '$')
-		start = end = -1, cmd++;
-	else if (*cmd == '*')
-		start = 1, end = -1, cmd++;
-	else if (isdigit((unsigned char) *cmd)) {
-		const char *temp;
-		int shifted = 0;
-
-		start = atoi(cmd);
-		temp = cmd;
-		for (; isdigit((unsigned char) *cmd); cmd++);
-		if (temp != cmd)
-			shifted = 1;
-		if (shifted && *cmd == '-') {
-			if (!isdigit((unsigned char) *(cmd + 1)))
-				end = -2;
-			else {
-				end = atoi(cmd + 1);
-				for (; isdigit((unsigned char) *cmd); cmd++);
-			}
-		} else if (shifted && *cmd == '*')
-			end = -1, cmd++;
-		else if (shifted)
-			end = start;
-	}
-	if (*cmd == ':')
-		cmd++;
-
-	line = strdup(event_data);
-	for (; *cmd; cmd++) {
-		if (*cmd == ':')
-			continue;
-		else if (*cmd == 'h')
-			h_on = 1 | g_on, g_on = 0;
-		else if (*cmd == 't')
-			t_on = 1 | g_on, g_on = 0;
-		else if (*cmd == 'r')
-			r_on = 1 | g_on, g_on = 0;
-		else if (*cmd == 'e')
-			e_on = 1 | g_on, g_on = 0;
-		else if (*cmd == 'p')
-			p_on = 1 | g_on, g_on = 0;
-		else if (*cmd == 'g')
-			g_on = 2;
-		else if (*cmd == 's' || *cmd == '&') {
-			char *what, *with, delim;
-			int len, from_len;
-			size_t size;
-
-			if (*cmd == '&' && (from == NULL || to == NULL))
-				continue;
-			else if (*cmd == 's') {
-				delim = *(++cmd), cmd++;
-				size = 16;
-				what = realloc(from, size);
-				len = 0;
-				for (; *cmd && *cmd != delim; cmd++) {
-					if (*cmd == '\\'
-					    && *(cmd + 1) == delim)
-						cmd++;
-					if (len >= size)
-						what = realloc(what,
-						    (size <<= 1));
-					what[len++] = *cmd;
-				}
-				what[len] = '\0';
-				from = what;
-				if (*what == '\0') {
-					free(what);
-					if (search)
-						from = strdup(search);
-					else {
-						from = NULL;
-						return (-1);
-					}
-				}
-				cmd++;	/* shift after delim */
-				if (!*cmd)
-					continue;
-
-				size = 16;
-				with = realloc(to, size);
-				len = 0;
-				from_len = strlen(from);
-				for (; *cmd && *cmd != delim; cmd++) {
-					if (len + from_len + 1 >= size) {
-						size += from_len + 1;
-						with = realloc(with, size);
-					}
-					if (*cmd == '&') {
-						/* safe */
-						(void) strcpy(&with[len], from);
-						len += from_len;
-						continue;
-					}
-					if (*cmd == '\\'
-					    && (*(cmd + 1) == delim
-						|| *(cmd + 1) == '&'))
-						cmd++;
-					with[len++] = *cmd;
-				}
-				with[len] = '\0';
-				to = with;
-
-				tempcmd = _rl_compat_sub(line, from, to,
-				    (g_on) ? 1 : 0);
-				free(line);
-				line = tempcmd;
-				g_on = 0;
-			}
-		}
-	}
-
-	arr = history_tokenize(line);
-	free(line);		/* no more needed */
-	if (arr && *arr == NULL)
-		free(arr), arr = NULL;
-	if (!arr)
-		return (-1);
-
-	/* find out max valid idx to array of array */
-	max = 0;
-	for (i = 0; arr[i]; i++)
-		max++;
-	max--;
-
-	/* set boundaries to something relevant */
-	if (start < 0)
-		start = 1;
-	if (end < 0)
-		end = max - ((end < -1) ? 1 : 0);
-
-	/* check boundaries ... */
-	if (start > max || end > max || start > end)
-		return (-1);
-
-	for (i = 0; i <= max; i++) {
-		char *temp;
-		if (h_on && (i == 1 || h_on > 1) &&
-		    (temp = strrchr(arr[i], '/')))
-			*(temp + 1) = '\0';
-		if (t_on && (i == 1 || t_on > 1) &&
-		    (temp = strrchr(arr[i], '/')))
-			(void) strcpy(arr[i], temp + 1);
-		if (r_on && (i == 1 || r_on > 1) &&
-		    (temp = strrchr(arr[i], '.')))
-			*temp = '\0';
-		if (e_on && (i == 1 || e_on > 1) &&
-		    (temp = strrchr(arr[i], '.')))
-			(void) strcpy(arr[i], temp);
-	}
-
-	cmdsize = 1, cmdlen = 0;
-	tempcmd = malloc(cmdsize);
-	for (i = start; start <= i && i <= end; i++) {
-		int arr_len;
-
-		arr_len = strlen(arr[i]);
-		if (cmdlen + arr_len + 1 >= cmdsize) {
-			cmdsize += arr_len + 1;
-			tempcmd = realloc(tempcmd, cmdsize);
-		}
-		(void) strcpy(&tempcmd[cmdlen], arr[i]);	/* safe */
-		cmdlen += arr_len;
-		tempcmd[cmdlen++] = ' ';	/* add a space */
-	}
-	while (cmdlen > 0 && isspace((unsigned char) tempcmd[cmdlen - 1]))
-		cmdlen--;
-	tempcmd[cmdlen] = '\0';
-
-	*result = tempcmd;
-
-	for (i = 0; i <= max; i++)
-		free(arr[i]);
-	free(arr), arr = (char **) NULL;
-	return (p_on) ? 2 : 1;
-}
-
-
-/*
- * csh-style history expansion
- */
-int
-history_expand(char *str, char **output)
-{
-	int i, retval = 0, idx;
-	size_t size;
-	char *temp, *result;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	*output = strdup(str);	/* do it early */
-
-	if (str[0] == history_subst_char) {
-		/* ^foo^foo2^ is equivalent to !!:s^foo^foo2^ */
-		temp = alloca(4 + strlen(str) + 1);
-		temp[0] = temp[1] = history_expansion_char;
-		temp[2] = ':';
-		temp[3] = 's';
-		(void) strcpy(temp + 4, str);
-		str = temp;
-	}
-#define	ADD_STRING(what, len) 						\
-	{								\
-		if (idx + len + 1 > size)				\
-			result = realloc(result, (size += len + 1));	\
-		(void)strncpy(&result[idx], what, len);			\
-		idx += len;						\
-		result[idx] = '\0';					\
-	}
-
-	result = NULL;
-	size = idx = 0;
-	for (i = 0; str[i];) {
-		int start, j, loop_again;
-		size_t len;
-
-		loop_again = 1;
-		start = j = i;
-loop:
-		for (; str[j]; j++) {
-			if (str[j] == '\\' &&
-			    str[j + 1] == history_expansion_char) {
-				(void) strcpy(&str[j], &str[j + 1]);
-				continue;
-			}
-			if (!loop_again) {
-				if (str[j] == '?') {
-					while (str[j] && str[++j] != '?');
-					if (str[j] == '?')
-						j++;
-				} else if (isspace((unsigned char) str[j]))
-					break;
-			}
-			if (str[j] == history_expansion_char
-			    && !strchr(history_no_expand_chars, str[j + 1])
-			    && (!history_inhibit_expansion_function ||
-			    (*history_inhibit_expansion_function)(str, j) == 0))
-				break;
-		}
-
-		if (str[j] && str[j + 1] != '#' && loop_again) {
-			i = j;
-			j++;
-			if (str[j] == history_expansion_char)
-				j++;
-			loop_again = 0;
-			goto loop;
-		}
-		len = i - start;
-		temp = &str[start];
-		ADD_STRING(temp, len);
-
-		if (str[i] == '\0' || str[i] != history_expansion_char
-		    || str[i + 1] == '#') {
-			len = j - i;
-			temp = &str[i];
-			ADD_STRING(temp, len);
-			if (start == 0)
-				retval = 0;
-			else
-				retval = 1;
-			break;
-		}
-		retval = _history_expand_command(&str[i], (size_t) (j - i),
-		    &temp);
-		if (retval != -1) {
-			len = strlen(temp);
-			ADD_STRING(temp, len);
-		}
-		i = j;
-	}			/* for(i ...) */
-
-	if (retval == 2) {
-		add_history(temp);
-#ifdef GDB_411_HACK
-		/* gdb 4.11 has been shipped with readline, where */
-		/* history_expand() returned -1 when the line	  */
-		/* should not be executed; in readline 2.1+	  */
-		/* it should return 2 in such a case		  */
-		retval = -1;
-#endif
-	}
-	free(*output);
-	*output = result;
-
-	return (retval);
-}
-
-
-/*
- * Parse the string into individual tokens, similarily to how shell would do it.
- */
-char **
-history_tokenize(const char *str)
-{
-	int size = 1, result_idx = 0, i, start;
-	size_t len;
-	char **result = NULL, *temp, delim = '\0';
-
-	for (i = 0; str[i]; i++) {
-		while (isspace((unsigned char) str[i]))
-			i++;
-		start = i;
-		for (; str[i]; i++) {
-			if (str[i] == '\\') {
-				if (str[i+1] != '\0')
-					i++;
-			} else if (str[i] == delim)
-				delim = '\0';
-			else if (!delim &&
-				    (isspace((unsigned char) str[i]) ||
-				strchr("()<>;&|$", str[i])))
-				break;
-			else if (!delim && strchr("'`\"", str[i]))
-				delim = str[i];
-		}
-
-		if (result_idx + 2 >= size) {
-			size <<= 1;
-			result = realloc(result, size * sizeof(char *));
-		}
-		len = i - start;
-		temp = malloc(len + 1);
-		(void) strncpy(temp, &str[start], len);
-		temp[len] = '\0';
-		result[result_idx++] = temp;
-		result[result_idx] = NULL;
-	}
-
-	return (result);
-}
-
-
-/*
- * limit size of history record to ``max'' events
- */
-void
-stifle_history(int max)
-{
-	HistEvent ev;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	if (history(h, &ev, H_SETSIZE, max) == 0)
-		max_input_history = max;
-}
-
-
-/*
- * "unlimit" size of history - set the limit to maximum allowed int value
- */
-int
-unstifle_history(void)
-{
-	HistEvent ev;
-	int omax;
-
-	history(h, &ev, H_SETSIZE, INT_MAX);
-	omax = max_input_history;
-	max_input_history = INT_MAX;
-	return (omax);		/* some value _must_ be returned */
-}
-
-
-int
-history_is_stifled(void)
-{
-
-	/* cannot return true answer */
-	return (max_input_history != INT_MAX);
-}
-
-
-/*
- * read history from a file given
- */
-int
-read_history(const char *filename)
-{
-	HistEvent ev;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-	return (history(h, &ev, H_LOAD, filename));
-}
-
-
-/*
- * write history to a file given
- */
-int
-write_history(const char *filename)
-{
-	HistEvent ev;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-	return (history(h, &ev, H_SAVE, filename));
-}
-
-
-/*
- * returns history ``num''th event
- *
- * returned pointer points to static variable
- */
-HIST_ENTRY *
-history_get(int num)
-{
-	static HIST_ENTRY she;
-	HistEvent ev;
-	int i = 1, curr_num;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	/* rewind to beginning */
-	if (history(h, &ev, H_CURR) != 0)
-		return (NULL);
-	curr_num = ev.num;
-	if (history(h, &ev, H_LAST) != 0)
-		return (NULL);	/* error */
-	while (i < num && history(h, &ev, H_PREV) == 0)
-		i++;
-	if (i != num)
-		return (NULL);	/* not so many entries */
-
-	she.line = ev.str;
-	she.data = NULL;
-
-	/* rewind history to the same event it was before */
-	(void) history(h, &ev, H_FIRST);
-	(void) history(h, &ev, H_NEXT_EVENT, curr_num);
-
-	return (&she);
-}
-
-
-/*
- * add the line to history table
- */
-int
-add_history(const char *line)
-{
-	HistEvent ev;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	(void) history(h, &ev, H_ENTER, line);
-	if (history(h, &ev, H_GETSIZE) == 0)
-		history_length = ev.num;
-
-	return (!(history_length > 0));	/* return 0 if all is okay */
-}
-
-
-/*
- * clear the history list - delete all entries
- */
-void
-clear_history(void)
-{
-	HistEvent ev;
-
-	history(h, &ev, H_CLEAR);
-}
-
-
-/*
- * returns offset of the current history event
- */
-int
-where_history(void)
-{
-	HistEvent ev;
-	int curr_num, off;
-
-	if (history(h, &ev, H_CURR) != 0)
-		return (0);
-	curr_num = ev.num;
-
-	history(h, &ev, H_FIRST);
-	off = 1;
-	while (ev.num != curr_num && history(h, &ev, H_NEXT) == 0)
-		off++;
-
-	return (off);
-}
-
-
-/*
- * returns current history event or NULL if there is no such event
- */
-HIST_ENTRY *
-current_history(void)
-{
-
-	return (_move_history(H_CURR));
-}
-
-
-/*
- * returns total number of bytes history events' data are using
- */
-int
-history_total_bytes(void)
-{
-	HistEvent ev;
-	int curr_num, size;
-
-	if (history(h, &ev, H_CURR) != 0)
-		return (-1);
-	curr_num = ev.num;
-
-	history(h, &ev, H_FIRST);
-	size = 0;
-	do
-		size += strlen(ev.str);
-	while (history(h, &ev, H_NEXT) == 0);
-
-	/* get to the same position as before */
-	history(h, &ev, H_PREV_EVENT, curr_num);
-
-	return (size);
-}
-
-
-/*
- * sets the position in the history list to ``pos''
- */
-int
-history_set_pos(int pos)
-{
-	HistEvent ev;
-	int off, curr_num;
-
-	if (pos > history_length || pos < 0)
-		return (-1);
-
-	history(h, &ev, H_CURR);
-	curr_num = ev.num;
-	history(h, &ev, H_FIRST);
-	off = 0;
-	while (off < pos && history(h, &ev, H_NEXT) == 0)
-		off++;
-
-	if (off != pos) {	/* do a rollback in case of error */
-		history(h, &ev, H_FIRST);
-		history(h, &ev, H_NEXT_EVENT, curr_num);
-		return (-1);
-	}
-	return (0);
-}
-
-
-/*
- * returns previous event in history and shifts pointer accordingly
- */
-HIST_ENTRY *
-previous_history(void)
-{
-
-	return (_move_history(H_PREV));
-}
-
-
-/*
- * returns next event in history and shifts pointer accordingly
- */
-HIST_ENTRY *
-next_history(void)
-{
-
-	return (_move_history(H_NEXT));
-}
-
-
-/*
- * generic history search function
- */
-static int
-_history_search_gen(const char *str, int direction, int pos)
-{
-	HistEvent ev;
-	const char *strp;
-	int curr_num;
-
-	if (history(h, &ev, H_CURR) != 0)
-		return (-1);
-	curr_num = ev.num;
-
-	for (;;) {
-		strp = strstr(ev.str, str);
-		if (strp && (pos < 0 || &ev.str[pos] == strp))
-			return (int) (strp - ev.str);
-		if (history(h, &ev, direction < 0 ? H_PREV : H_NEXT) != 0)
-			break;
-	}
-
-	history(h, &ev, direction < 0 ? H_NEXT_EVENT : H_PREV_EVENT, curr_num);
-
-	return (-1);
-}
-
-
-/*
- * searches for first history event containing the str
- */
-int
-history_search(const char *str, int direction)
-{
-
-	return (_history_search_gen(str, direction, -1));
-}
-
-
-/*
- * searches for first history event beginning with str
- */
-int
-history_search_prefix(const char *str, int direction)
-{
-
-	return (_history_search_gen(str, direction, 0));
-}
-
-
-/*
- * search for event in history containing str, starting at offset
- * abs(pos); continue backward, if pos<0, forward otherwise
- */
-/* ARGSUSED */
-int
-history_search_pos(const char *str, int direction, int pos)
-{
-	HistEvent ev;
-	int curr_num, off;
-
-	off = (pos > 0) ? pos : -pos;
-	pos = (pos > 0) ? 1 : -1;
-
-	if (history(h, &ev, H_CURR) != 0)
-		return (-1);
-	curr_num = ev.num;
-
-	if (history_set_pos(off) != 0 || history(h, &ev, H_CURR) != 0)
-		return (-1);
-
-
-	for (;;) {
-		if (strstr(ev.str, str))
-			return (off);
-		if (history(h, &ev, (pos < 0) ? H_PREV : H_NEXT) != 0)
-			break;
-	}
-
-	/* set "current" pointer back to previous state */
-	history(h, &ev, (pos < 0) ? H_NEXT_EVENT : H_PREV_EVENT, curr_num);
-
-	return (-1);
-}
-
-
-/********************************/
-/* completition functions	*/
-
-/*
- * does tilde expansion of strings of type ``~user/foo''
- * if ``user'' isn't valid user name or ``txt'' doesn't start
- * w/ '~', returns pointer to strdup()ed copy of ``txt''
- *
- * it's callers's responsibility to free() returned string
- */
-char *
-tilde_expand(char *txt)
-{
-	struct passwd *pass;
-	char *temp;
-	size_t len = 0;
-
-	if (txt[0] != '~')
-		return (strdup(txt));
-
-	temp = strchr(txt + 1, '/');
-	if (temp == NULL)
-		temp = strdup(txt + 1);
-	else {
-		len = temp - txt + 1;	/* text until string after slash */
-		temp = malloc(len);
-		(void) strncpy(temp, txt + 1, len - 2);
-		temp[len - 2] = '\0';
-	}
-	pass = getpwnam(temp);
-	free(temp);		/* value no more needed */
-	if (pass == NULL)
-		return (strdup(txt));
-
-	/* update pointer txt to point at string immedially following */
-	/* first slash */
-	txt += len;
-
-	temp = malloc(strlen(pass->pw_dir) + 1 + strlen(txt) + 1);
-	(void) sprintf(temp, "%s/%s", pass->pw_dir, txt);
-
-	return (temp);
-}
-
-
-/*
- * return first found file name starting by the ``text'' or NULL if no
- * such file can be found.
- * The first ``state'' matches are ignored.
- *
- * it's caller's responsibility to free returned string
- */
-char *
-filename_completion_function(const char *text, int state)
-{
-	DIR *dir = NULL;
-	char *filename = NULL, *dirname = NULL;
-	size_t filename_len = 0;
-	struct dirent *entry;
-	char *temp;
-	size_t len;
-
-	temp = strrchr(text, '/');
-	if (temp) {
-		temp++;
-		filename = realloc(filename, strlen(temp) + 1);
-		(void) strcpy(filename, temp);
-		len = temp - text;	/* including last slash */
-		dirname = realloc(dirname, len + 1);
-		(void) strncpy(dirname, text, len);
-		dirname[len] = '\0';
-	} else {
-		filename = strdup(text);
-		dirname = NULL;
-	}
-
-	/* support for ``~user'' syntax */
-	if (dirname && *dirname == '~') {
-		temp = tilde_expand(dirname);
-		dirname = realloc(dirname, strlen(temp) + 1);
-		(void) strcpy(dirname, temp);	/* safe */
-		free(temp);	/* no longer needed */
-	}
-	/* will be used in cycle */
-	filename_len = strlen(filename);
-
-	dir = opendir(dirname ? dirname : ".");
-	if (!dir)
-		return (NULL);	/* cannot open the directory */
-
-	/* find the match */
-	while ((entry = readdir(dir)) != NULL) {
-		/* otherwise, get first entry where first */
-		/* filename_len characters are equal	  */
-		if (
-#if defined(__SVR4) || defined(__linux__)
-		    strlen(entry->d_name) >= filename_len
-#else
-		    entry->d_namlen >= filename_len
-#endif
-		    && strncmp(entry->d_name, filename,
-			filename_len) == 0
-			&& (state-- == 0))
-			break;
-	}
-
-	if (entry) {		/* match found */
-
-		struct stat stbuf;
-#if defined(__SVR4) || defined(__linux__)
-		len = strlen(entry->d_name) +
-#else
-		len = entry->d_namlen +
-#endif
-		    ((dirname) ? strlen(dirname) : 0) + 1 + 1;
-		temp = malloc(len);
-		(void) sprintf(temp, "%s%s",
-		    dirname ? dirname : "", entry->d_name);	/* safe */
-
-		/* test, if it's directory */
-		if (stat(temp, &stbuf) == 0 && S_ISDIR(stbuf.st_mode))
-			strcat(temp, "/");	/* safe */
-	} else
-		temp = NULL;
-	closedir(dir);
-
-	return (temp);
-}
-
-
-/*
- * a completion generator for usernames; returns _first_ username
- * which starts with supplied text
- * text contains a partial username preceded by random character
- * (usually '~'); state is ignored
- * it's callers responsibility to free returned value
- */
-char *
-username_completion_function(const char *text, int state)
-{
-	struct passwd *pwd;
-
-	if (text[0] == '\0')
-		return (NULL);
-
-	if (*text == '~')
-		text++;
-
-	if (state == 0)
-		setpwent();
-
-	while ((pwd = getpwent()) && text[0] == pwd->pw_name[0]
-	    && strcmp(text, pwd->pw_name) == 0);
-
-	if (pwd == NULL) {
-		endpwent();
-		return (NULL);
-	}
-	return (strdup(pwd->pw_name));
-}
-
-
-/*
- * el-compatible wrapper around rl_complete; needed for key binding
- */
-/* ARGSUSED */
-static unsigned char
-_el_rl_complete(EditLine *el, int ch)
-{
-	return (unsigned char) rl_complete(0, ch);
-}
-
-
-/*
- * returns list of completitions for text given
- */
-char **
-completion_matches(const char *text, CPFunction *genfunc)
-{
-	char **match_list = NULL, *retstr, *prevstr;
-	size_t match_list_len, max_equal, which, i;
-	int matches;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	matches = 0;
-	match_list_len = 1;
-	while ((retstr = (*genfunc) (text, matches)) != NULL) {
-		if (matches + 1 >= match_list_len) {
-			match_list_len <<= 1;
-			match_list = realloc(match_list,
-			    match_list_len * sizeof(char *));
-		}
-		match_list[++matches] = retstr;
-	}
-
-	if (!match_list)
-		return (char **) NULL;	/* nothing found */
-
-	/* find least denominator and insert it to match_list[0] */
-	which = 2;
-	prevstr = match_list[1];
-	max_equal = strlen(prevstr);
-	for (; which <= matches; which++) {
-		for (i = 0; i < max_equal &&
-		    prevstr[i] == match_list[which][i]; i++)
-			continue;
-		max_equal = i;
-	}
-
-	retstr = malloc(max_equal + 1);
-	(void) strncpy(retstr, match_list[1], max_equal);
-	retstr[max_equal] = '\0';
-	match_list[0] = retstr;
-
-	/* add NULL as last pointer to the array */
-	if (matches + 1 >= match_list_len)
-		match_list = realloc(match_list,
-		    (match_list_len + 1) * sizeof(char *));
-	match_list[matches + 1] = (char *) NULL;
-
-	return (match_list);
-}
-
-/*
- * Sort function for qsort(). Just wrapper around strcasecmp().
- */
-static int
-_rl_qsort_string_compare(i1, i2)
-	const void *i1, *i2;
-{
-	/* LINTED const castaway */
-	const char *s1 = ((const char **)i1)[0];
-	/* LINTED const castaway */
-	const char *s2 = ((const char **)i2)[0];
-
-	return strcasecmp(s1, s2);
-}
-
-/*
- * Display list of strings in columnar format on readline's output stream.
- * 'matches' is list of strings, 'len' is number of strings in 'matches',
- * 'max' is maximum length of string in 'matches'.
- */
-void
-rl_display_match_list (matches, len, max)
-     char **matches;
-     int len, max;
-{
-	int i, idx, limit, count;
-	int screenwidth = e->el_term.t_size.h;
-
-	/*
-	 * Find out how many entries can be put on one line, count
-	 * with two spaces between strings.
-	 */
-	limit = screenwidth / (max + 2);
-	if (limit == 0)
-		limit = 1;
-
-	/* how many lines of output */
-	count = len / limit;
-	if (count * limit < len)
-		count++;
-
-	/* Sort the items if they are not already sorted. */
-	qsort(&matches[1], (size_t)(len - 1), sizeof(char *),
-	    _rl_qsort_string_compare);
-
-	idx = 1;
-	for(; count > 0; count--) {
-		for(i=0; i < limit && matches[idx]; i++, idx++)
-			fprintf(e->el_outfile, "%-*s  ", max, matches[idx]);
-		fprintf(e->el_outfile, "\n");
-	}
-}
-
-/*
- * Complete the word at or before point, called by rl_complete()
- * 'what_to_do' says what to do with the completion.
- * `?' means list the possible completions.
- * TAB means do standard completion.
- * `*' means insert all of the possible completions.
- * `!' means to do standard completion, and list all possible completions if
- * there is more than one.
- *
- * Note: '*' support is not implemented
- */
-static int
-rl_complete_internal(int what_to_do)
-{
-	CPFunction *complet_func;
-	const LineInfo *li;
-	char *temp, **matches;
-	const char *ctemp;
-	size_t len;
-
-	rl_completion_type = what_to_do;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	complet_func = rl_completion_entry_function;
-	if (!complet_func)
-		complet_func = filename_completion_function;
-
-	/* We now look backwards for the start of a filename/variable word */
-	li = el_line(e);
-	ctemp = (const char *) li->cursor;
-	while (ctemp > li->buffer
-	    && !strchr(rl_basic_word_break_characters, ctemp[-1])
-	    && (!rl_special_prefixes
-			|| !strchr(rl_special_prefixes, ctemp[-1]) ) )
-		ctemp--;
-
-	len = li->cursor - ctemp;
-	temp = alloca(len + 1);
-	(void) strncpy(temp, ctemp, len);
-	temp[len] = '\0';
-
-	/* these can be used by function called in completion_matches() */
-	/* or (*rl_attempted_completion_function)() */
-	rl_point = li->cursor - li->buffer;
-	rl_end = li->lastchar - li->buffer;
-
-	if (!rl_attempted_completion_function)
-		matches = completion_matches(temp, complet_func);
-	else {
-		int end = li->cursor - li->buffer;
-		matches = (*rl_attempted_completion_function) (temp, (int)
-		    (end - len), end);
-	}
-
-	if (matches) {
-		int i, retval = CC_REFRESH;
-		int matches_num, maxlen, match_len, match_display=1;
-
-		/*
-		 * Only replace the completed string with common part of
-		 * possible matches if there is possible completion.
-		 */
-		if (matches[0][0] != '\0') {
-			el_deletestr(e, (int) len);
-			el_insertstr(e, matches[0]);
-		}
-
-		if (what_to_do == '?')
-			goto display_matches;
-
-		if (matches[2] == NULL && strcmp(matches[0], matches[1]) == 0) {
-			/*
-			 * We found exact match. Add a space after
-			 * it, unless we do filename completition and the
-			 * object is a directory.
-			 */
-			size_t alen = strlen(matches[0]);
-			if ((complet_func != filename_completion_function
-			      || (alen > 0 && (matches[0])[alen - 1] != '/'))
-			    && rl_completion_append_character) {
-				char buf[2];
-				buf[0] = rl_completion_append_character;
-				buf[1] = '\0';
-				el_insertstr(e, buf);
-			}
-		} else if (what_to_do == '!') {
-    display_matches:
-			/*
-			 * More than one match and requested to list possible
-			 * matches.
-			 */
-
-			for(i=1, maxlen=0; matches[i]; i++) {
-				match_len = strlen(matches[i]);
-				if (match_len > maxlen)
-					maxlen = match_len;
-			}
-			matches_num = i - 1;
-				
-			/* newline to get on next line from command line */
-			fprintf(e->el_outfile, "\n");
-
-			/*
-			 * If there are too many items, ask user for display
-			 * confirmation.
-			 */
-			if (matches_num > rl_completion_query_items) {
-				fprintf(e->el_outfile,
-				"Display all %d possibilities? (y or n) ",
-					matches_num);
-				fflush(e->el_outfile);
-				if (getc(stdin) != 'y')
-					match_display = 0;
-				fprintf(e->el_outfile, "\n");
-			}
-
-			if (match_display)
-				rl_display_match_list(matches, matches_num,
-					maxlen);
-			retval = CC_REDISPLAY;
-		} else if (matches[0][0]) {
-			/*
-			 * There was some common match, but the name was
-			 * not complete enough. Next tab will print possible
-			 * completions.
-			 */
-			el_beep(e);
-		} else {
-			/* lcd is not a valid object - further specification */
-			/* is needed */
-			el_beep(e);
-			retval = CC_NORM;
-		}
-
-		/* free elements of array and the array itself */
-		for (i = 0; matches[i]; i++)
-			free(matches[i]);
-		free(matches), matches = NULL;
-
-		return (retval);
-	}
-	return (CC_NORM);
-}
-
-
-/*
- * complete word at current point
- */
-int
-rl_complete(int ignore, int invoking_key)
-{
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	if (rl_inhibit_completion) {
-		rl_insert(ignore, invoking_key);
-		return (CC_REFRESH);
-	} else if (e->el_state.lastcmd == el_rl_complete_cmdnum)
-		return rl_complete_internal('?');
-	else if (_rl_complete_show_all)
-		return rl_complete_internal('!');
-	else
-		return (rl_complete_internal(TAB));
-}
-
-
-/*
- * misc other functions
- */
-
-/*
- * bind key c to readline-type function func
- */
-int
-rl_bind_key(int c, int func(int, int))
-{
-	int retval = -1;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	if (func == rl_insert) {
-		/* XXX notice there is no range checking of ``c'' */
-		e->el_map.key[c] = ED_INSERT;
-		retval = 0;
-	}
-	return (retval);
-}
-
-
-/*
- * read one key from input - handles chars pushed back
- * to input stream also
- */
-int
-rl_read_key(void)
-{
-	char fooarr[2 * sizeof(int)];
-
-	if (e == NULL || h == NULL)
-		rl_initialize();
-
-	return (el_getc(e, fooarr));
-}
-
-
-/*
- * reset the terminal
- */
-/* ARGSUSED */
-void
-rl_reset_terminal(const char *p)
-{
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-	el_reset(e);
-}
-
-
-/*
- * insert character ``c'' back into input stream, ``count'' times
- */
-int
-rl_insert(int count, int c)
-{
-	char arr[2];
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	/* XXX - int -> char conversion can lose on multichars */
-	arr[0] = c;
-	arr[1] = '\0';
-
-	for (; count > 0; count--)
-		el_push(e, arr);
-
-	return (0);
-}
diff --git a/main/editline/readline/readline.h b/main/editline/readline/readline.h
deleted file mode 100644
index 7485dde..0000000
--- a/main/editline/readline/readline.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/*	$NetBSD: readline.h,v 1.1 2001/01/05 21:15:50 jdolecek Exp $	*/
-
-/*-
- * Copyright (c) 1997 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Jaromir Dolecek.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the NetBSD
- *	Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _READLINE_H_
-#define	_READLINE_H_
-
-#include <sys/types.h>
-
-/* list of readline stuff supported by editline library's readline wrapper */
-
-/* typedefs */
-typedef int	  Function(const char *, int);
-typedef void	  VFunction(void);
-typedef char	 *CPFunction(const char *, int);
-typedef char	**CPPFunction(const char *, int, int);
-
-typedef struct _hist_entry {
-	const char	*line;
-	const char	*data;
-} HIST_ENTRY;
-
-/* global variables used by readline enabled applications */
-#ifdef __cplusplus
-extern "C" {
-#endif
-extern const char	*rl_library_version;
-extern char		*rl_readline_name;
-extern FILE		*rl_instream;
-extern FILE		*rl_outstream;
-extern char		*rl_line_buffer;
-extern int		 rl_point, rl_end;
-extern int		 history_base, history_length;
-extern int		 max_input_history;
-extern char		*rl_basic_word_break_characters;
-extern char		*rl_completer_word_break_characters;
-extern char		*rl_completer_quote_characters;
-extern CPFunction	*rl_completion_entry_function;
-extern CPPFunction	*rl_attempted_completion_function;
-extern int		rl_completion_type;
-extern int		rl_completion_query_items;
-extern char		*rl_special_prefixes;
-extern int		rl_completion_append_character;
-
-/* supported functions */
-char		*readline(const char *);
-int		 rl_initialize(void);
-
-void		 using_history(void);
-int		 add_history(const char *);
-void		 clear_history(void);
-void		 stifle_history(int);
-int		 unstifle_history(void);
-int		 history_is_stifled(void);
-int		 where_history(void);
-HIST_ENTRY	*current_history(void);
-HIST_ENTRY	*history_get(int);
-int		 history_total_bytes(void);
-int		 history_set_pos(int);
-HIST_ENTRY	*previous_history(void);
-HIST_ENTRY	*next_history(void);
-int		 history_search(const char *, int);
-int		 history_search_prefix(const char *, int);
-int		 history_search_pos(const char *, int, int);
-int		 read_history(const char *);
-int		 write_history(const char *);
-int		 history_expand(char *, char **);
-char	       **history_tokenize(const char *);
-
-char		*tilde_expand(char *);
-char		*filename_completion_function(const char *, int);
-char		*username_completion_function(const char *, int);
-int		 rl_complete(int, int);
-int		 rl_read_key(void);
-char	       **completion_matches(const char *, CPFunction *);
-void		 rl_display_match_list(char **, int, int);
-
-int		 rl_insert(int, int);
-void		 rl_reset_terminal(const char *);
-int		 rl_bind_key(int, int (*)(int, int));
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _READLINE_H_ */
diff --git a/main/editline/refresh.c b/main/editline/refresh.c
deleted file mode 100644
index fcebe12..0000000
--- a/main/editline/refresh.c
+++ /dev/null
@@ -1,1104 +0,0 @@
-/*	$NetBSD: refresh.c,v 1.18 2002/03/18 16:00:58 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)refresh.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: refresh.c,v 1.18 2002/03/18 16:00:58 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * refresh.c: Lower level screen refreshing functions
- */
-#include <stdio.h>
-#include <ctype.h>
-#include <unistd.h>
-#include <string.h>
-
-#include "el.h"
-
-private void	re_addc(EditLine *, int);
-private void	re_update_line(EditLine *, char *, char *, int);
-private void	re_insert (EditLine *, char *, int, int, char *, int);
-private void	re_delete(EditLine *, char *, int, int, int);
-private void	re_fastputc(EditLine *, int);
-private void	re__strncopy(char *, char *, size_t);
-private void	re__copy_and_pad(char *, const char *, size_t);
-
-#ifdef DEBUG_REFRESH
-private void	re_printstr(EditLine *, char *, char *, char *);
-#define	__F el->el_errfile
-#define	ELRE_ASSERT(a, b, c)	do 				\
-				    if (a) {			\
-					(void) fprintf b;	\
-					c;			\
-				    }				\
-				while (0)
-#define	ELRE_DEBUG(a, b)	ELRE_ASSERT(a,b,;)
-
-/* re_printstr():
- *	Print a string on the debugging pty
- */
-private void
-re_printstr(EditLine *el, char *str, char *f, char *t)
-{
-
-	ELRE_DEBUG(1, (__F, "%s:\"", str));
-	while (f < t)
-		ELRE_DEBUG(1, (__F, "%c", *f++ & 0177));
-	ELRE_DEBUG(1, (__F, "\"\r\n"));
-}
-#else
-#define	ELRE_ASSERT(a, b, c)
-#define	ELRE_DEBUG(a, b)
-#endif
-
-
-/* re_addc():
- *	Draw c, expanding tabs, control chars etc.
- */
-private void
-re_addc(EditLine *el, int c)
-{
-
-	if (isprint(c)) {
-		re_putc(el, c, 1);
-		return;
-	}
-	if (c == '\n') {				/* expand the newline */
-		int oldv = el->el_refresh.r_cursor.v;
-		re_putc(el, '\0', 0);			/* assure end of line */
-		if (oldv == el->el_refresh.r_cursor.v) { /* XXX */
-			el->el_refresh.r_cursor.h = 0;	/* reset cursor pos */
-			el->el_refresh.r_cursor.v++;
-		}
-		return;
-	}
-	if (c == '\t') {				/* expand the tab */
-		for (;;) {
-			re_putc(el, ' ', 1);
-			if ((el->el_refresh.r_cursor.h & 07) == 0)
-				break;			/* go until tab stop */
-		}
-	} else if (iscntrl(c)) {
-		re_putc(el, '^', 1);
-		if (c == '\177')
-			re_putc(el, '?', 1);
-		else
-		    /* uncontrolify it; works only for iso8859-1 like sets */
-			re_putc(el, (c | 0100), 1);
-	} else {
-		re_putc(el, '\\', 1);
-		re_putc(el, (int) ((((unsigned int) c >> 6) & 07) + '0'), 1);
-		re_putc(el, (int) ((((unsigned int) c >> 3) & 07) + '0'), 1);
-		re_putc(el, (c & 07) + '0', 1);
-	}
-}
-
-
-/* re_putc():
- *	Draw the character given
- */
-protected void
-re_putc(EditLine *el, int c, int shift)
-{
-
-	ELRE_DEBUG(1, (__F, "printing %3.3o '%c'\r\n", c, c));
-
-	el->el_vdisplay[el->el_refresh.r_cursor.v][el->el_refresh.r_cursor.h] = c;
-	if (!shift)
-		return;
-
-	el->el_refresh.r_cursor.h++;	/* advance to next place */
-	if (el->el_refresh.r_cursor.h >= el->el_term.t_size.h) {
-		el->el_vdisplay[el->el_refresh.r_cursor.v][el->el_term.t_size.h] = '\0';
-		/* assure end of line */
-		el->el_refresh.r_cursor.h = 0;	/* reset it. */
-
-		/*
-		 * If we would overflow (input is longer than terminal size),
-		 * emulate scroll by dropping first line and shuffling the rest.
-		 * We do this via pointer shuffling - it's safe in this case
-		 * and we avoid memcpy().
-		 */
-		if (el->el_refresh.r_cursor.v + 1 >= el->el_term.t_size.v) {
-			int i, lins = el->el_term.t_size.v;
-			char *firstline = el->el_vdisplay[0];
-
-			for(i=1; i < lins; i++)
-				el->el_vdisplay[i-1] = el->el_vdisplay[i];
-
-			firstline[0] = '\0';		/* empty the string */	
-			el->el_vdisplay[i-1] = firstline;
-		} else
-			el->el_refresh.r_cursor.v++;
-
-		ELRE_ASSERT(el->el_refresh.r_cursor.v >= el->el_term.t_size.v,
-		    (__F, "\r\nre_putc: overflow! r_cursor.v == %d > %d\r\n",
-		    el->el_refresh.r_cursor.v, el->el_term.t_size.v),
-		    abort());
-	}
-}
-
-
-/* re_refresh():
- *	draws the new virtual screen image from the current input
- *  	line, then goes line-by-line changing the real image to the new
- *	virtual image. The routine to re-draw a line can be replaced
- *	easily in hopes of a smarter one being placed there.
- */
-protected void
-re_refresh(EditLine *el)
-{
-	int i, rhdiff;
-	char *cp, *st;
-	coord_t cur;
-#ifdef notyet
-	size_t termsz;
-#endif
-
-	ELRE_DEBUG(1, (__F, "el->el_line.buffer = :%s:\r\n",
-	    el->el_line.buffer));
-
-	/* reset the Drawing cursor */
-	el->el_refresh.r_cursor.h = 0;
-	el->el_refresh.r_cursor.v = 0;
-
-	/* temporarily draw rprompt to calculate its size */
-	prompt_print(el, EL_RPROMPT);
-
-	/* reset the Drawing cursor */
-	el->el_refresh.r_cursor.h = 0;
-	el->el_refresh.r_cursor.v = 0;
-
-	cur.h = -1;		/* set flag in case I'm not set */
-	cur.v = 0;
-
-	prompt_print(el, EL_PROMPT);
-
-	/* draw the current input buffer */
-#ifdef notyet
-	termsz = el->el_term.t_size.h * el->el_term.t_size.v;
-	if (el->el_line.lastchar - el->el_line.buffer > termsz) {
-		/*
-		 * If line is longer than terminal, process only part
-		 * of line which would influence display.
-		 */
-		size_t rem = (el->el_line.lastchar-el->el_line.buffer)%termsz;
-
-		st = el->el_line.lastchar - rem
-			- (termsz - (((rem / el->el_term.t_size.v) - 1)
-					* el->el_term.t_size.v));
-	} else
-#endif
-		st = el->el_line.buffer;
-
-	for (cp = st; cp < el->el_line.lastchar; cp++) {
-		if (cp == el->el_line.cursor) {
-			/* save for later */
-			cur.h = el->el_refresh.r_cursor.h;
-			cur.v = el->el_refresh.r_cursor.v;
-		}
-		re_addc(el, (unsigned char) *cp);
-	}
-
-	if (cur.h == -1) {	/* if I haven't been set yet, I'm at the end */
-		cur.h = el->el_refresh.r_cursor.h;
-		cur.v = el->el_refresh.r_cursor.v;
-	}
-	rhdiff = el->el_term.t_size.h - el->el_refresh.r_cursor.h -
-	    el->el_rprompt.p_pos.h;
-	if (el->el_rprompt.p_pos.h && !el->el_rprompt.p_pos.v &&
-	    !el->el_refresh.r_cursor.v && rhdiff > 1) {
-		/*
-		 * have a right-hand side prompt that will fit
-		 * on the end of the first line with at least
-		 * one character gap to the input buffer.
-		 */
-		while (--rhdiff > 0)	/* pad out with spaces */
-			re_putc(el, ' ', 1);
-		prompt_print(el, EL_RPROMPT);
-	} else {
-		el->el_rprompt.p_pos.h = 0;	/* flag "not using rprompt" */
-		el->el_rprompt.p_pos.v = 0;
-	}
-
-	re_putc(el, '\0', 0);	/* make line ended with NUL, no cursor shift */
-
-	el->el_refresh.r_newcv = el->el_refresh.r_cursor.v;
-
-	ELRE_DEBUG(1, (__F,
-		"term.h=%d vcur.h=%d vcur.v=%d vdisplay[0]=\r\n:%80.80s:\r\n",
-		el->el_term.t_size.h, el->el_refresh.r_cursor.h,
-		el->el_refresh.r_cursor.v, el->el_vdisplay[0]));
-
-	ELRE_DEBUG(1, (__F, "updating %d lines.\r\n", el->el_refresh.r_newcv));
-	for (i = 0; i <= el->el_refresh.r_newcv; i++) {
-		/* NOTE THAT re_update_line MAY CHANGE el_display[i] */
-		re_update_line(el, el->el_display[i], el->el_vdisplay[i], i);
-
-		/*
-		 * Copy the new line to be the current one, and pad out with
-		 * spaces to the full width of the terminal so that if we try
-		 * moving the cursor by writing the character that is at the
-		 * end of the screen line, it won't be a NUL or some old
-		 * leftover stuff.
-		 */
-		re__copy_and_pad(el->el_display[i], el->el_vdisplay[i],
-		    (size_t) el->el_term.t_size.h);
-	}
-	ELRE_DEBUG(1, (__F,
-	"\r\nel->el_refresh.r_cursor.v=%d,el->el_refresh.r_oldcv=%d i=%d\r\n",
-	    el->el_refresh.r_cursor.v, el->el_refresh.r_oldcv, i));
-
-	if (el->el_refresh.r_oldcv > el->el_refresh.r_newcv)
-		for (; i <= el->el_refresh.r_oldcv; i++) {
-			term_move_to_line(el, i);
-			term_move_to_char(el, 0);
-			term_clear_EOL(el, (int) strlen(el->el_display[i]));
-#ifdef DEBUG_REFRESH
-			term_overwrite(el, "C\b", 2);
-#endif /* DEBUG_REFRESH */
-			el->el_display[i][0] = '\0';
-		}
-
-	el->el_refresh.r_oldcv = el->el_refresh.r_newcv; /* set for next time */
-	ELRE_DEBUG(1, (__F,
-	    "\r\ncursor.h = %d, cursor.v = %d, cur.h = %d, cur.v = %d\r\n",
-	    el->el_refresh.r_cursor.h, el->el_refresh.r_cursor.v,
-	    cur.h, cur.v));
-	term_move_to_line(el, cur.v);	/* go to where the cursor is */
-	term_move_to_char(el, cur.h);
-}
-
-
-/* re_goto_bottom():
- *	 used to go to last used screen line
- */
-protected void
-re_goto_bottom(EditLine *el)
-{
-
-	term_move_to_line(el, el->el_refresh.r_oldcv);
-	term__putc('\r');
-	term__putc('\n');
-	re_clear_display(el);
-	term__flush();
-}
-
-
-/* re_insert():
- *	insert num characters of s into d (in front of the character)
- *	at dat, maximum length of d is dlen
- */
-private void
-/*ARGSUSED*/
-re_insert(EditLine *el, char *d, int dat, int dlen, char *s, int num)
-{
-	char *a, *b;
-
-	if (num <= 0)
-		return;
-	if (num > dlen - dat)
-		num = dlen - dat;
-
-	ELRE_DEBUG(1,
-	    (__F, "re_insert() starting: %d at %d max %d, d == \"%s\"\n",
-	    num, dat, dlen, d));
-	ELRE_DEBUG(1, (__F, "s == \"%s\"n", s));
-
-	/* open up the space for num chars */
-	if (num > 0) {
-		b = d + dlen - 1;
-		a = b - num;
-		while (a >= &d[dat])
-			*b-- = *a--;
-		d[dlen] = '\0';	/* just in case */
-	}
-	ELRE_DEBUG(1, (__F,
-		"re_insert() after insert: %d at %d max %d, d == \"%s\"\n",
-		num, dat, dlen, d));
-	ELRE_DEBUG(1, (__F, "s == \"%s\"n", s));
-
-	/* copy the characters */
-	for (a = d + dat; (a < d + dlen) && (num > 0); num--)
-		*a++ = *s++;
-
-	ELRE_DEBUG(1,
-	    (__F, "re_insert() after copy: %d at %d max %d, %s == \"%s\"\n",
-	    num, dat, dlen, d, s));
-	ELRE_DEBUG(1, (__F, "s == \"%s\"n", s));
-}
-
-
-/* re_delete():
- *	delete num characters d at dat, maximum length of d is dlen
- */
-private void
-/*ARGSUSED*/
-re_delete(EditLine *el, char *d, int dat, int dlen, int num)
-{
-	char *a, *b;
-
-	if (num <= 0)
-		return;
-	if (dat + num >= dlen) {
-		d[dat] = '\0';
-		return;
-	}
-	ELRE_DEBUG(1,
-	    (__F, "re_delete() starting: %d at %d max %d, d == \"%s\"\n",
-	    num, dat, dlen, d));
-
-	/* open up the space for num chars */
-	if (num > 0) {
-		b = d + dat;
-		a = b + num;
-		while (a < &d[dlen])
-			*b++ = *a++;
-		d[dlen] = '\0';	/* just in case */
-	}
-	ELRE_DEBUG(1,
-	    (__F, "re_delete() after delete: %d at %d max %d, d == \"%s\"\n",
-	    num, dat, dlen, d));
-}
-
-
-/* re__strncopy():
- *	Like strncpy without padding.
- */
-private void
-re__strncopy(char *a, char *b, size_t n)
-{
-
-	while (n-- && *b)
-		*a++ = *b++;
-}
-
-
-/*****************************************************************
-    re_update_line() is based on finding the middle difference of each line
-    on the screen; vis:
-
-			     /old first difference
-	/beginning of line   |              /old last same       /old EOL
-	v		     v              v                    v
-old:	eddie> Oh, my little gruntle-buggy is to me, as lurgid as
-new:	eddie> Oh, my little buggy says to me, as lurgid as
-	^		     ^        ^			   ^
-	\beginning of line   |        \new last same	   \new end of line
-			     \new first difference
-
-    all are character pointers for the sake of speed.  Special cases for
-    no differences, as well as for end of line additions must be handled.
-**************************************************************** */
-
-/* Minimum at which doing an insert it "worth it".  This should be about
- * half the "cost" of going into insert mode, inserting a character, and
- * going back out.  This should really be calculated from the termcap
- * data...  For the moment, a good number for ANSI terminals.
- */
-#define	MIN_END_KEEP	4
-
-private void
-re_update_line(EditLine *el, char *old, char *new, int i)
-{
-	char *o, *n, *p, c;
-	char *ofd, *ols, *oe, *nfd, *nls, *ne;
-	char *osb, *ose, *nsb, *nse;
-	int fx, sx;
-
-	/*
-         * find first diff
-         */
-	for (o = old, n = new; *o && (*o == *n); o++, n++)
-		continue;
-	ofd = o;
-	nfd = n;
-
-	/*
-         * Find the end of both old and new
-         */
-	while (*o)
-		o++;
-	/*
-         * Remove any trailing blanks off of the end, being careful not to
-         * back up past the beginning.
-         */
-	while (ofd < o) {
-		if (o[-1] != ' ')
-			break;
-		o--;
-	}
-	oe = o;
-	*oe = '\0';
-
-	while (*n)
-		n++;
-
-	/* remove blanks from end of new */
-	while (nfd < n) {
-		if (n[-1] != ' ')
-			break;
-		n--;
-	}
-	ne = n;
-	*ne = '\0';
-
-	/*
-         * if no diff, continue to next line of redraw
-         */
-	if (*ofd == '\0' && *nfd == '\0') {
-		ELRE_DEBUG(1, (__F, "no difference.\r\n"));
-		return;
-	}
-	/*
-         * find last same pointer
-         */
-	while ((o > ofd) && (n > nfd) && (*--o == *--n))
-		continue;
-	ols = ++o;
-	nls = ++n;
-
-	/*
-         * find same begining and same end
-         */
-	osb = ols;
-	nsb = nls;
-	ose = ols;
-	nse = nls;
-
-	/*
-         * case 1: insert: scan from nfd to nls looking for *ofd
-         */
-	if (*ofd) {
-		for (c = *ofd, n = nfd; n < nls; n++) {
-			if (c == *n) {
-				for (o = ofd, p = n;
-				    p < nls && o < ols && *o == *p;
-				    o++, p++)
-					continue;
-				/*
-				 * if the new match is longer and it's worth
-				 * keeping, then we take it
-				 */
-				if (((nse - nsb) < (p - n)) &&
-				    (2 * (p - n) > n - nfd)) {
-					nsb = n;
-					nse = p;
-					osb = ofd;
-					ose = o;
-				}
-			}
-		}
-	}
-	/*
-         * case 2: delete: scan from ofd to ols looking for *nfd
-         */
-	if (*nfd) {
-		for (c = *nfd, o = ofd; o < ols; o++) {
-			if (c == *o) {
-				for (n = nfd, p = o;
-				    p < ols && n < nls && *p == *n;
-				    p++, n++)
-					continue;
-				/*
-				 * if the new match is longer and it's worth
-				 * keeping, then we take it
-				 */
-				if (((ose - osb) < (p - o)) &&
-				    (2 * (p - o) > o - ofd)) {
-					nsb = nfd;
-					nse = n;
-					osb = o;
-					ose = p;
-				}
-			}
-		}
-	}
-	/*
-         * Pragmatics I: If old trailing whitespace or not enough characters to
-         * save to be worth it, then don't save the last same info.
-         */
-	if ((oe - ols) < MIN_END_KEEP) {
-		ols = oe;
-		nls = ne;
-	}
-	/*
-         * Pragmatics II: if the terminal isn't smart enough, make the data
-         * dumber so the smart update doesn't try anything fancy
-         */
-
-	/*
-         * fx is the number of characters we need to insert/delete: in the
-         * beginning to bring the two same begins together
-         */
-	fx = (nsb - nfd) - (osb - ofd);
-	/*
-         * sx is the number of characters we need to insert/delete: in the
-         * end to bring the two same last parts together
-         */
-	sx = (nls - nse) - (ols - ose);
-
-	if (!EL_CAN_INSERT) {
-		if (fx > 0) {
-			osb = ols;
-			ose = ols;
-			nsb = nls;
-			nse = nls;
-		}
-		if (sx > 0) {
-			ols = oe;
-			nls = ne;
-		}
-		if ((ols - ofd) < (nls - nfd)) {
-			ols = oe;
-			nls = ne;
-		}
-	}
-	if (!EL_CAN_DELETE) {
-		if (fx < 0) {
-			osb = ols;
-			ose = ols;
-			nsb = nls;
-			nse = nls;
-		}
-		if (sx < 0) {
-			ols = oe;
-			nls = ne;
-		}
-		if ((ols - ofd) > (nls - nfd)) {
-			ols = oe;
-			nls = ne;
-		}
-	}
-	/*
-         * Pragmatics III: make sure the middle shifted pointers are correct if
-         * they don't point to anything (we may have moved ols or nls).
-         */
-	/* if the change isn't worth it, don't bother */
-	/* was: if (osb == ose) */
-	if ((ose - osb) < MIN_END_KEEP) {
-		osb = ols;
-		ose = ols;
-		nsb = nls;
-		nse = nls;
-	}
-	/*
-         * Now that we are done with pragmatics we recompute fx, sx
-         */
-	fx = (nsb - nfd) - (osb - ofd);
-	sx = (nls - nse) - (ols - ose);
-
-	ELRE_DEBUG(1, (__F, "\n"));
-	ELRE_DEBUG(1, (__F, "ofd %d, osb %d, ose %d, ols %d, oe %d\n",
-		ofd - old, osb - old, ose - old, ols - old, oe - old));
-	ELRE_DEBUG(1, (__F, "nfd %d, nsb %d, nse %d, nls %d, ne %d\n",
-		nfd - new, nsb - new, nse - new, nls - new, ne - new));
-	ELRE_DEBUG(1, (__F,
-		"xxx-xxx:\"00000000001111111111222222222233333333334\"\r\n"));
-	ELRE_DEBUG(1, (__F,
-		"xxx-xxx:\"01234567890123456789012345678901234567890\"\r\n"));
-#ifdef DEBUG_REFRESH
-	re_printstr(el, "old- oe", old, oe);
-	re_printstr(el, "new- ne", new, ne);
-	re_printstr(el, "old-ofd", old, ofd);
-	re_printstr(el, "new-nfd", new, nfd);
-	re_printstr(el, "ofd-osb", ofd, osb);
-	re_printstr(el, "nfd-nsb", nfd, nsb);
-	re_printstr(el, "osb-ose", osb, ose);
-	re_printstr(el, "nsb-nse", nsb, nse);
-	re_printstr(el, "ose-ols", ose, ols);
-	re_printstr(el, "nse-nls", nse, nls);
-	re_printstr(el, "ols- oe", ols, oe);
-	re_printstr(el, "nls- ne", nls, ne);
-#endif /* DEBUG_REFRESH */
-
-	/*
-         * el_cursor.v to this line i MUST be in this routine so that if we
-         * don't have to change the line, we don't move to it. el_cursor.h to
-         * first diff char
-         */
-	term_move_to_line(el, i);
-
-	/*
-         * at this point we have something like this:
-         *
-         * /old                  /ofd    /osb               /ose    /ols     /oe
-         * v.....................v       v..................v       v........v
-         * eddie> Oh, my fredded gruntle-buggy is to me, as foo var lurgid as
-         * eddie> Oh, my fredded quiux buggy is to me, as gruntle-lurgid as
-         * ^.....................^     ^..................^       ^........^
-         * \new                  \nfd  \nsb               \nse     \nls    \ne
-         *
-         * fx is the difference in length between the chars between nfd and
-         * nsb, and the chars between ofd and osb, and is thus the number of
-         * characters to delete if < 0 (new is shorter than old, as above),
-         * or insert (new is longer than short).
-         *
-         * sx is the same for the second differences.
-         */
-
-	/*
-         * if we have a net insert on the first difference, AND inserting the
-         * net amount ((nsb-nfd) - (osb-ofd)) won't push the last useful
-         * character (which is ne if nls != ne, otherwise is nse) off the edge
-	 * of the screen (el->el_term.t_size.h) else we do the deletes first
-	 * so that we keep everything we need to.
-         */
-
-	/*
-         * if the last same is the same like the end, there is no last same
-         * part, otherwise we want to keep the last same part set p to the
-         * last useful old character
-         */
-	p = (ols != oe) ? oe : ose;
-
-	/*
-         * if (There is a diffence in the beginning) && (we need to insert
-         *   characters) && (the number of characters to insert is less than
-         *   the term width)
-	 *	We need to do an insert!
-	 * else if (we need to delete characters)
-	 *	We need to delete characters!
-	 * else
-	 *	No insert or delete
-         */
-	if ((nsb != nfd) && fx > 0 &&
-	    ((p - old) + fx <= el->el_term.t_size.h)) {
-		ELRE_DEBUG(1,
-		    (__F, "first diff insert at %d...\r\n", nfd - new));
-		/*
-		 * Move to the first char to insert, where the first diff is.
-		 */
-		term_move_to_char(el, nfd - new);
-		/*
-		 * Check if we have stuff to keep at end
-		 */
-		if (nsb != ne) {
-			ELRE_DEBUG(1, (__F, "with stuff to keep at end\r\n"));
-			/*
-		         * insert fx chars of new starting at nfd
-		         */
-			if (fx > 0) {
-				ELRE_DEBUG(!EL_CAN_INSERT, (__F,
-				"ERROR: cannot insert in early first diff\n"));
-				term_insertwrite(el, nfd, fx);
-				re_insert(el, old, ofd - old,
-				    el->el_term.t_size.h, nfd, fx);
-			}
-			/*
-		         * write (nsb-nfd) - fx chars of new starting at
-		         * (nfd + fx)
-			 */
-			term_overwrite(el, nfd + fx, (nsb - nfd) - fx);
-			re__strncopy(ofd + fx, nfd + fx,
-			    (size_t) ((nsb - nfd) - fx));
-		} else {
-			ELRE_DEBUG(1, (__F, "without anything to save\r\n"));
-			term_overwrite(el, nfd, (nsb - nfd));
-			re__strncopy(ofd, nfd, (size_t) (nsb - nfd));
-			/*
-		         * Done
-		         */
-			return;
-		}
-	} else if (fx < 0) {
-		ELRE_DEBUG(1,
-		    (__F, "first diff delete at %d...\r\n", ofd - old));
-		/*
-		 * move to the first char to delete where the first diff is
-		 */
-		term_move_to_char(el, ofd - old);
-		/*
-		 * Check if we have stuff to save
-		 */
-		if (osb != oe) {
-			ELRE_DEBUG(1, (__F, "with stuff to save at end\r\n"));
-			/*
-		         * fx is less than zero *always* here but we check
-		         * for code symmetry
-		         */
-			if (fx < 0) {
-				ELRE_DEBUG(!EL_CAN_DELETE, (__F,
-				    "ERROR: cannot delete in first diff\n"));
-				term_deletechars(el, -fx);
-				re_delete(el, old, ofd - old,
-				    el->el_term.t_size.h, -fx);
-			}
-			/*
-		         * write (nsb-nfd) chars of new starting at nfd
-		         */
-			term_overwrite(el, nfd, (nsb - nfd));
-			re__strncopy(ofd, nfd, (size_t) (nsb - nfd));
-
-		} else {
-			ELRE_DEBUG(1, (__F,
-			    "but with nothing left to save\r\n"));
-			/*
-		         * write (nsb-nfd) chars of new starting at nfd
-		         */
-			term_overwrite(el, nfd, (nsb - nfd));
-			ELRE_DEBUG(1, (__F,
-			    "cleareol %d\n", (oe - old) - (ne - new)));
-			term_clear_EOL(el, (oe - old) - (ne - new));
-			/*
-		         * Done
-		         */
-			return;
-		}
-	} else
-		fx = 0;
-
-	if (sx < 0 && (ose - old) + fx < el->el_term.t_size.h) {
-		ELRE_DEBUG(1, (__F,
-		    "second diff delete at %d...\r\n", (ose - old) + fx));
-		/*
-		 * Check if we have stuff to delete
-		 */
-		/*
-		 * fx is the number of characters inserted (+) or deleted (-)
-		 */
-
-		term_move_to_char(el, (ose - old) + fx);
-		/*
-		 * Check if we have stuff to save
-		 */
-		if (ols != oe) {
-			ELRE_DEBUG(1, (__F, "with stuff to save at end\r\n"));
-			/*
-		         * Again a duplicate test.
-		         */
-			if (sx < 0) {
-				ELRE_DEBUG(!EL_CAN_DELETE, (__F,
-				    "ERROR: cannot delete in second diff\n"));
-				term_deletechars(el, -sx);
-			}
-			/*
-		         * write (nls-nse) chars of new starting at nse
-		         */
-			term_overwrite(el, nse, (nls - nse));
-		} else {
-			ELRE_DEBUG(1, (__F,
-			    "but with nothing left to save\r\n"));
-			term_overwrite(el, nse, (nls - nse));
-			ELRE_DEBUG(1, (__F,
-			    "cleareol %d\n", (oe - old) - (ne - new)));
-			if ((oe - old) - (ne - new) != 0)
-				term_clear_EOL(el, (oe - old) - (ne - new));
-		}
-	}
-	/*
-         * if we have a first insert AND WE HAVEN'T ALREADY DONE IT...
-         */
-	if ((nsb != nfd) && (osb - ofd) <= (nsb - nfd) && (fx == 0)) {
-		ELRE_DEBUG(1, (__F, "late first diff insert at %d...\r\n",
-		    nfd - new));
-
-		term_move_to_char(el, nfd - new);
-		/*
-		 * Check if we have stuff to keep at the end
-		 */
-		if (nsb != ne) {
-			ELRE_DEBUG(1, (__F, "with stuff to keep at end\r\n"));
-			/*
-		         * We have to recalculate fx here because we set it
-		         * to zero above as a flag saying that we hadn't done
-		         * an early first insert.
-		         */
-			fx = (nsb - nfd) - (osb - ofd);
-			if (fx > 0) {
-				/*
-				 * insert fx chars of new starting at nfd
-				 */
-				ELRE_DEBUG(!EL_CAN_INSERT, (__F,
-				 "ERROR: cannot insert in late first diff\n"));
-				term_insertwrite(el, nfd, fx);
-				re_insert(el, old, ofd - old,
-				    el->el_term.t_size.h, nfd, fx);
-			}
-			/*
-		         * write (nsb-nfd) - fx chars of new starting at
-		         * (nfd + fx)
-			 */
-			term_overwrite(el, nfd + fx, (nsb - nfd) - fx);
-			re__strncopy(ofd + fx, nfd + fx,
-			    (size_t) ((nsb - nfd) - fx));
-		} else {
-			ELRE_DEBUG(1, (__F, "without anything to save\r\n"));
-			term_overwrite(el, nfd, (nsb - nfd));
-			re__strncopy(ofd, nfd, (size_t) (nsb - nfd));
-		}
-	}
-	/*
-         * line is now NEW up to nse
-         */
-	if (sx >= 0) {
-		ELRE_DEBUG(1, (__F,
-		    "second diff insert at %d...\r\n", nse - new));
-		term_move_to_char(el, nse - new);
-		if (ols != oe) {
-			ELRE_DEBUG(1, (__F, "with stuff to keep at end\r\n"));
-			if (sx > 0) {
-				/* insert sx chars of new starting at nse */
-				ELRE_DEBUG(!EL_CAN_INSERT, (__F,
-				    "ERROR: cannot insert in second diff\n"));
-				term_insertwrite(el, nse, sx);
-			}
-			/*
-		         * write (nls-nse) - sx chars of new starting at
-			 * (nse + sx)
-		         */
-			term_overwrite(el, nse + sx, (nls - nse) - sx);
-		} else {
-			ELRE_DEBUG(1, (__F, "without anything to save\r\n"));
-			term_overwrite(el, nse, (nls - nse));
-
-			/*
-	                 * No need to do a clear-to-end here because we were
-	                 * doing a second insert, so we will have over
-	                 * written all of the old string.
-		         */
-		}
-	}
-	ELRE_DEBUG(1, (__F, "done.\r\n"));
-}
-
-
-/* re__copy_and_pad():
- *	Copy string and pad with spaces
- */
-private void
-re__copy_and_pad(char *dst, const char *src, size_t width)
-{
-	int i;
-
-	for (i = 0; i < width; i++) {
-		if (*src == '\0')
-			break;
-		*dst++ = *src++;
-	}
-
-	for (; i < width; i++)
-		*dst++ = ' ';
-
-	*dst = '\0';
-}
-
-
-/* re_refresh_cursor():
- *	Move to the new cursor position
- */
-protected void
-re_refresh_cursor(EditLine *el)
-{
-	char *cp, c;
-	int h, v, th;
-
-	/* first we must find where the cursor is... */
-	h = el->el_prompt.p_pos.h;
-	v = el->el_prompt.p_pos.v;
-	th = el->el_term.t_size.h;	/* optimize for speed */
-
-	/* do input buffer to el->el_line.cursor */
-	for (cp = el->el_line.buffer; cp < el->el_line.cursor; cp++) {
-		c = *cp;
-		h++;		/* all chars at least this long */
-
-		if (c == '\n') {/* handle newline in data part too */
-			h = 0;
-			v++;
-		} else {
-			if (c == '\t') {	/* if a tab, to next tab stop */
-				while (h & 07) {
-					h++;
-				}
-			} else if (iscntrl((unsigned char) c)) {
-						/* if control char */
-				h++;
-				if (h > th) {	/* if overflow, compensate */
-					h = 1;
-					v++;
-				}
-			} else if (!isprint((unsigned char) c)) {
-				h += 3;
-				if (h > th) {	/* if overflow, compensate */
-					h = h - th;
-					v++;
-				}
-			}
-		}
-
-		if (h >= th) {	/* check, extra long tabs picked up here also */
-			h = 0;
-			v++;
-		}
-	}
-
-	/* now go there */
-	term_move_to_line(el, v);
-	term_move_to_char(el, h);
-	term__flush();
-}
-
-
-/* re_fastputc():
- *	Add a character fast.
- */
-private void
-re_fastputc(EditLine *el, int c)
-{
-
-	term__putc(c);
-	el->el_display[el->el_cursor.v][el->el_cursor.h++] = c;
-	if (el->el_cursor.h >= el->el_term.t_size.h) {
-		/* if we must overflow */
-		el->el_cursor.h = 0;
-
-		/*
-		 * If we would overflow (input is longer than terminal size),
-		 * emulate scroll by dropping first line and shuffling the rest.
-		 * We do this via pointer shuffling - it's safe in this case
-		 * and we avoid memcpy().
-		 */
-		if (el->el_cursor.v + 1 >= el->el_term.t_size.v) {
-			int i, lins = el->el_term.t_size.v;
-			char *firstline = el->el_display[0];
-	
-			for(i=1; i < lins; i++)
-				el->el_display[i-1] = el->el_display[i];
-
-			re__copy_and_pad(firstline, "", 0);
-			el->el_display[i-1] = firstline;
-		} else {
-			el->el_cursor.v++;
-			el->el_refresh.r_oldcv++;
-		}
-		if (EL_HAS_AUTO_MARGINS) {
-			if (EL_HAS_MAGIC_MARGINS) {
-				term__putc(' ');
-				term__putc('\b');
-			}
-		} else {
-			term__putc('\r');
-			term__putc('\n');
-		}
-	}
-}
-
-
-/* re_fastaddc():
- *	we added just one char, handle it fast.
- *	Assumes that screen cursor == real cursor
- */
-protected void
-re_fastaddc(EditLine *el)
-{
-	char c;
-	int rhdiff;
-
-	c = el->el_line.cursor[-1];
-
-	if (c == '\t' || el->el_line.cursor != el->el_line.lastchar) {
-		re_refresh(el);	/* too hard to handle */
-		return;
-	}
-	rhdiff = el->el_term.t_size.h - el->el_cursor.h -
-	    el->el_rprompt.p_pos.h;
-	if (el->el_rprompt.p_pos.h && rhdiff < 3) {
-		re_refresh(el);	/* clear out rprompt if less than 1 char gap */
-		return;
-	}			/* else (only do at end of line, no TAB) */
-	if (iscntrl((unsigned char) c)) {	/* if control char, do caret */
-		char mc = (c == '\177') ? '?' : (c | 0100);
-		re_fastputc(el, '^');
-		re_fastputc(el, mc);
-	} else if (isprint((unsigned char) c)) {	/* normal char */
-		re_fastputc(el, c);
-	} else {
-		re_fastputc(el, '\\');
-		re_fastputc(el, (int) ((((unsigned int) c >> 6) & 7) + '0'));
-		re_fastputc(el, (int) ((((unsigned int) c >> 3) & 7) + '0'));
-		re_fastputc(el, (c & 7) + '0');
-	}
-	term__flush();
-}
-
-
-/* re_clear_display():
- *	clear the screen buffers so that new new prompt starts fresh.
- */
-protected void
-re_clear_display(EditLine *el)
-{
-	int i;
-
-	el->el_cursor.v = 0;
-	el->el_cursor.h = 0;
-	for (i = 0; i < el->el_term.t_size.v; i++)
-		el->el_display[i][0] = '\0';
-	el->el_refresh.r_oldcv = 0;
-}
-
-
-/* re_clear_lines():
- *	Make sure all lines are *really* blank
- */
-protected void
-re_clear_lines(EditLine *el)
-{
-
-	if (EL_CAN_CEOL) {
-		int i;
-		term_move_to_char(el, 0);
-		for (i = 0; i <= el->el_refresh.r_oldcv; i++) {
-			/* for each line on the screen */
-			term_move_to_line(el, i);
-			term_clear_EOL(el, el->el_term.t_size.h);
-		}
-		term_move_to_line(el, 0);
-	} else {
-		term_move_to_line(el, el->el_refresh.r_oldcv);
-					/* go to last line */
-		term__putc('\r');	/* go to BOL */
-		term__putc('\n');	/* go to new line */
-	}
-}
diff --git a/main/editline/refresh.h b/main/editline/refresh.h
deleted file mode 100644
index 33c0887..0000000
--- a/main/editline/refresh.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*	$NetBSD: refresh.h,v 1.4 2001/01/10 07:45:42 jdolecek Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)refresh.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.refresh.h: Screen refresh functions
- */
-#ifndef _h_el_refresh
-#define	_h_el_refresh
-
-#include "histedit.h"
-
-typedef struct {
-	coord_t	r_cursor;	/* Refresh cursor position	*/
-	int	r_oldcv;	/* Vertical locations		*/
-	int	r_newcv;
-} el_refresh_t;
-
-protected void	re_putc(EditLine *, int, int);
-protected void	re_clear_lines(EditLine *);
-protected void	re_clear_display(EditLine *);
-protected void	re_refresh(EditLine *);
-protected void	re_refresh_cursor(EditLine *);
-protected void	re_fastaddc(EditLine *);
-protected void	re_goto_bottom(EditLine *);
-
-#endif /* _h_el_refresh */
diff --git a/main/editline/search.c b/main/editline/search.c
deleted file mode 100644
index 7c1cb84..0000000
--- a/main/editline/search.c
+++ /dev/null
@@ -1,649 +0,0 @@
-/*	$NetBSD: search.c,v 1.12 2002/03/18 16:00:58 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)search.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: search.c,v 1.12 2002/03/18 16:00:58 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * search.c: History and character search functions
- */
-#include <stdlib.h>
-#if defined(REGEX)
-#include <regex.h>
-#elif defined(REGEXP)
-#include <regexp.h>
-#endif
-#include "el.h"
-
-/*
- * Adjust cursor in vi mode to include the character under it
- */
-#define	EL_CURSOR(el) \
-    ((el)->el_line.cursor + (((el)->el_map.type == MAP_VI) && \
-			    ((el)->el_map.current == (el)->el_map.alt)))
-
-/* search_init():
- *	Initialize the search stuff
- */
-protected int
-search_init(EditLine *el)
-{
-
-	el->el_search.patbuf = (char *) el_malloc(EL_BUFSIZ);
-	if (el->el_search.patbuf == NULL)
-		return (-1);
-	el->el_search.patlen = 0;
-	el->el_search.patdir = -1;
-	el->el_search.chacha = '\0';
-	el->el_search.chadir = -1;
-	return (0);
-}
-
-
-/* search_end():
- *	Initialize the search stuff
- */
-protected void
-search_end(EditLine *el)
-{
-
-	el_free((ptr_t) el->el_search.patbuf);
-	el->el_search.patbuf = NULL;
-}
-
-
-#ifdef REGEXP
-/* regerror():
- *	Handle regular expression errors
- */
-public void
-/*ARGSUSED*/
-regerror(const char *msg)
-{
-}
-#endif
-
-
-/* el_match():
- *	Return if string matches pattern
- */
-protected int
-el_match(const char *str, const char *pat)
-{
-#if defined (REGEX)
-	regex_t re;
-	int rv;
-#elif defined (REGEXP)
-	regexp *rp;
-	int rv;
-#else
-	extern char	*re_comp(const char *);
-	extern int	 re_exec(const char *);
-#endif
-
-	if (strstr(str, pat) != NULL)
-		return (1);
-
-#if defined(REGEX)
-	if (regcomp(&re, pat, 0) == 0) {
-		rv = regexec(&re, str, 0, NULL, 0) == 0;
-		regfree(&re);
-	} else {
-		rv = 0;
-	}
-	return (rv);
-#elif defined(REGEXP)
-	if ((re = regcomp(pat)) != NULL) {
-		rv = regexec(re, str);
-		free((ptr_t) re);
-	} else {
-		rv = 0;
-	}
-	return (rv);
-#else
-	if (re_comp(pat) != NULL)
-		return (0);
-	else
-		return (re_exec(str) == 1);
-#endif
-}
-
-
-/* c_hmatch():
- *	 return True if the pattern matches the prefix
- */
-protected int
-c_hmatch(EditLine *el, const char *str)
-{
-#ifdef SDEBUG
-	(void) fprintf(el->el_errfile, "match `%s' with `%s'\n",
-	    el->el_search.patbuf, str);
-#endif /* SDEBUG */
-
-	return (el_match(str, el->el_search.patbuf));
-}
-
-
-/* c_setpat():
- *	Set the history seatch pattern
- */
-protected void
-c_setpat(EditLine *el)
-{
-	if (el->el_state.lastcmd != ED_SEARCH_PREV_HISTORY &&
-	    el->el_state.lastcmd != ED_SEARCH_NEXT_HISTORY) {
-		el->el_search.patlen = EL_CURSOR(el) - el->el_line.buffer;
-		if (el->el_search.patlen >= EL_BUFSIZ)
-			el->el_search.patlen = EL_BUFSIZ - 1;
-		if (el->el_search.patlen != 0) {
-			(void) strncpy(el->el_search.patbuf, el->el_line.buffer,
-			    el->el_search.patlen);
-			el->el_search.patbuf[el->el_search.patlen] = '\0';
-		} else
-			el->el_search.patlen = strlen(el->el_search.patbuf);
-	}
-#ifdef SDEBUG
-	(void) fprintf(el->el_errfile, "\neventno = %d\n",
-	    el->el_history.eventno);
-	(void) fprintf(el->el_errfile, "patlen = %d\n", el->el_search.patlen);
-	(void) fprintf(el->el_errfile, "patbuf = \"%s\"\n",
-	    el->el_search.patbuf);
-	(void) fprintf(el->el_errfile, "cursor %d lastchar %d\n",
-	    EL_CURSOR(el) - el->el_line.buffer,
-	    el->el_line.lastchar - el->el_line.buffer);
-#endif
-}
-
-
-/* ce_inc_search():
- *	Emacs incremental search
- */
-protected el_action_t
-ce_inc_search(EditLine *el, int dir)
-{
-	static const char STRfwd[] = {'f', 'w', 'd', '\0'},
-	     STRbck[] = {'b', 'c', 'k', '\0'};
-	static char pchar = ':';/* ':' = normal, '?' = failed */
-	static char endcmd[2] = {'\0', '\0'};
-	char ch, *ocursor = el->el_line.cursor, oldpchar = pchar;
-	const char *cp;
-
-	el_action_t ret = CC_NORM;
-
-	int ohisteventno = el->el_history.eventno;
-	int oldpatlen = el->el_search.patlen;
-	int newdir = dir;
-	int done, redo;
-
-	if (el->el_line.lastchar + sizeof(STRfwd) / sizeof(char) + 2 +
-	    el->el_search.patlen >= el->el_line.limit)
-		return (CC_ERROR);
-
-	for (;;) {
-
-		if (el->el_search.patlen == 0) {	/* first round */
-			pchar = ':';
-#ifdef ANCHOR
-			el->el_search.patbuf[el->el_search.patlen++] = '.';
-			el->el_search.patbuf[el->el_search.patlen++] = '*';
-#endif
-		}
-		done = redo = 0;
-		*el->el_line.lastchar++ = '\n';
-		for (cp = (newdir == ED_SEARCH_PREV_HISTORY) ? STRbck : STRfwd;
-		    *cp; *el->el_line.lastchar++ = *cp++)
-			continue;
-		*el->el_line.lastchar++ = pchar;
-		for (cp = &el->el_search.patbuf[1];
-		    cp < &el->el_search.patbuf[el->el_search.patlen];
-		    *el->el_line.lastchar++ = *cp++)
-			continue;
-		*el->el_line.lastchar = '\0';
-		re_refresh(el);
-
-		if (el_getc(el, &ch) != 1)
-			return (ed_end_of_file(el, 0));
-
-		switch (el->el_map.current[(unsigned char) ch]) {
-		case ED_INSERT:
-		case ED_DIGIT:
-			if (el->el_search.patlen > EL_BUFSIZ - 3)
-				term_beep(el);
-			else {
-				el->el_search.patbuf[el->el_search.patlen++] =
-				    ch;
-				*el->el_line.lastchar++ = ch;
-				*el->el_line.lastchar = '\0';
-				re_refresh(el);
-			}
-			break;
-
-		case EM_INC_SEARCH_NEXT:
-			newdir = ED_SEARCH_NEXT_HISTORY;
-			redo++;
-			break;
-
-		case EM_INC_SEARCH_PREV:
-			newdir = ED_SEARCH_PREV_HISTORY;
-			redo++;
-			break;
-
-		case ED_DELETE_PREV_CHAR:
-			if (el->el_search.patlen > 1)
-				done++;
-			else
-				term_beep(el);
-			break;
-
-		default:
-			switch (ch) {
-			case 0007:	/* ^G: Abort */
-				ret = CC_ERROR;
-				done++;
-				break;
-
-			case 0027:	/* ^W: Append word */
-			/* No can do if globbing characters in pattern */
-				for (cp = &el->el_search.patbuf[1];; cp++)
-				    if (cp >= &el->el_search.patbuf[el->el_search.patlen]) {
-					el->el_line.cursor +=
-					    el->el_search.patlen - 1;
-					cp = c__next_word(el->el_line.cursor,
-					    el->el_line.lastchar, 1,
-					    ce__isword);
-					while (el->el_line.cursor < cp &&
-					    *el->el_line.cursor != '\n') {
-						if (el->el_search.patlen >
-						    EL_BUFSIZ - 3) {
-							term_beep(el);
-							break;
-						}
-						el->el_search.patbuf[el->el_search.patlen++] =
-						    *el->el_line.cursor;
-						*el->el_line.lastchar++ =
-						    *el->el_line.cursor++;
-					}
-					el->el_line.cursor = ocursor;
-					*el->el_line.lastchar = '\0';
-					re_refresh(el);
-					break;
-				    } else if (isglob(*cp)) {
-					    term_beep(el);
-					    break;
-				    }
-				break;
-
-			default:	/* Terminate and execute cmd */
-				endcmd[0] = ch;
-				el_push(el, endcmd);
-				/* FALLTHROUGH */
-
-			case 0033:	/* ESC: Terminate */
-				ret = CC_REFRESH;
-				done++;
-				break;
-			}
-			break;
-		}
-
-		while (el->el_line.lastchar > el->el_line.buffer &&
-		    *el->el_line.lastchar != '\n')
-			*el->el_line.lastchar-- = '\0';
-		*el->el_line.lastchar = '\0';
-
-		if (!done) {
-
-			/* Can't search if unmatched '[' */
-			for (cp = &el->el_search.patbuf[el->el_search.patlen-1],
-			    ch = ']';
-			    cp > el->el_search.patbuf;
-			    cp--)
-				if (*cp == '[' || *cp == ']') {
-					ch = *cp;
-					break;
-				}
-			if (el->el_search.patlen > 1 && ch != '[') {
-				if (redo && newdir == dir) {
-					if (pchar == '?') { /* wrap around */
-						el->el_history.eventno =
-						    newdir == ED_SEARCH_PREV_HISTORY ? 0 : 0x7fffffff;
-						if (hist_get(el) == CC_ERROR)
-							/* el->el_history.event
-							 * no was fixed by
-							 * first call */
-							(void) hist_get(el);
-						el->el_line.cursor = newdir ==
-						    ED_SEARCH_PREV_HISTORY ?
-						    el->el_line.lastchar :
-						    el->el_line.buffer;
-					} else
-						el->el_line.cursor +=
-						    newdir ==
-						    ED_SEARCH_PREV_HISTORY ?
-						    -1 : 1;
-				}
-#ifdef ANCHOR
-				el->el_search.patbuf[el->el_search.patlen++] =
-				    '.';
-				el->el_search.patbuf[el->el_search.patlen++] =
-				    '*';
-#endif
-				el->el_search.patbuf[el->el_search.patlen] =
-				    '\0';
-				if (el->el_line.cursor < el->el_line.buffer ||
-				    el->el_line.cursor > el->el_line.lastchar ||
-				    (ret = ce_search_line(el,
-				    &el->el_search.patbuf[1],
-				    newdir)) == CC_ERROR) {
-					/* avoid c_setpat */
-					el->el_state.lastcmd =
-					    (el_action_t) newdir;
-					ret = newdir == ED_SEARCH_PREV_HISTORY ?
-					    ed_search_prev_history(el, 0) :
-					    ed_search_next_history(el, 0);
-					if (ret != CC_ERROR) {
-						el->el_line.cursor = newdir ==
-						    ED_SEARCH_PREV_HISTORY ?
-						    el->el_line.lastchar :
-						    el->el_line.buffer;
-						(void) ce_search_line(el,
-						    &el->el_search.patbuf[1],
-						    newdir);
-					}
-				}
-				el->el_search.patbuf[--el->el_search.patlen] =
-				    '\0';
-				if (ret == CC_ERROR) {
-					term_beep(el);
-					if (el->el_history.eventno !=
-					    ohisteventno) {
-						el->el_history.eventno =
-						    ohisteventno;
-						if (hist_get(el) == CC_ERROR)
-							return (CC_ERROR);
-					}
-					el->el_line.cursor = ocursor;
-					pchar = '?';
-				} else {
-					pchar = ':';
-				}
-			}
-			ret = ce_inc_search(el, newdir);
-
-			if (ret == CC_ERROR && pchar == '?' && oldpchar == ':')
-				/*
-				 * break abort of failed search at last
-				 * non-failed
-				 */
-				ret = CC_NORM;
-
-		}
-		if (ret == CC_NORM || (ret == CC_ERROR && oldpatlen == 0)) {
-			/* restore on normal return or error exit */
-			pchar = oldpchar;
-			el->el_search.patlen = oldpatlen;
-			if (el->el_history.eventno != ohisteventno) {
-				el->el_history.eventno = ohisteventno;
-				if (hist_get(el) == CC_ERROR)
-					return (CC_ERROR);
-			}
-			el->el_line.cursor = ocursor;
-			if (ret == CC_ERROR)
-				re_refresh(el);
-		}
-		if (done || ret != CC_NORM)
-			return (ret);
-	}
-}
-
-
-/* cv_search():
- *	Vi search.
- */
-protected el_action_t
-cv_search(EditLine *el, int dir)
-{
-	char ch;
-	char tmpbuf[EL_BUFSIZ];
-	int tmplen;
-
-	tmplen = 0;
-#ifdef ANCHOR
-	tmpbuf[tmplen++] = '.';
-	tmpbuf[tmplen++] = '*';
-#endif
-
-	el->el_line.buffer[0] = '\0';
-	el->el_line.lastchar = el->el_line.buffer;
-	el->el_line.cursor = el->el_line.buffer;
-	el->el_search.patdir = dir;
-
-	c_insert(el, 2);	/* prompt + '\n' */
-	*el->el_line.cursor++ = '\n';
-	*el->el_line.cursor++ = dir == ED_SEARCH_PREV_HISTORY ? '/' : '?';
-	re_refresh(el);
-
-#ifdef ANCHOR
-#define	LEN	2
-#else
-#define	LEN	0
-#endif
-
-	tmplen = c_gets(el, &tmpbuf[LEN]) + LEN;
-	ch = tmpbuf[tmplen];
-	tmpbuf[tmplen] = '\0';
-
-	if (tmplen == LEN) {
-		/*
-		 * Use the old pattern, but wild-card it.
-		 */
-		if (el->el_search.patlen == 0) {
-			el->el_line.buffer[0] = '\0';
-			el->el_line.lastchar = el->el_line.buffer;
-			el->el_line.cursor = el->el_line.buffer;
-			re_refresh(el);
-			return (CC_ERROR);
-		}
-#ifdef ANCHOR
-		if (el->el_search.patbuf[0] != '.' &&
-		    el->el_search.patbuf[0] != '*') {
-			(void) strncpy(tmpbuf, el->el_search.patbuf,
-			    sizeof(tmpbuf) - 1);
-			el->el_search.patbuf[0] = '.';
-			el->el_search.patbuf[1] = '*';
-			(void) strncpy(&el->el_search.patbuf[2], tmpbuf,
-			    EL_BUFSIZ - 3);
-			el->el_search.patlen++;
-			el->el_search.patbuf[el->el_search.patlen++] = '.';
-			el->el_search.patbuf[el->el_search.patlen++] = '*';
-			el->el_search.patbuf[el->el_search.patlen] = '\0';
-		}
-#endif
-	} else {
-#ifdef ANCHOR
-		tmpbuf[tmplen++] = '.';
-		tmpbuf[tmplen++] = '*';
-#endif
-		tmpbuf[tmplen] = '\0';
-		(void) strncpy(el->el_search.patbuf, tmpbuf, EL_BUFSIZ - 1);
-		el->el_search.patlen = tmplen;
-	}
-	el->el_state.lastcmd = (el_action_t) dir;	/* avoid c_setpat */
-	el->el_line.cursor = el->el_line.lastchar = el->el_line.buffer;
-	if ((dir == ED_SEARCH_PREV_HISTORY ? ed_search_prev_history(el, 0) :
-		ed_search_next_history(el, 0)) == CC_ERROR) {
-		re_refresh(el);
-		return (CC_ERROR);
-	} else {
-		if (ch == 0033) {
-			re_refresh(el);
-			*el->el_line.lastchar++ = '\n';
-			*el->el_line.lastchar = '\0';
-			re_goto_bottom(el);
-			return (CC_NEWLINE);
-		} else
-			return (CC_REFRESH);
-	}
-}
-
-
-/* ce_search_line():
- *	Look for a pattern inside a line
- */
-protected el_action_t
-ce_search_line(EditLine *el, char *pattern, int dir)
-{
-	char *cp;
-
-	if (dir == ED_SEARCH_PREV_HISTORY) {
-		for (cp = el->el_line.cursor; cp >= el->el_line.buffer; cp--)
-			if (el_match(cp, pattern)) {
-				el->el_line.cursor = cp;
-				return (CC_NORM);
-			}
-		return (CC_ERROR);
-	} else {
-		for (cp = el->el_line.cursor; *cp != '\0' &&
-		    cp < el->el_line.limit; cp++)
-			if (el_match(cp, pattern)) {
-				el->el_line.cursor = cp;
-				return (CC_NORM);
-			}
-		return (CC_ERROR);
-	}
-}
-
-
-/* cv_repeat_srch():
- *	Vi repeat search
- */
-protected el_action_t
-cv_repeat_srch(EditLine *el, int c)
-{
-
-#ifdef SDEBUG
-	(void) fprintf(el->el_errfile, "dir %d patlen %d patbuf %s\n",
-	    c, el->el_search.patlen, el->el_search.patbuf);
-#endif
-
-	el->el_state.lastcmd = (el_action_t) c;	/* Hack to stop c_setpat */
-	el->el_line.lastchar = el->el_line.buffer;
-
-	switch (c) {
-	case ED_SEARCH_NEXT_HISTORY:
-		return (ed_search_next_history(el, 0));
-	case ED_SEARCH_PREV_HISTORY:
-		return (ed_search_prev_history(el, 0));
-	default:
-		return (CC_ERROR);
-	}
-}
-
-
-/* cv_csearch_back():
- *	Vi character search reverse
- */
-protected el_action_t
-cv_csearch_back(EditLine *el, int ch, int count, int tflag)
-{
-	char *cp;
-
-	cp = el->el_line.cursor;
-	while (count--) {
-		if (*cp == ch)
-			cp--;
-		while (cp > el->el_line.buffer && *cp != ch)
-			cp--;
-	}
-
-	if (cp < el->el_line.buffer || (cp == el->el_line.buffer && *cp != ch))
-		return (CC_ERROR);
-
-	if (*cp == ch && tflag)
-		cp++;
-
-	el->el_line.cursor = cp;
-
-	if (el->el_chared.c_vcmd.action & DELETE) {
-		el->el_line.cursor++;
-		cv_delfini(el);
-		return (CC_REFRESH);
-	}
-	re_refresh_cursor(el);
-	return (CC_NORM);
-}
-
-
-/* cv_csearch_fwd():
- *	Vi character search forward
- */
-protected el_action_t
-cv_csearch_fwd(EditLine *el, int ch, int count, int tflag)
-{
-	char *cp;
-
-	cp = el->el_line.cursor;
-	while (count--) {
-		if (*cp == ch)
-			cp++;
-		while (cp < el->el_line.lastchar && *cp != ch)
-			cp++;
-	}
-
-	if (cp >= el->el_line.lastchar)
-		return (CC_ERROR);
-
-	if (*cp == ch && tflag)
-		cp--;
-
-	el->el_line.cursor = cp;
-
-	if (el->el_chared.c_vcmd.action & DELETE) {
-		el->el_line.cursor++;
-		cv_delfini(el);
-		return (CC_REFRESH);
-	}
-	re_refresh_cursor(el);
-	return (CC_NORM);
-}
diff --git a/main/editline/search.h b/main/editline/search.h
deleted file mode 100644
index 676bbe2..0000000
--- a/main/editline/search.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*	$NetBSD: search.h,v 1.5 2000/09/04 22:06:32 lukem Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)search.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.search.h: Line and history searching utilities
- */
-#ifndef _h_el_search
-#define	_h_el_search
-
-#include "histedit.h"
-
-typedef struct el_search_t {
-	char	*patbuf;		/* The pattern buffer		*/
-	size_t	 patlen;		/* Length of the pattern buffer	*/
-	int	 patdir;		/* Direction of the last search	*/
-	int	 chadir;		/* Character search direction	*/
-	char	 chacha;		/* Character we are looking for	*/
-} el_search_t;
-
-
-protected int		el_match(const char *, const char *);
-protected int		search_init(EditLine *);
-protected void		search_end(EditLine *);
-protected int		c_hmatch(EditLine *, const char *);
-protected void		c_setpat(EditLine *);
-protected el_action_t	ce_inc_search(EditLine *, int);
-protected el_action_t	cv_search(EditLine *, int);
-protected el_action_t	ce_search_line(EditLine *, char *, int);
-protected el_action_t	cv_repeat_srch(EditLine *, int);
-protected el_action_t	cv_csearch_back(EditLine *, int, int, int);
-protected el_action_t	cv_csearch_fwd(EditLine *, int, int, int);
-
-#endif /* _h_el_search */
diff --git a/main/editline/sig.c b/main/editline/sig.c
deleted file mode 100644
index 0acba12..0000000
--- a/main/editline/sig.c
+++ /dev/null
@@ -1,198 +0,0 @@
-/*	$NetBSD: sig.c,v 1.9 2002/03/18 16:00:58 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)sig.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: sig.c,v 1.9 2002/03/18 16:00:58 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * sig.c: Signal handling stuff.
- *	  our policy is to trap all signals, set a good state
- *	  and pass the ball to our caller.
- */
-#include "el.h"
-#include <stdlib.h>
-
-private EditLine *sel = NULL;
-
-private const int sighdl[] = {
-#define	_DO(a)	(a),
-	ALLSIGS
-#undef	_DO
-	- 1
-};
-
-private void sig_handler(int);
-
-/* sig_handler():
- *	This is the handler called for all signals
- *	XXX: we cannot pass any data so we just store the old editline
- *	state in a private variable
- */
-private void
-sig_handler(int signo)
-{
-	int i;
-	sigset_t nset, oset;
-
-	(void) sigemptyset(&nset);
-	(void) sigaddset(&nset, signo);
-	(void) sigprocmask(SIG_BLOCK, &nset, &oset);
-
-	switch (signo) {
-	case SIGCONT:
-		tty_rawmode(sel);
-		if (ed_redisplay(sel, 0) == CC_REFRESH)
-			re_refresh(sel);
-		term__flush();
-		break;
-
-	case SIGWINCH:
-		el_resize(sel);
-		break;
-
-	default:
-		tty_cookedmode(sel);
-		break;
-	}
-
-	for (i = 0; sighdl[i] != -1; i++)
-		if (signo == sighdl[i])
-			break;
-
-	(void) signal(signo, sel->el_signal[i]);
-	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
-	(void) kill(0, signo);
-}
-
-
-/* sig_init():
- *	Initialize all signal stuff
- */
-protected int
-sig_init(EditLine *el)
-{
-	int i;
-	sigset_t nset, oset;
-
-	(void) sigemptyset(&nset);
-#define	_DO(a) (void) sigaddset(&nset, a);
-	ALLSIGS
-#undef	_DO
-	    (void) sigprocmask(SIG_BLOCK, &nset, &oset);
-
-#define	SIGSIZE (sizeof(sighdl) / sizeof(sighdl[0]) * sizeof(sig_t))
-
-	el->el_signal = (sig_t *) el_malloc(SIGSIZE);
-	if (el->el_signal == NULL)
-		return (-1);
-	for (i = 0; sighdl[i] != -1; i++)
-		el->el_signal[i] = SIG_ERR;
-
-	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
-
-	return (0);
-}
-
-
-/* sig_end():
- *	Clear all signal stuff
- */
-protected void
-sig_end(EditLine *el)
-{
-
-	el_free((ptr_t) el->el_signal);
-	el->el_signal = NULL;
-}
-
-
-/* sig_set():
- *	set all the signal handlers
- */
-protected void
-sig_set(EditLine *el)
-{
-	int i;
-	sigset_t nset, oset;
-
-	(void) sigemptyset(&nset);
-#define	_DO(a) (void) sigaddset(&nset, a);
-	ALLSIGS
-#undef	_DO
-	    (void) sigprocmask(SIG_BLOCK, &nset, &oset);
-
-	for (i = 0; sighdl[i] != -1; i++) {
-		sig_t s;
-		/* This could happen if we get interrupted */
-		if ((s = signal(sighdl[i], sig_handler)) != sig_handler)
-			el->el_signal[i] = s;
-	}
-	sel = el;
-	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
-}
-
-
-/* sig_clr():
- *	clear all the signal handlers
- */
-protected void
-sig_clr(EditLine *el)
-{
-	int i;
-	sigset_t nset, oset;
-
-	(void) sigemptyset(&nset);
-#define	_DO(a) (void) sigaddset(&nset, a);
-	ALLSIGS
-#undef	_DO
-	    (void) sigprocmask(SIG_BLOCK, &nset, &oset);
-
-	for (i = 0; sighdl[i] != -1; i++)
-		if (el->el_signal[i] != SIG_ERR)
-			(void) signal(sighdl[i], el->el_signal[i]);
-
-	sel = NULL;		/* we are going to die if the handler is
-				 * called */
-	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
-}
diff --git a/main/editline/sig.h b/main/editline/sig.h
deleted file mode 100644
index e7231b6..0000000
--- a/main/editline/sig.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*	$NetBSD: sig.h,v 1.3 2000/09/04 22:06:32 lukem Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)sig.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.sig.h: Signal handling functions
- */
-#ifndef _h_el_sig
-#define	_h_el_sig
-
-#include <signal.h>
-
-#include "histedit.h"
-
-/*
- * Define here all the signals we are going to handle
- * The _DO macro is used to iterate in the source code
- */
-#define	ALLSIGS		\
-	_DO(SIGINT)	\
-	_DO(SIGTSTP)	\
-	_DO(SIGSTOP)	\
-	_DO(SIGQUIT)	\
-	_DO(SIGHUP)	\
-	_DO(SIGTERM)	\
-	_DO(SIGCONT)	\
-	_DO(SIGWINCH)
-
-typedef sig_t	*el_signal_t;
-
-protected void	sig_end(EditLine*);
-protected int	sig_init(EditLine*);
-protected void	sig_set(EditLine*);
-protected void	sig_clr(EditLine*);
-
-#endif /* _h_el_sig */
diff --git a/main/editline/sys.h b/main/editline/sys.h
deleted file mode 100644
index 80feb57..0000000
--- a/main/editline/sys.h
+++ /dev/null
@@ -1,135 +0,0 @@
-/*	$NetBSD: sys.h,v 1.5 2002/03/18 16:00:59 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)sys.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * sys.h: Put all the stupid compiler and system dependencies here...
- */
-#ifndef _h_sys
-#define	_h_sys
-
-#ifndef public
-# define public		/* Externally visible functions/variables */
-#endif
-
-#ifndef private
-# define private	static	/* Always hidden internals */
-#endif
-
-#ifndef protected
-# define protected	/* Redefined from elsewhere to "static" */
-			/* When we want to hide everything	*/
-#endif
-
-#ifndef _PTR_T
-# define _PTR_T
-typedef void	*ptr_t;
-#endif
-
-#ifndef _IOCTL_T
-# define _IOCTL_T
-typedef void	*ioctl_t;
-#endif
-
-#include <stdio.h>
-
-#ifndef HAVE_FGETLN
-#define	fgetln libedit_fgetln
-char	*fgetln(FILE *fp, size_t *len);
-#endif
-
-#ifndef HAVE_STRLCPY
-#undef strlcpy /* We define this in top-level Asterisk to point towards ast_copy_string */
-#define	strlcpy libedit_strlcpy
-size_t strlcpy(char *dst, const char *src, size_t siz);
-#endif
-
-#ifndef HAVE_STRLCAT
-#undef strlcat /* We define this in top-level Asterisk to point towards the ast_str_* APIs */
-#define	strlcat libedit_strlcat
-size_t strlcat(char *dst, const char *src, size_t siz);
-#endif
-
-#define	REGEX		/* Use POSIX.2 regular expression functions */
-#undef	REGEXP		/* Use UNIX V8 regular expression functions */
-
-#ifdef SUNOS
-# undef REGEX
-# undef REGEXP
-/* # include <malloc.h> XXX Removed for Solaris build XXX */
-typedef void (*sig_t)(int);
-# ifdef __GNUC__
-/*
- * Broken hdrs.
- */
-#ifndef SOLARIS
-extern int	tgetent(const char *bp, char *name);
-extern int	tgetflag(const char *id);
-extern int	tgetnum(const char *id);
-extern char    *tgetstr(const char *id, char **area);
-#endif
-extern char    *tgoto(const char *cap, int col, int row);
-extern int	tputs(const char *str, int affcnt, int (*putc)(int));
-extern char    *getenv(const char *);
-extern int	fprintf(FILE *, const char *, ...);
-extern int	sigsetmask(int);
-extern int	sigblock(int);
-extern int	fputc(int, FILE *);
-extern int	fgetc(FILE *);
-extern int	fflush(FILE *);
-extern int	tolower(int);
-extern int	toupper(int);
-extern int	errno, sys_nerr;
-extern char	*sys_errlist[];
-extern void	perror(const char *);
-#  include <string.h>
-#  define strerror(e)	sys_errlist[e]
-# endif
-# ifdef SABER
-extern ptr_t    memcpy(ptr_t, const ptr_t, size_t);
-extern ptr_t    memset(ptr_t, int, size_t);
-# endif
-extern char    *fgetline(FILE *, int *);
-#endif
-
-#ifdef HAVE_SYS_CDEFS_H
-#include <sys/cdefs.h>
-#endif
-
-#endif /* _h_sys */
diff --git a/main/editline/term.c b/main/editline/term.c
deleted file mode 100644
index fb627ca..0000000
--- a/main/editline/term.c
+++ /dev/null
@@ -1,1587 +0,0 @@
-/*	$NetBSD: term.c,v 1.35 2002/03/18 16:00:59 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)term.c	8.2 (Berkeley) 4/30/95";
-#else
-__RCSID("$NetBSD: term.c,v 1.35 2002/03/18 16:00:59 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * term.c: Editor/termcap-curses interface
- *	   We have to declare a static variable here, since the
- *	   termcap putchar routine does not take an argument!
- */
-#include <stdio.h>
-#include <signal.h>
-#include <string.h>
-#include <stdlib.h>
-#include <unistd.h>
-#ifdef HAVE_TERMCAP_H
-#include <termcap.h>
-#endif
-#ifdef HAVE_CURSES_H
-#include <curses.h>
-#endif
-#ifdef HAVE_NCURSES_H
-#include <ncurses.h>
-#endif
-#if defined(HAVE_TERM_H)
-#include "term.h"
-/* Can not use /usr/include/term.h because of a lot of incompatibilities, so just define some prototypes */
-extern int tgetent(char *, const char *);
-extern int tgetflag(const char *);
-extern int tgetnum(const char *);
-extern char *tgetstr(const char *, char **);
-extern int tputs (const char *, int, int (*)(int));
-extern char *tgoto (const char *, int, int);
-#endif /* defined(HAVE_TERM_H) */
-#include <sys/types.h>
-#include <sys/ioctl.h>
-
-#include "el.h"
-
-/*
- * IMPORTANT NOTE: these routines are allowed to look at the current screen
- * and the current possition assuming that it is correct.  If this is not
- * true, then the update will be WRONG!  This is (should be) a valid
- * assumption...
- */
-
-#define	TC_BUFSIZE	2048
-
-#define	GoodStr(a)	(el->el_term.t_str[a] != NULL && \
-			    el->el_term.t_str[a][0] != '\0')
-#define	Str(a)		el->el_term.t_str[a]
-#define	Val(a)		el->el_term.t_val[a]
-
-#ifdef notdef
-private const struct {
-	const char *b_name;
-	int b_rate;
-} baud_rate[] = {
-#ifdef B0
-	{ "0", B0 },
-#endif
-#ifdef B50
-	{ "50", B50 },
-#endif
-#ifdef B75
-	{ "75", B75 },
-#endif
-#ifdef B110
-	{ "110", B110 },
-#endif
-#ifdef B134
-	{ "134", B134 },
-#endif
-#ifdef B150
-	{ "150", B150 },
-#endif
-#ifdef B200
-	{ "200", B200 },
-#endif
-#ifdef B300
-	{ "300", B300 },
-#endif
-#ifdef B600
-	{ "600", B600 },
-#endif
-#ifdef B900
-	{ "900", B900 },
-#endif
-#ifdef B1200
-	{ "1200", B1200 },
-#endif
-#ifdef B1800
-	{ "1800", B1800 },
-#endif
-#ifdef B2400
-	{ "2400", B2400 },
-#endif
-#ifdef B3600
-	{ "3600", B3600 },
-#endif
-#ifdef B4800
-	{ "4800", B4800 },
-#endif
-#ifdef B7200
-	{ "7200", B7200 },
-#endif
-#ifdef B9600
-	{ "9600", B9600 },
-#endif
-#ifdef EXTA
-	{ "19200", EXTA },
-#endif
-#ifdef B19200
-	{ "19200", B19200 },
-#endif
-#ifdef EXTB
-	{ "38400", EXTB },
-#endif
-#ifdef B38400
-	{ "38400", B38400 },
-#endif
-	{ NULL, 0 }
-};
-#endif
-
-private const struct termcapstr {
-	const char *name;
-	const char *long_name;
-} tstr[] = {
-#define	T_al	0
-	{ "al", "add new blank line" },
-#define	T_bl	1
-	{ "bl", "audible bell" },
-#define	T_cd	2
-	{ "cd", "clear to bottom" },
-#define	T_ce	3
-	{ "ce", "clear to end of line" },
-#define	T_ch	4
-	{ "ch", "cursor to horiz pos" },
-#define	T_cl	5
-	{ "cl", "clear screen" },
-#define	T_dc	6
-	{ "dc", "delete a character" },
-#define	T_dl	7
-	{ "dl", "delete a line" },
-#define	T_dm	8
-	{ "dm", "start delete mode" },
-#define	T_ed	9
-	{ "ed", "end delete mode" },
-#define	T_ei	10
-	{ "ei", "end insert mode" },
-#define	T_fs	11
-	{ "fs", "cursor from status line" },
-#define	T_ho	12
-	{ "ho", "home cursor" },
-#define	T_ic	13
-	{ "ic", "insert character" },
-#define	T_im	14
-	{ "im", "start insert mode" },
-#define	T_ip	15
-	{ "ip", "insert padding" },
-#define	T_kd	16
-	{ "kd", "sends cursor down" },
-#define	T_kl	17
-	{ "kl", "sends cursor left" },
-#define	T_kr	18
-	{ "kr", "sends cursor right" },
-#define	T_ku	19
-	{ "ku", "sends cursor up" },
-#define	T_md	20
-	{ "md", "begin bold" },
-#define	T_me	21
-	{ "me", "end attributes" },
-#define	T_nd	22
-	{ "nd", "non destructive space" },
-#define	T_se	23
-	{ "se", "end standout" },
-#define	T_so	24
-	{ "so", "begin standout" },
-#define	T_ts	25
-	{ "ts", "cursor to status line" },
-#define	T_up	26
-	{ "up", "cursor up one" },
-#define	T_us	27
-	{ "us", "begin underline" },
-#define	T_ue	28
-	{ "ue", "end underline" },
-#define	T_vb	29
-	{ "vb", "visible bell" },
-#define	T_DC	30
-	{ "DC", "delete multiple chars" },
-#define	T_DO	31
-	{ "DO", "cursor down multiple" },
-#define	T_IC	32
-	{ "IC", "insert multiple chars" },
-#define	T_LE	33
-	{ "LE", "cursor left multiple" },
-#define	T_RI	34
-	{ "RI", "cursor right multiple" },
-#define	T_UP	35
-	{ "UP", "cursor up multiple" },
-#define	T_kh	36
-	{ "kh", "send cursor home" },
-#define	T_at7	37
-	{ "@7", "send cursor end" },
-#define	T_str	38
-	{ NULL, NULL }
-};
-
-private const struct termcapval {
-	const char *name;
-	const char *long_name;
-} tval[] = {
-#define	T_am	0
-	{ "am", "has automatic margins" },
-#define	T_pt	1
-	{ "pt", "has physical tabs" },
-#define	T_li	2
-	{ "li", "Number of lines" },
-#define	T_co	3
-	{ "co", "Number of columns" },
-#define	T_km	4
-	{ "km", "Has meta key" },
-#define	T_xt	5
-	{ "xt", "Tab chars destructive" },
-#define	T_xn	6
-	{ "xn", "newline ignored at right margin" },
-#define	T_MT	7
-	{ "MT", "Has meta key" },			/* XXX? */
-#define	T_val	8
-	{ NULL, NULL, }
-};
-/* do two or more of the attributes use me */
-
-private void	term_setflags(EditLine *);
-private int	term_rebuffer_display(EditLine *);
-private void	term_free_display(EditLine *);
-private int	term_alloc_display(EditLine *);
-private void	term_alloc(EditLine *, const struct termcapstr *, const char *);
-private void	term_init_arrow(EditLine *);
-private void	term_reset_arrow(EditLine *);
-
-
-private FILE *term_outfile = NULL;	/* XXX: How do we fix that? */
-
-
-/* term_setflags():
- *	Set the terminal capability flags
- */
-private void
-term_setflags(EditLine *el)
-{
-	EL_FLAGS = 0;
-	if (el->el_tty.t_tabs)
-		EL_FLAGS |= (Val(T_pt) && !Val(T_xt)) ? TERM_CAN_TAB : 0;
-
-	EL_FLAGS |= (Val(T_km) || Val(T_MT)) ? TERM_HAS_META : 0;
-	EL_FLAGS |= GoodStr(T_ce) ? TERM_CAN_CEOL : 0;
-	EL_FLAGS |= (GoodStr(T_dc) || GoodStr(T_DC)) ? TERM_CAN_DELETE : 0;
-	EL_FLAGS |= (GoodStr(T_im) || GoodStr(T_ic) || GoodStr(T_IC)) ?
-	    TERM_CAN_INSERT : 0;
-	EL_FLAGS |= (GoodStr(T_up) || GoodStr(T_UP)) ? TERM_CAN_UP : 0;
-	EL_FLAGS |= Val(T_am) ? TERM_HAS_AUTO_MARGINS : 0;
-	EL_FLAGS |= Val(T_xn) ? TERM_HAS_MAGIC_MARGINS : 0;
-
-	if (GoodStr(T_me) && GoodStr(T_ue))
-		EL_FLAGS |= (strcmp(Str(T_me), Str(T_ue)) == 0) ?
-		    TERM_CAN_ME : 0;
-	else
-		EL_FLAGS &= ~TERM_CAN_ME;
-	if (GoodStr(T_me) && GoodStr(T_se))
-		EL_FLAGS |= (strcmp(Str(T_me), Str(T_se)) == 0) ?
-		    TERM_CAN_ME : 0;
-
-
-#ifdef DEBUG_SCREEN
-	if (!EL_CAN_UP) {
-		(void) fprintf(el->el_errfile,
-		    "WARNING: Your terminal cannot move up.\n");
-		(void) fprintf(el->el_errfile,
-		    "Editing may be odd for long lines.\n");
-	}
-	if (!EL_CAN_CEOL)
-		(void) fprintf(el->el_errfile, "no clear EOL capability.\n");
-	if (!EL_CAN_DELETE)
-		(void) fprintf(el->el_errfile, "no delete char capability.\n");
-	if (!EL_CAN_INSERT)
-		(void) fprintf(el->el_errfile, "no insert char capability.\n");
-#endif /* DEBUG_SCREEN */
-}
-
-
-/* term_init():
- *	Initialize the terminal stuff
- */
-protected int
-term_init(EditLine *el)
-{
-
-	el->el_term.t_buf = (char *) el_malloc(TC_BUFSIZE);
-	if (el->el_term.t_buf == NULL)
-		return (-1);
-	el->el_term.t_cap = (char *) el_malloc(TC_BUFSIZE);
-	if (el->el_term.t_cap == NULL)
-		return (-1);
-	el->el_term.t_fkey = (fkey_t *) el_malloc(A_K_NKEYS * sizeof(fkey_t));
-	if (el->el_term.t_fkey == NULL)
-		return (-1);
-	el->el_term.t_loc = 0;
-	el->el_term.t_str = (char **) el_malloc(T_str * sizeof(char *));
-	if (el->el_term.t_str == NULL)
-		return (-1);
-	(void) memset(el->el_term.t_str, 0, T_str * sizeof(char *));
-	el->el_term.t_val = (int *) el_malloc(T_val * sizeof(int));
-	if (el->el_term.t_val == NULL)
-		return (-1);
-	(void) memset(el->el_term.t_val, 0, T_val * sizeof(int));
-	term_outfile = el->el_outfile;
-	(void) term_set(el, NULL);
-	term_init_arrow(el);
-	return (0);
-}
-/* term_end():
- *	Clean up the terminal stuff
- */
-protected void
-term_end(EditLine *el)
-{
-
-	el_free((ptr_t) el->el_term.t_buf);
-	el->el_term.t_buf = NULL;
-	el_free((ptr_t) el->el_term.t_cap);
-	el->el_term.t_cap = NULL;
-	el_free((ptr_t) el->el_term.t_fkey);
-	el->el_term.t_fkey = NULL;
-	el->el_term.t_loc = 0;
-	el_free((ptr_t) el->el_term.t_str);
-	el->el_term.t_str = NULL;
-	el_free((ptr_t) el->el_term.t_val);
-	el->el_term.t_val = NULL;
-	term_free_display(el);
-}
-
-
-/* term_alloc():
- *	Maintain a string pool for termcap strings
- */
-private void
-term_alloc(EditLine *el, const struct termcapstr *t, const char *cap)
-{
-	char termbuf[TC_BUFSIZE];
-	int tlen, clen;
-	char **tlist = el->el_term.t_str;
-	char **tmp, **str = &tlist[t - tstr];
-
-	if (cap == NULL || *cap == '\0') {
-		*str = NULL;
-		return;
-	} else
-		clen = strlen(cap);
-
-	tlen = *str == NULL ? 0 : strlen(*str);
-
-	/*
-         * New string is shorter; no need to allocate space
-         */
-	if (clen <= tlen) {
-		(void) strcpy(*str, cap);	/* XXX strcpy is safe */
-		return;
-	}
-	/*
-         * New string is longer; see if we have enough space to append
-         */
-	if (el->el_term.t_loc + 3 < TC_BUFSIZE) {
-						/* XXX strcpy is safe */
-		(void) strcpy(*str = &el->el_term.t_buf[el->el_term.t_loc],
-		    cap);
-		el->el_term.t_loc += clen + 1;	/* one for \0 */
-		return;
-	}
-	/*
-         * Compact our buffer; no need to check compaction, cause we know it
-         * fits...
-         */
-	tlen = 0;
-	for (tmp = tlist; tmp < &tlist[T_str]; tmp++)
-		if (*tmp != NULL && *tmp != '\0' && *tmp != *str) {
-			char *ptr;
-
-			for (ptr = *tmp; *ptr != '\0'; termbuf[tlen++] = *ptr++)
-				continue;
-			termbuf[tlen++] = '\0';
-		}
-	memcpy(el->el_term.t_buf, termbuf, TC_BUFSIZE);
-	el->el_term.t_loc = tlen;
-	if (el->el_term.t_loc + 3 >= TC_BUFSIZE) {
-		(void) fprintf(el->el_errfile,
-		    "Out of termcap string space.\n");
-		return;
-	}
-					/* XXX strcpy is safe */
-	(void) strcpy(*str = &el->el_term.t_buf[el->el_term.t_loc], cap);
-	el->el_term.t_loc += clen + 1;	/* one for \0 */
-	return;
-}
-
-
-/* term_rebuffer_display():
- *	Rebuffer the display after the screen changed size
- */
-private int
-term_rebuffer_display(EditLine *el)
-{
-	coord_t *c = &el->el_term.t_size;
-
-	term_free_display(el);
-
-	c->h = Val(T_co);
-	c->v = Val(T_li);
-
-	if (term_alloc_display(el) == -1)
-		return (-1);
-	return (0);
-}
-
-
-/* term_alloc_display():
- *	Allocate a new display.
- */
-private int
-term_alloc_display(EditLine *el)
-{
-	int i;
-	char **b;
-	coord_t *c = &el->el_term.t_size;
-
-	b = (char **) el_malloc((size_t) (sizeof(char *) * (c->v + 1)));
-	if (b == NULL)
-		return (-1);
-	for (i = 0; i < c->v; i++) {
-		b[i] = (char *) el_malloc((size_t) (sizeof(char) * (c->h + 1)));
-		if (b[i] == NULL)
-			return (-1);
-	}
-	b[c->v] = NULL;
-	el->el_display = b;
-
-	b = (char **) el_malloc((size_t) (sizeof(char *) * (c->v + 1)));
-	if (b == NULL)
-		return (-1);
-	for (i = 0; i < c->v; i++) {
-		b[i] = (char *) el_malloc((size_t) (sizeof(char) * (c->h + 1)));
-		if (b[i] == NULL)
-			return (-1);
-	}
-	b[c->v] = NULL;
-	el->el_vdisplay = b;
-	return (0);
-}
-
-
-/* term_free_display():
- *	Free the display buffers
- */
-private void
-term_free_display(EditLine *el)
-{
-	char **b;
-	char **bufp;
-
-	b = el->el_display;
-	el->el_display = NULL;
-	if (b != NULL) {
-		for (bufp = b; *bufp != NULL; bufp++)
-			el_free((ptr_t) * bufp);
-		el_free((ptr_t) b);
-	}
-	b = el->el_vdisplay;
-	el->el_vdisplay = NULL;
-	if (b != NULL) {
-		for (bufp = b; *bufp != NULL; bufp++)
-			el_free((ptr_t) * bufp);
-		el_free((ptr_t) b);
-	}
-}
-
-
-/* term_move_to_line():
- *	move to line <where> (first line == 0)
- * 	as efficiently as possible
- */
-protected void
-term_move_to_line(EditLine *el, int where)
-{
-	int del;
-
-	if (where == el->el_cursor.v)
-		return;
-
-	if (where > el->el_term.t_size.v) {
-#ifdef DEBUG_SCREEN
-		(void) fprintf(el->el_errfile,
-		    "term_move_to_line: where is ridiculous: %d\r\n", where);
-#endif /* DEBUG_SCREEN */
-		return;
-	}
-	if ((del = where - el->el_cursor.v) > 0) {
-		while (del > 0) {
-			if (EL_HAS_AUTO_MARGINS &&
-			    el->el_display[el->el_cursor.v][0] != '\0') {
-				/* move without newline */
-				term_move_to_char(el, el->el_term.t_size.h - 1);
-				term_overwrite(el,
-				    &el->el_display[el->el_cursor.v][el->el_cursor.h],
-				    1);
-				/* updates Cursor */
-				del--;
-			} else {
-				if ((del > 1) && GoodStr(T_DO)) {
-					(void) tputs(tgoto(Str(T_DO), del, del),
-					    del, term__putc);
-					del = 0;
-				} else {
-					for (; del > 0; del--)
-						term__putc('\n');
-					/* because the \n will become \r\n */
-					el->el_cursor.h = 0;
-				}
-			}
-		}
-	} else {		/* del < 0 */
-		if (GoodStr(T_UP) && (-del > 1 || !GoodStr(T_up)))
-			(void) tputs(tgoto(Str(T_UP), -del, -del), -del,
-			    term__putc);
-		else {
-			if (GoodStr(T_up))
-				for (; del < 0; del++)
-					(void) tputs(Str(T_up), 1, term__putc);
-		}
-	}
-	el->el_cursor.v = where;/* now where is here */
-}
-
-
-/* term_move_to_char():
- *	Move to the character position specified
- */
-protected void
-term_move_to_char(EditLine *el, int where)
-{
-	int del, i;
-
-mc_again:
-	if (where == el->el_cursor.h)
-		return;
-
-	if (where > el->el_term.t_size.h) {
-#ifdef DEBUG_SCREEN
-		(void) fprintf(el->el_errfile,
-		    "term_move_to_char: where is riduculous: %d\r\n", where);
-#endif /* DEBUG_SCREEN */
-		return;
-	}
-	if (!where) {		/* if where is first column */
-		term__putc('\r');	/* do a CR */
-		el->el_cursor.h = 0;
-		return;
-	}
-	del = where - el->el_cursor.h;
-
-	if ((del < -4 || del > 4) && GoodStr(T_ch))
-		/* go there directly */
-		(void) tputs(tgoto(Str(T_ch), where, where), where, term__putc);
-	else {
-		if (del > 0) {	/* moving forward */
-			if ((del > 4) && GoodStr(T_RI))
-				(void) tputs(tgoto(Str(T_RI), del, del),
-				    del, term__putc);
-			else {
-					/* if I can do tabs, use them */
-				if (EL_CAN_TAB) {
-					if ((el->el_cursor.h & 0370) !=
-					    (where & 0370)) {
-						/* if not within tab stop */
-						for (i =
-						    (el->el_cursor.h & 0370);
-						    i < (where & 0370);
-						    i += 8)
-							term__putc('\t');	
-							/* then tab over */
-						el->el_cursor.h = where & 0370;
-					}
-				}
-				/*
-				 * it's usually cheaper to just write the
-				 * chars, so we do.
-				 */
-				/*
-				 * NOTE THAT term_overwrite() WILL CHANGE
-				 * el->el_cursor.h!!!
-				 */
-				term_overwrite(el,
-				    &el->el_display[el->el_cursor.v][el->el_cursor.h],
-				    where - el->el_cursor.h);
-
-			}
-		} else {	/* del < 0 := moving backward */
-			if ((-del > 4) && GoodStr(T_LE))
-				(void) tputs(tgoto(Str(T_LE), -del, -del),
-				    -del, term__putc);
-			else {	/* can't go directly there */
-				/*
-				 * if the "cost" is greater than the "cost"
-				 * from col 0
-				 */
-				if (EL_CAN_TAB ?
-				    (-del > (((unsigned int) where >> 3) +
-				     (where & 07)))
-				    : (-del > where)) {
-					term__putc('\r');	/* do a CR */
-					el->el_cursor.h = 0;
-					goto mc_again;	/* and try again */
-				}
-				for (i = 0; i < -del; i++)
-					term__putc('\b');
-			}
-		}
-	}
-	el->el_cursor.h = where;		/* now where is here */
-}
-
-
-/* term_overwrite():
- *	Overstrike num characters
- */
-protected void
-term_overwrite(EditLine *el, const char *cp, int n)
-{
-	if (n <= 0)
-		return;		/* catch bugs */
-
-	if (n > el->el_term.t_size.h) {
-#ifdef DEBUG_SCREEN
-		(void) fprintf(el->el_errfile,
-		    "term_overwrite: n is riduculous: %d\r\n", n);
-#endif /* DEBUG_SCREEN */
-		return;
-	}
-	do {
-		term__putc(*cp++);
-		el->el_cursor.h++;
-	} while (--n);
-
-	if (el->el_cursor.h >= el->el_term.t_size.h) {	/* wrap? */
-		if (EL_HAS_AUTO_MARGINS) {	/* yes */
-			el->el_cursor.h = 0;
-			el->el_cursor.v++;
-			if (EL_HAS_MAGIC_MARGINS) {
-				/* force the wrap to avoid the "magic"
-				 * situation */
-				char c;
-				if ((c = el->el_display[el->el_cursor.v][el->el_cursor.h])
-				    != '\0')
-					term_overwrite(el, &c, 1);
-				else
-					term__putc(' ');
-				el->el_cursor.h = 1;
-			}
-		} else		/* no wrap, but cursor stays on screen */
-			el->el_cursor.h = el->el_term.t_size.h;
-	}
-}
-
-
-/* term_deletechars():
- *	Delete num characters
- */
-protected void
-term_deletechars(EditLine *el, int num)
-{
-	if (num <= 0)
-		return;
-
-	if (!EL_CAN_DELETE) {
-#ifdef DEBUG_EDIT
-		(void) fprintf(el->el_errfile, "   ERROR: cannot delete   \n");
-#endif /* DEBUG_EDIT */
-		return;
-	}
-	if (num > el->el_term.t_size.h) {
-#ifdef DEBUG_SCREEN
-		(void) fprintf(el->el_errfile,
-		    "term_deletechars: num is riduculous: %d\r\n", num);
-#endif /* DEBUG_SCREEN */
-		return;
-	}
-	if (GoodStr(T_DC))	/* if I have multiple delete */
-		if ((num > 1) || !GoodStr(T_dc)) {	/* if dc would be more
-							 * expen. */
-			(void) tputs(tgoto(Str(T_DC), num, num),
-			    num, term__putc);
-			return;
-		}
-	if (GoodStr(T_dm))	/* if I have delete mode */
-		(void) tputs(Str(T_dm), 1, term__putc);
-
-	if (GoodStr(T_dc))	/* else do one at a time */
-		while (num--)
-			(void) tputs(Str(T_dc), 1, term__putc);
-
-	if (GoodStr(T_ed))	/* if I have delete mode */
-		(void) tputs(Str(T_ed), 1, term__putc);
-}
-
-
-/* term_insertwrite():
- *	Puts terminal in insert character mode or inserts num
- *	characters in the line
- */
-protected void
-term_insertwrite(EditLine *el, char *cp, int num)
-{
-	if (num <= 0)
-		return;
-	if (!EL_CAN_INSERT) {
-#ifdef DEBUG_EDIT
-		(void) fprintf(el->el_errfile, "   ERROR: cannot insert   \n");
-#endif /* DEBUG_EDIT */
-		return;
-	}
-	if (num > el->el_term.t_size.h) {
-#ifdef DEBUG_SCREEN
-		(void) fprintf(el->el_errfile,
-		    "StartInsert: num is riduculous: %d\r\n", num);
-#endif /* DEBUG_SCREEN */
-		return;
-	}
-	if (GoodStr(T_IC))	/* if I have multiple insert */
-		if ((num > 1) || !GoodStr(T_ic)) {
-				/* if ic would be more expensive */
-			(void) tputs(tgoto(Str(T_IC), num, num),
-			    num, term__putc);
-			term_overwrite(el, cp, num);
-				/* this updates el_cursor.h */
-			return;
-		}
-	if (GoodStr(T_im) && GoodStr(T_ei)) {	/* if I have insert mode */
-		(void) tputs(Str(T_im), 1, term__putc);
-
-		el->el_cursor.h += num;
-		do
-			term__putc(*cp++);
-		while (--num);
-
-		if (GoodStr(T_ip))	/* have to make num chars insert */
-			(void) tputs(Str(T_ip), 1, term__putc);
-
-		(void) tputs(Str(T_ei), 1, term__putc);
-		return;
-	}
-	do {
-		if (GoodStr(T_ic))	/* have to make num chars insert */
-			(void) tputs(Str(T_ic), 1, term__putc);
-					/* insert a char */
-
-		term__putc(*cp++);
-
-		el->el_cursor.h++;
-
-		if (GoodStr(T_ip))	/* have to make num chars insert */
-			(void) tputs(Str(T_ip), 1, term__putc);
-					/* pad the inserted char */
-
-	} while (--num);
-}
-
-
-/* term_clear_EOL():
- *	clear to end of line.  There are num characters to clear
- */
-protected void
-term_clear_EOL(EditLine *el, int num)
-{
-	int i;
-
-	if (EL_CAN_CEOL && GoodStr(T_ce))
-		(void) tputs(Str(T_ce), 1, term__putc);
-	else {
-		for (i = 0; i < num; i++)
-			term__putc(' ');
-		el->el_cursor.h += num;	/* have written num spaces */
-	}
-}
-
-
-/* term_clear_screen():
- *	Clear the screen
- */
-protected void
-term_clear_screen(EditLine *el)
-{				/* clear the whole screen and home */
-
-	if (GoodStr(T_cl))
-		/* send the clear screen code */
-		(void) tputs(Str(T_cl), Val(T_li), term__putc);
-	else if (GoodStr(T_ho) && GoodStr(T_cd)) {
-		(void) tputs(Str(T_ho), Val(T_li), term__putc);	/* home */
-		/* clear to bottom of screen */
-		(void) tputs(Str(T_cd), Val(T_li), term__putc);
-	} else {
-		term__putc('\r');
-		term__putc('\n');
-	}
-}
-
-
-/* term_beep():
- *	Beep the way the terminal wants us
- */
-protected void
-term_beep(EditLine *el)
-{
-	if (GoodStr(T_bl))
-		/* what termcap says we should use */
-		(void) tputs(Str(T_bl), 1, term__putc);
-	else
-		term__putc('\007');	/* an ASCII bell; ^G */
-}
-
-
-#ifdef notdef
-/* term_clear_to_bottom():
- *	Clear to the bottom of the screen
- */
-protected void
-term_clear_to_bottom(EditLine *el)
-{
-	if (GoodStr(T_cd))
-		(void) tputs(Str(T_cd), Val(T_li), term__putc);
-	else if (GoodStr(T_ce))
-		(void) tputs(Str(T_ce), Val(T_li), term__putc);
-}
-#endif
-
-
-/* term_set():
- *	Read in the terminal capabilities from the requested terminal
- */
-protected int
-term_set(EditLine *el, const char *term)
-{
-	int i;
-	char buf[TC_BUFSIZE];
-	char *area;
-	const struct termcapstr *t;
-	sigset_t oset, nset;
-	int lins, cols;
-
-	(void) sigemptyset(&nset);
-	(void) sigaddset(&nset, SIGWINCH);
-	(void) sigprocmask(SIG_BLOCK, &nset, &oset);
-
-	area = buf;
-
-
-	if (term == NULL)
-		term = getenv("TERM");
-
-	if (!term || !term[0])
-		term = "dumb";
-
-	if (strcmp(term, "emacs") == 0)
-		el->el_flags |= EDIT_DISABLED;
-
-	memset(el->el_term.t_cap, 0, TC_BUFSIZE);
-
-	i = tgetent(el->el_term.t_cap, term);
-
-	if (i <= 0) {
-		if (i == -1)
-			(void) fprintf(el->el_errfile,
-			    "Cannot read termcap database;\n");
-		else if (i == 0)
-			(void) fprintf(el->el_errfile,
-			    "No entry for terminal type \"%s\";\n", term);
-		(void) fprintf(el->el_errfile,
-		    "using dumb terminal settings.\n");
-		Val(T_co) = 80;	/* do a dumb terminal */
-		Val(T_pt) = Val(T_km) = Val(T_li) = 0;
-		Val(T_xt) = Val(T_MT);
-		for (t = tstr; t->name != NULL; t++)
-			term_alloc(el, t, NULL);
-	} else {
-		/* auto/magic margins */
-		Val(T_am) = tgetflag("am");
-		Val(T_xn) = tgetflag("xn");
-		/* Can we tab */
-		Val(T_pt) = tgetflag("pt");
-		Val(T_xt) = tgetflag("xt");
-		/* do we have a meta? */
-		Val(T_km) = tgetflag("km");
-		Val(T_MT) = tgetflag("MT");
-		/* Get the size */
-		Val(T_co) = tgetnum("co");
-		Val(T_li) = tgetnum("li");
-		for (t = tstr; t->name != NULL; t++)
-			term_alloc(el, t, tgetstr((char *)t->name, &area));
-	}
-
-	if (Val(T_co) < 2)
-		Val(T_co) = 80;	/* just in case */
-	if (Val(T_li) < 1)
-		Val(T_li) = 24;
-
-	el->el_term.t_size.v = Val(T_co);
-	el->el_term.t_size.h = Val(T_li);
-
-	term_setflags(el);
-
-				/* get the correct window size */
-	(void) term_get_size(el, &lins, &cols);
-	if (term_change_size(el, lins, cols) == -1)
-		return (-1);
-	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
-	term_bind_arrow(el);
-	return (i <= 0 ? -1 : 0);
-}
-
-
-/* term_get_size():
- *	Return the new window size in lines and cols, and
- *	true if the size was changed.
- */
-protected int
-term_get_size(EditLine *el, int *lins, int *cols)
-{
-
-	*cols = Val(T_co);
-	*lins = Val(T_li);
-
-#ifdef TIOCGWINSZ
-	{
-		struct winsize ws;
-		if (ioctl(el->el_infd, TIOCGWINSZ, (ioctl_t) & ws) != -1) {
-			if (ws.ws_col)
-				*cols = ws.ws_col;
-			if (ws.ws_row)
-				*lins = ws.ws_row;
-		}
-	}
-#endif
-#ifdef TIOCGSIZE
-	{
-		struct ttysize ts;
-		if (ioctl(el->el_infd, TIOCGSIZE, (ioctl_t) & ts) != -1) {
-			if (ts.ts_cols)
-				*cols = ts.ts_cols;
-			if (ts.ts_lines)
-				*lins = ts.ts_lines;
-		}
-	}
-#endif
-	return (Val(T_co) != *cols || Val(T_li) != *lins);
-}
-
-
-/* term_change_size():
- *	Change the size of the terminal
- */
-protected int
-term_change_size(EditLine *el, int lins, int cols)
-{
-	/*
-         * Just in case
-         */
-	Val(T_co) = (cols < 2) ? 80 : cols;
-	Val(T_li) = (lins < 1) ? 24 : lins;
-
-	/* re-make display buffers */
-	if (term_rebuffer_display(el) == -1)
-		return (-1);
-	re_clear_display(el);
-	return (0);
-}
-
-
-/* term_init_arrow():
- *	Initialize the arrow key bindings from termcap
- */
-private void
-term_init_arrow(EditLine *el)
-{
-	fkey_t *arrow = el->el_term.t_fkey;
-
-	arrow[A_K_DN].name = "down";
-	arrow[A_K_DN].key = T_kd;
-	arrow[A_K_DN].fun.cmd = ED_NEXT_HISTORY;
-	arrow[A_K_DN].type = XK_CMD;
-
-	arrow[A_K_UP].name = "up";
-	arrow[A_K_UP].key = T_ku;
-	arrow[A_K_UP].fun.cmd = ED_PREV_HISTORY;
-	arrow[A_K_UP].type = XK_CMD;
-
-	arrow[A_K_LT].name = "left";
-	arrow[A_K_LT].key = T_kl;
-	arrow[A_K_LT].fun.cmd = ED_PREV_CHAR;
-	arrow[A_K_LT].type = XK_CMD;
-
-	arrow[A_K_RT].name = "right";
-	arrow[A_K_RT].key = T_kr;
-	arrow[A_K_RT].fun.cmd = ED_NEXT_CHAR;
-	arrow[A_K_RT].type = XK_CMD;
-
-	arrow[A_K_HO].name = "home";
-	arrow[A_K_HO].key = T_kh;
-	arrow[A_K_HO].fun.cmd = ED_MOVE_TO_BEG;
-	arrow[A_K_HO].type = XK_CMD;
-
-	arrow[A_K_EN].name = "end";
-	arrow[A_K_EN].key = T_at7;
-	arrow[A_K_EN].fun.cmd = ED_MOVE_TO_END;
-	arrow[A_K_EN].type = XK_CMD;
-}
-
-
-/* term_reset_arrow():
- *	Reset arrow key bindings
- */
-private void
-term_reset_arrow(EditLine *el)
-{
-	fkey_t *arrow = el->el_term.t_fkey;
-	static const char strA[] = {033, '[', 'A', '\0'};
-	static const char strB[] = {033, '[', 'B', '\0'};
-	static const char strC[] = {033, '[', 'C', '\0'};
-	static const char strD[] = {033, '[', 'D', '\0'};
-	static const char strH[] = {033, '[', 'H', '\0'};
-	static const char strF[] = {033, '[', 'F', '\0'};
-	static const char stOA[] = {033, 'O', 'A', '\0'};
-	static const char stOB[] = {033, 'O', 'B', '\0'};
-	static const char stOC[] = {033, 'O', 'C', '\0'};
-	static const char stOD[] = {033, 'O', 'D', '\0'};
-	static const char stOH[] = {033, 'O', 'H', '\0'};
-	static const char stOF[] = {033, 'O', 'F', '\0'};
-
-	key_add(el, strA, &arrow[A_K_UP].fun, arrow[A_K_UP].type);
-	key_add(el, strB, &arrow[A_K_DN].fun, arrow[A_K_DN].type);
-	key_add(el, strC, &arrow[A_K_RT].fun, arrow[A_K_RT].type);
-	key_add(el, strD, &arrow[A_K_LT].fun, arrow[A_K_LT].type);
-	key_add(el, strH, &arrow[A_K_HO].fun, arrow[A_K_HO].type);
-	key_add(el, strF, &arrow[A_K_EN].fun, arrow[A_K_EN].type);
-	key_add(el, stOA, &arrow[A_K_UP].fun, arrow[A_K_UP].type);
-	key_add(el, stOB, &arrow[A_K_DN].fun, arrow[A_K_DN].type);
-	key_add(el, stOC, &arrow[A_K_RT].fun, arrow[A_K_RT].type);
-	key_add(el, stOD, &arrow[A_K_LT].fun, arrow[A_K_LT].type);
-	key_add(el, stOH, &arrow[A_K_HO].fun, arrow[A_K_HO].type);
-	key_add(el, stOF, &arrow[A_K_EN].fun, arrow[A_K_EN].type);
-
-	if (el->el_map.type == MAP_VI) {
-		key_add(el, &strA[1], &arrow[A_K_UP].fun, arrow[A_K_UP].type);
-		key_add(el, &strB[1], &arrow[A_K_DN].fun, arrow[A_K_DN].type);
-		key_add(el, &strC[1], &arrow[A_K_RT].fun, arrow[A_K_RT].type);
-		key_add(el, &strD[1], &arrow[A_K_LT].fun, arrow[A_K_LT].type);
-		key_add(el, &strH[1], &arrow[A_K_HO].fun, arrow[A_K_HO].type);
-		key_add(el, &strF[1], &arrow[A_K_EN].fun, arrow[A_K_EN].type);
-		key_add(el, &stOA[1], &arrow[A_K_UP].fun, arrow[A_K_UP].type);
-		key_add(el, &stOB[1], &arrow[A_K_DN].fun, arrow[A_K_DN].type);
-		key_add(el, &stOC[1], &arrow[A_K_RT].fun, arrow[A_K_RT].type);
-		key_add(el, &stOD[1], &arrow[A_K_LT].fun, arrow[A_K_LT].type);
-		key_add(el, &stOH[1], &arrow[A_K_HO].fun, arrow[A_K_HO].type);
-		key_add(el, &stOF[1], &arrow[A_K_EN].fun, arrow[A_K_EN].type);
-	}
-}
-
-
-/* term_set_arrow():
- *	Set an arrow key binding
- */
-protected int
-term_set_arrow(EditLine *el, const char *name, key_value_t *fun, int type)
-{
-	fkey_t *arrow = el->el_term.t_fkey;
-	int i;
-
-	for (i = 0; i < A_K_NKEYS; i++)
-		if (strcmp(name, arrow[i].name) == 0) {
-			arrow[i].fun = *fun;
-			arrow[i].type = type;
-			return (0);
-		}
-	return (-1);
-}
-
-
-/* term_clear_arrow():
- *	Clear an arrow key binding
- */
-protected int
-term_clear_arrow(EditLine *el, const char *name)
-{
-	fkey_t *arrow = el->el_term.t_fkey;
-	int i;
-
-	for (i = 0; i < A_K_NKEYS; i++)
-		if (strcmp(name, arrow[i].name) == 0) {
-			arrow[i].type = XK_NOD;
-			return (0);
-		}
-	return (-1);
-}
-
-
-/* term_print_arrow():
- *	Print the arrow key bindings
- */
-protected void
-term_print_arrow(EditLine *el, const char *name)
-{
-	int i;
-	fkey_t *arrow = el->el_term.t_fkey;
-
-	for (i = 0; i < A_K_NKEYS; i++)
-		if (*name == '\0' || strcmp(name, arrow[i].name) == 0)
-			if (arrow[i].type != XK_NOD)
-				key_kprint(el, arrow[i].name, &arrow[i].fun,
-				    arrow[i].type);
-}
-
-
-/* term_bind_arrow():
- *	Bind the arrow keys
- */
-protected void
-term_bind_arrow(EditLine *el)
-{
-	el_action_t *map;
-	const el_action_t *dmap;
-	int i, j;
-	char *p;
-	fkey_t *arrow = el->el_term.t_fkey;
-
-	/* Check if the components needed are initialized */
-	if (el->el_term.t_buf == NULL || el->el_map.key == NULL)
-		return;
-
-	map = el->el_map.type == MAP_VI ? el->el_map.alt : el->el_map.key;
-	dmap = el->el_map.type == MAP_VI ? el->el_map.vic : el->el_map.emacs;
-
-	term_reset_arrow(el);
-
-	for (i = 0; i < A_K_NKEYS; i++) {
-		p = el->el_term.t_str[arrow[i].key];
-		if (p && *p) {
-			j = (unsigned char) *p;
-			/*
-			 * Assign the arrow keys only if:
-			 *
-			 * 1. They are multi-character arrow keys and the user
-			 *    has not re-assigned the leading character, or
-			 *    has re-assigned the leading character to be
-			 *	  ED_SEQUENCE_LEAD_IN
-			 * 2. They are single arrow keys pointing to an
-			 *    unassigned key.
-			 */
-			if (arrow[i].type == XK_NOD)
-				key_clear(el, map, p);
-			else {
-				if (p[1] && (dmap[j] == map[j] ||
-					map[j] == ED_SEQUENCE_LEAD_IN)) {
-					key_add(el, p, &arrow[i].fun,
-					    arrow[i].type);
-					map[j] = ED_SEQUENCE_LEAD_IN;
-				} else if (map[j] == ED_UNASSIGNED) {
-					key_clear(el, map, p);
-					if (arrow[i].type == XK_CMD)
-						map[j] = arrow[i].fun.cmd;
-					else
-						key_add(el, p, &arrow[i].fun,
-						    arrow[i].type);
-				}
-			}
-		}
-	}
-}
-
-
-/* term__putc():
- *	Add a character
- */
-protected int
-term__putc(int c)
-{
-
-	return (fputc(c, term_outfile));
-}
-
-
-/* term__flush():
- *	Flush output
- */
-protected void
-term__flush(void)
-{
-
-	(void) fflush(term_outfile);
-}
-
-
-/* term_telltc():
- *	Print the current termcap characteristics
- */
-protected int
-/*ARGSUSED*/
-term_telltc(EditLine *el, int argc, const char **argv)
-{
-	const struct termcapstr *t;
-	char **ts;
-	char upbuf[EL_BUFSIZ];
-
-	(void) fprintf(el->el_outfile, "\n\tYour terminal has the\n");
-	(void) fprintf(el->el_outfile, "\tfollowing characteristics:\n\n");
-	(void) fprintf(el->el_outfile, "\tIt has %d columns and %d lines\n",
-	    Val(T_co), Val(T_li));
-	(void) fprintf(el->el_outfile,
-	    "\tIt has %s meta key\n", EL_HAS_META ? "a" : "no");
-	(void) fprintf(el->el_outfile,
-	    "\tIt can%suse tabs\n", EL_CAN_TAB ? " " : "not ");
-	(void) fprintf(el->el_outfile, "\tIt %s automatic margins\n",
-	    EL_HAS_AUTO_MARGINS ? "has" : "does not have");
-	if (EL_HAS_AUTO_MARGINS)
-		(void) fprintf(el->el_outfile, "\tIt %s magic margins\n",
-		    EL_HAS_MAGIC_MARGINS ? "has" : "does not have");
-
-	for (t = tstr, ts = el->el_term.t_str; t->name != NULL; t++, ts++)
-		(void) fprintf(el->el_outfile, "\t%25s (%s) == %s\n",
-		    t->long_name,
-		    t->name, *ts && **ts ?
-		    key__decode_str(*ts, upbuf, "") : "(empty)");
-	(void) fputc('\n', el->el_outfile);
-	return (0);
-}
-
-
-/* term_settc():
- *	Change the current terminal characteristics
- */
-protected int
-/*ARGSUSED*/
-term_settc(EditLine *el, int argc, const char **argv)
-{
-	const struct termcapstr *ts;
-	const struct termcapval *tv;
-	const char *what, *how;
-
-	if (argv == NULL || argv[1] == NULL || argv[2] == NULL)
-		return (-1);
-
-	what = argv[1];
-	how = argv[2];
-
-	/*
-         * Do the strings first
-         */
-	for (ts = tstr; ts->name != NULL; ts++)
-		if (strcmp(ts->name, what) == 0)
-			break;
-
-	if (ts->name != NULL) {
-		term_alloc(el, ts, how);
-		term_setflags(el);
-		return (0);
-	}
-	/*
-         * Do the numeric ones second
-         */
-	for (tv = tval; tv->name != NULL; tv++)
-		if (strcmp(tv->name, what) == 0)
-			break;
-
-	if (tv->name != NULL) {
-		if (tv == &tval[T_pt] || tv == &tval[T_km] ||
-		    tv == &tval[T_am] || tv == &tval[T_xn]) {
-			if (strcmp(how, "yes") == 0)
-				el->el_term.t_val[tv - tval] = 1;
-			else if (strcmp(how, "no") == 0)
-				el->el_term.t_val[tv - tval] = 0;
-			else {
-				(void) fprintf(el->el_errfile,
-				    "settc: Bad value `%s'.\n", how);
-				return (-1);
-			}
-			term_setflags(el);
-			if (term_change_size(el, Val(T_li), Val(T_co)) == -1)
-				return (-1);
-			return (0);
-		} else {
-			long i;
-			char *ep;
-
-			i = strtol(how, &ep, 10);
-			if (*ep != '\0') {
-				(void) fprintf(el->el_errfile,
-				    "settc: Bad value `%s'.\n", how);
-				return (-1);
-			}
-			el->el_term.t_val[tv - tval] = (int) i;
-			el->el_term.t_size.v = Val(T_co);
-			el->el_term.t_size.h = Val(T_li);
-			if (tv == &tval[T_co] || tv == &tval[T_li])
-				if (term_change_size(el, Val(T_li), Val(T_co))
-				    == -1)
-					return (-1);
-			return (0);
-		}
-	}
-	return (-1);
-}
-
-
-/* term_echotc():
- *	Print the termcap string out with variable substitution
- */
-protected int
-/*ARGSUSED*/
-term_echotc(EditLine *el, int argc, const char **argv)
-{
-	char *cap, *scap, *ep;
-	int arg_need, arg_cols, arg_rows;
-	int verbose = 0, silent = 0;
-	char *area;
-	static const char fmts[] = "%s\n", fmtd[] = "%d\n";
-	const struct termcapstr *t;
-	char buf[TC_BUFSIZE];
-	long i;
-
-	area = buf;
-
-	if (argv == NULL || argv[1] == NULL)
-		return (-1);
-	argv++;
-
-	if (argv[0][0] == '-') {
-		switch (argv[0][1]) {
-		case 'v':
-			verbose = 1;
-			break;
-		case 's':
-			silent = 1;
-			break;
-		default:
-			/* stderror(ERR_NAME | ERR_TCUSAGE); */
-			break;
-		}
-		argv++;
-	}
-	if (!*argv || *argv[0] == '\0')
-		return (0);
-	if (strcmp(*argv, "tabs") == 0) {
-		(void) fprintf(el->el_outfile, fmts, EL_CAN_TAB ? "yes" : "no");
-		return (0);
-	} else if (strcmp(*argv, "meta") == 0) {
-		(void) fprintf(el->el_outfile, fmts, Val(T_km) ? "yes" : "no");
-		return (0);
-	} else if (strcmp(*argv, "xn") == 0) {
-		(void) fprintf(el->el_outfile, fmts, EL_HAS_MAGIC_MARGINS ?
-		    "yes" : "no");
-		return (0);
-	} else if (strcmp(*argv, "am") == 0) {
-		(void) fprintf(el->el_outfile, fmts, EL_HAS_AUTO_MARGINS ?
-		    "yes" : "no");
-		return (0);
-	} else if (strcmp(*argv, "baud") == 0) {
-#ifdef notdef
-		int i;
-
-		for (i = 0; baud_rate[i].b_name != NULL; i++)
-			if (el->el_tty.t_speed == baud_rate[i].b_rate) {
-				(void) fprintf(el->el_outfile, fmts,
-				    baud_rate[i].b_name);
-				return (0);
-			}
-		(void) fprintf(el->el_outfile, fmtd, 0);
-#else
-		(void) fprintf(el->el_outfile, fmtd, (int) el->el_tty.t_speed);
-#endif
-		return (0);
-	} else if (strcmp(*argv, "rows") == 0 || strcmp(*argv, "lines") == 0) {
-		(void) fprintf(el->el_outfile, fmtd, Val(T_li));
-		return (0);
-	} else if (strcmp(*argv, "cols") == 0) {
-		(void) fprintf(el->el_outfile, fmtd, Val(T_co));
-		return (0);
-	}
-	/*
-         * Try to use our local definition first
-         */
-	scap = NULL;
-	for (t = tstr; t->name != NULL; t++)
-		if (strcmp(t->name, *argv) == 0) {
-			scap = el->el_term.t_str[t - tstr];
-			break;
-		}
-	if (t->name == NULL)
-		scap = tgetstr((char *)argv, &area);
-	if (!scap || scap[0] == '\0') {
-		if (!silent)
-			(void) fprintf(el->el_errfile,
-			    "echotc: Termcap parameter `%s' not found.\n",
-			    *argv);
-		return (-1);
-	}
-	/*
-         * Count home many values we need for this capability.
-         */
-	for (cap = scap, arg_need = 0; *cap; cap++)
-		if (*cap == '%')
-			switch (*++cap) {
-			case 'd':
-			case '2':
-			case '3':
-			case '.':
-			case '+':
-				arg_need++;
-				break;
-			case '%':
-			case '>':
-			case 'i':
-			case 'r':
-			case 'n':
-			case 'B':
-			case 'D':
-				break;
-			default:
-				/*
-				 * hpux has lot's of them...
-				 */
-				if (verbose)
-					(void) fprintf(el->el_errfile,
-				"echotc: Warning: unknown termcap %% `%c'.\n",
-					    *cap);
-				/* This is bad, but I won't complain */
-				break;
-			}
-
-	switch (arg_need) {
-	case 0:
-		argv++;
-		if (*argv && *argv[0]) {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Warning: Extra argument `%s'.\n",
-				    *argv);
-			return (-1);
-		}
-		(void) tputs(scap, 1, term__putc);
-		break;
-	case 1:
-		argv++;
-		if (!*argv || *argv[0] == '\0') {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Warning: Missing argument.\n");
-			return (-1);
-		}
-		arg_cols = 0;
-		i = strtol(*argv, &ep, 10);
-		if (*ep != '\0' || i < 0) {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Bad value `%s' for rows.\n",
-				    *argv);
-			return (-1);
-		}
-		arg_rows = (int) i;
-		argv++;
-		if (*argv && *argv[0]) {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Warning: Extra argument `%s'.\n",
-				    *argv);
-			return (-1);
-		}
-		(void) tputs(tgoto(scap, arg_cols, arg_rows), 1, term__putc);
-		break;
-	default:
-		/* This is wrong, but I will ignore it... */
-		if (verbose)
-			(void) fprintf(el->el_errfile,
-			 "echotc: Warning: Too many required arguments (%d).\n",
-			    arg_need);
-		/* FALLTHROUGH */
-	case 2:
-		argv++;
-		if (!*argv || *argv[0] == '\0') {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Warning: Missing argument.\n");
-			return (-1);
-		}
-		i = strtol(*argv, &ep, 10);
-		if (*ep != '\0' || i < 0) {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Bad value `%s' for cols.\n",
-				    *argv);
-			return (-1);
-		}
-		arg_cols = (int) i;
-		argv++;
-		if (!*argv || *argv[0] == '\0') {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Warning: Missing argument.\n");
-			return (-1);
-		}
-		i = strtol(*argv, &ep, 10);
-		if (*ep != '\0' || i < 0) {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Bad value `%s' for rows.\n",
-				    *argv);
-			return (-1);
-		}
-		arg_rows = (int) i;
-		if (*ep != '\0') {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Bad value `%s'.\n", *argv);
-			return (-1);
-		}
-		argv++;
-		if (*argv && *argv[0]) {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Warning: Extra argument `%s'.\n",
-				    *argv);
-			return (-1);
-		}
-		(void) tputs(tgoto(scap, arg_cols, arg_rows), arg_rows,
-		    term__putc);
-		break;
-	}
-	return (0);
-}
diff --git a/main/editline/term.h b/main/editline/term.h
deleted file mode 100644
index 47e08e8..0000000
--- a/main/editline/term.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/*	$NetBSD: term.h,v 1.13 2002/03/18 16:01:00 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)term.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.term.h: Termcap header
- */
-#ifndef _h_el_term
-#define	_h_el_term
-
-#include "histedit.h"
-
-typedef struct {		/* Symbolic function key bindings	*/
-	const char	*name;	/* name of the key			*/
-	int		 key;	/* Index in termcap table		*/
-	key_value_t	 fun;	/* Function bound to it			*/
-	int		 type;	/* Type of function			*/
-} fkey_t;
-
-typedef struct {
-	coord_t	  t_size;		/* # lines and cols	*/
-	int	  t_flags;
-#define	TERM_CAN_INSERT		0x001	/* Has insert cap	*/
-#define	TERM_CAN_DELETE		0x002	/* Has delete cap	*/
-#define	TERM_CAN_CEOL		0x004	/* Has CEOL cap		*/
-#define	TERM_CAN_TAB		0x008	/* Can use tabs		*/
-#define	TERM_CAN_ME		0x010	/* Can turn all attrs.	*/
-#define	TERM_CAN_UP		0x020	/* Can move up		*/
-#define	TERM_HAS_META		0x040	/* Has a meta key	*/
-#define	TERM_HAS_AUTO_MARGINS	0x080	/* Has auto margins	*/
-#define	TERM_HAS_MAGIC_MARGINS	0x100	/* Has magic margins	*/
-	char	 *t_buf;		/* Termcap buffer	*/
-	int	  t_loc;		/* location used	*/
-	char	**t_str;		/* termcap strings	*/
-	int	 *t_val;		/* termcap values	*/
-	char	 *t_cap;		/* Termcap buffer	*/
-	fkey_t	 *t_fkey;		/* Array of keys	*/
-} el_term_t;
-
-/*
- * fKey indexes
- */
-#define	A_K_DN		0
-#define	A_K_UP		1
-#define	A_K_LT		2
-#define	A_K_RT		3
-#define	A_K_HO		4
-#define	A_K_EN		5
-#define	A_K_NKEYS	6
-
-protected void	term_move_to_line(EditLine *, int);
-protected void	term_move_to_char(EditLine *, int);
-protected void	term_clear_EOL(EditLine *, int);
-protected void	term_overwrite(EditLine *, const char *, int);
-protected void	term_insertwrite(EditLine *, char *, int);
-protected void	term_deletechars(EditLine *, int);
-protected void	term_clear_screen(EditLine *);
-protected void	term_beep(EditLine *);
-protected int	term_change_size(EditLine *, int, int);
-protected int	term_get_size(EditLine *, int *, int *);
-protected int	term_init(EditLine *);
-protected void	term_bind_arrow(EditLine *);
-protected void	term_print_arrow(EditLine *, const char *);
-protected int	term_clear_arrow(EditLine *, const char *);
-protected int	term_set_arrow(EditLine *, const char *, key_value_t *, int);
-protected void	term_end(EditLine *);
-protected int	term_set(EditLine *, const char *);
-protected int	term_settc(EditLine *, int, const char **);
-protected int	term_telltc(EditLine *, int, const char **);
-protected int	term_echotc(EditLine *, int, const char **);
-protected int	term__putc(int);
-protected void	term__flush(void);
-
-/*
- * Easy access macros
- */
-#define	EL_FLAGS	(el)->el_term.t_flags
-
-#define	EL_CAN_INSERT		(EL_FLAGS & TERM_CAN_INSERT)
-#define	EL_CAN_DELETE		(EL_FLAGS & TERM_CAN_DELETE)
-#define	EL_CAN_CEOL		(EL_FLAGS & TERM_CAN_CEOL)
-#define	EL_CAN_TAB		(EL_FLAGS & TERM_CAN_TAB)
-#define	EL_CAN_ME		(EL_FLAGS & TERM_CAN_ME)
-#define	EL_HAS_META		(EL_FLAGS & TERM_HAS_META)
-#define	EL_HAS_AUTO_MARGINS	(EL_FLAGS & TERM_HAS_AUTO_MARGINS)
-#define	EL_HAS_MAGIC_MARGINS	(EL_FLAGS & TERM_HAS_MAGIC_MARGINS)
-
-#endif /* _h_el_term */
diff --git a/main/editline/tokenizer.c b/main/editline/tokenizer.c
deleted file mode 100644
index f0de39b..0000000
--- a/main/editline/tokenizer.c
+++ /dev/null
@@ -1,397 +0,0 @@
-/*	$NetBSD: tokenizer.c,v 1.10 2002/03/18 16:01:00 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)tokenizer.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: tokenizer.c,v 1.10 2002/03/18 16:01:00 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * tokenize.c: Bourne shell like tokenizer
- */
-#include <string.h>
-#include <stdlib.h>
-#include "tokenizer.h"
-
-typedef enum {
-	Q_none, Q_single, Q_double, Q_one, Q_doubleone
-} quote_t;
-
-#define	IFS		"\t \n"
-
-#define	TOK_KEEP	1
-#define	TOK_EAT		2
-
-#define	WINCR		20
-#define	AINCR		10
-
-#define	tok_malloc(a)		malloc(a)
-#define	tok_free(a)		free(a)
-#define	tok_realloc(a, b)	realloc(a, b)
-
-
-struct tokenizer {
-	char	*ifs;		/* In field separator			 */
-	int	 argc, amax;	/* Current and maximum number of args	 */
-	char   **argv;		/* Argument list			 */
-	char	*wptr, *wmax;	/* Space and limit on the word buffer	 */
-	char	*wstart;	/* Beginning of next word		 */
-	char	*wspace;	/* Space of word buffer			 */
-	quote_t	 quote;		/* Quoting state			 */
-	int	 flags;		/* flags;				 */
-};
-
-
-private void tok_finish(Tokenizer *);
-
-
-/* tok_finish():
- *	Finish a word in the tokenizer.
- */
-private void
-tok_finish(Tokenizer *tok)
-{
-
-	*tok->wptr = '\0';
-	if ((tok->flags & TOK_KEEP) || tok->wptr != tok->wstart) {
-		tok->argv[tok->argc++] = tok->wstart;
-		tok->argv[tok->argc] = NULL;
-		tok->wstart = ++tok->wptr;
-	}
-	tok->flags &= ~TOK_KEEP;
-}
-
-
-/* tok_init():
- *	Initialize the tokenizer
- */
-public Tokenizer *
-tok_init(const char *ifs)
-{
-	Tokenizer *tok = (Tokenizer *) tok_malloc(sizeof(Tokenizer));
-
-	tok->ifs = strdup(ifs ? ifs : IFS);
-	tok->argc = 0;
-	tok->amax = AINCR;
-	tok->argv = (char **) tok_malloc(sizeof(char *) * tok->amax);
-	if (tok->argv == NULL)
-		return (NULL);
-	tok->argv[0] = NULL;
-	tok->wspace = (char *) tok_malloc(WINCR);
-	if (tok->wspace == NULL)
-		return (NULL);
-	tok->wmax = tok->wspace + WINCR;
-	tok->wstart = tok->wspace;
-	tok->wptr = tok->wspace;
-	tok->flags = 0;
-	tok->quote = Q_none;
-
-	return (tok);
-}
-
-
-/* tok_reset():
- *	Reset the tokenizer
- */
-public void
-tok_reset(Tokenizer *tok)
-{
-
-	tok->argc = 0;
-	tok->wstart = tok->wspace;
-	tok->wptr = tok->wspace;
-	tok->flags = 0;
-	tok->quote = Q_none;
-}
-
-
-/* tok_end():
- *	Clean up
- */
-public void
-tok_end(Tokenizer *tok)
-{
-
-	tok_free((ptr_t) tok->ifs);
-	tok_free((ptr_t) tok->wspace);
-	tok_free((ptr_t) tok->argv);
-	tok_free((ptr_t) tok);
-}
-
-
-
-/* tok_line():
- *	Bourne shell like tokenizing
- *	Return:
- *		-1: Internal error
- *		 3: Quoted return
- *		 2: Unmatched double quote
- *		 1: Unmatched single quote
- *		 0: Ok
- */
-public int
-tok_line(Tokenizer *tok, const char *line, int *argc, const char ***argv)
-{
-	const char *ptr;
-
-	for (;;) {
-		switch (*(ptr = line++)) {
-		case '\'':
-			tok->flags |= TOK_KEEP;
-			tok->flags &= ~TOK_EAT;
-			switch (tok->quote) {
-			case Q_none:
-				tok->quote = Q_single;	/* Enter single quote
-							 * mode */
-				break;
-
-			case Q_single:	/* Exit single quote mode */
-				tok->quote = Q_none;
-				break;
-
-			case Q_one:	/* Quote this ' */
-				tok->quote = Q_none;
-				*tok->wptr++ = *ptr;
-				break;
-
-			case Q_double:	/* Stay in double quote mode */
-				*tok->wptr++ = *ptr;
-				break;
-
-			case Q_doubleone:	/* Quote this ' */
-				tok->quote = Q_double;
-				*tok->wptr++ = *ptr;
-				break;
-
-			default:
-				return (-1);
-			}
-			break;
-
-		case '"':
-			tok->flags &= ~TOK_EAT;
-			tok->flags |= TOK_KEEP;
-			switch (tok->quote) {
-			case Q_none:	/* Enter double quote mode */
-				tok->quote = Q_double;
-				break;
-
-			case Q_double:	/* Exit double quote mode */
-				tok->quote = Q_none;
-				break;
-
-			case Q_one:	/* Quote this " */
-				tok->quote = Q_none;
-				*tok->wptr++ = *ptr;
-				break;
-
-			case Q_single:	/* Stay in single quote mode */
-				*tok->wptr++ = *ptr;
-				break;
-
-			case Q_doubleone:	/* Quote this " */
-				tok->quote = Q_double;
-				*tok->wptr++ = *ptr;
-				break;
-
-			default:
-				return (-1);
-			}
-			break;
-
-		case '\\':
-			tok->flags |= TOK_KEEP;
-			tok->flags &= ~TOK_EAT;
-			switch (tok->quote) {
-			case Q_none:	/* Quote next character */
-				tok->quote = Q_one;
-				break;
-
-			case Q_double:	/* Quote next character */
-				tok->quote = Q_doubleone;
-				break;
-
-			case Q_one:	/* Quote this, restore state */
-				*tok->wptr++ = *ptr;
-				tok->quote = Q_none;
-				break;
-
-			case Q_single:	/* Stay in single quote mode */
-				*tok->wptr++ = *ptr;
-				break;
-
-			case Q_doubleone:	/* Quote this \ */
-				tok->quote = Q_double;
-				*tok->wptr++ = *ptr;
-				break;
-
-			default:
-				return (-1);
-			}
-			break;
-
-		case '\n':
-			tok->flags &= ~TOK_EAT;
-			switch (tok->quote) {
-			case Q_none:
-				tok_finish(tok);
-				*argv = (const char **)tok->argv;
-				*argc = tok->argc;
-				return (0);
-
-			case Q_single:
-			case Q_double:
-				*tok->wptr++ = *ptr;	/* Add the return */
-				break;
-
-			case Q_doubleone:   /* Back to double, eat the '\n' */
-				tok->flags |= TOK_EAT;
-				tok->quote = Q_double;
-				break;
-
-			case Q_one:	/* No quote, more eat the '\n' */
-				tok->flags |= TOK_EAT;
-				tok->quote = Q_none;
-				break;
-
-			default:
-				return (0);
-			}
-			break;
-
-		case '\0':
-			switch (tok->quote) {
-			case Q_none:
-				/* Finish word and return */
-				if (tok->flags & TOK_EAT) {
-					tok->flags &= ~TOK_EAT;
-					return (3);
-				}
-				tok_finish(tok);
-				*argv = (const char **)tok->argv;
-				*argc = tok->argc;
-				return (0);
-
-			case Q_single:
-				return (1);
-
-			case Q_double:
-				return (2);
-
-			case Q_doubleone:
-				tok->quote = Q_double;
-				*tok->wptr++ = *ptr;
-				break;
-
-			case Q_one:
-				tok->quote = Q_none;
-				*tok->wptr++ = *ptr;
-				break;
-
-			default:
-				return (-1);
-			}
-			break;
-
-		default:
-			tok->flags &= ~TOK_EAT;
-			switch (tok->quote) {
-			case Q_none:
-				if (strchr(tok->ifs, *ptr) != NULL)
-					tok_finish(tok);
-				else
-					*tok->wptr++ = *ptr;
-				break;
-
-			case Q_single:
-			case Q_double:
-				*tok->wptr++ = *ptr;
-				break;
-
-
-			case Q_doubleone:
-				*tok->wptr++ = '\\';
-				tok->quote = Q_double;
-				*tok->wptr++ = *ptr;
-				break;
-
-			case Q_one:
-				tok->quote = Q_none;
-				*tok->wptr++ = *ptr;
-				break;
-
-			default:
-				return (-1);
-
-			}
-			break;
-		}
-
-		if (tok->wptr >= tok->wmax - 4) {
-			size_t size = tok->wmax - tok->wspace + WINCR;
-			char *s = (char *) tok_realloc(tok->wspace, size);
-			if (s == NULL)
-				return (-1);
-
-			if (s != tok->wspace) {
-				int i;
-				for (i = 0; i < tok->argc; i++) {
-				    tok->argv[i] =
-					(tok->argv[i] - tok->wspace) + s;
-				}
-				tok->wptr = (tok->wptr - tok->wspace) + s;
-				tok->wstart = (tok->wstart - tok->wspace) + s;
-				tok->wspace = s;
-			}
-			tok->wmax = s + size;
-		}
-		if (tok->argc >= tok->amax - 4) {
-			char **p;
-			tok->amax += AINCR;
-			p = (char **) tok_realloc(tok->argv,
-			    tok->amax * sizeof(char *));
-			if (p == NULL)
-				return (-1);
-			tok->argv = p;
-		}
-	}
-}
diff --git a/main/editline/tokenizer.h b/main/editline/tokenizer.h
deleted file mode 100644
index 7cc7a33..0000000
--- a/main/editline/tokenizer.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*	$NetBSD: tokenizer.h,v 1.5 2002/03/18 16:01:00 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)tokenizer.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * tokenizer.h: Header file for tokenizer routines
- */
-#ifndef _h_tokenizer
-#define	_h_tokenizer
-
-typedef struct tokenizer Tokenizer;
-
-Tokenizer	*tok_init(const char *);
-void		 tok_reset(Tokenizer *);
-void		 tok_end(Tokenizer *);
-int		 tok_line(Tokenizer *, const char *, int *, const char ***);
-
-#endif /* _h_tokenizer */
diff --git a/main/editline/tty.c b/main/editline/tty.c
deleted file mode 100644
index 256cf78..0000000
--- a/main/editline/tty.c
+++ /dev/null
@@ -1,1182 +0,0 @@
-/*	$NetBSD: tty.c,v 1.16 2002/03/18 16:01:01 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)tty.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: tty.c,v 1.16 2002/03/18 16:01:01 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * tty.c: tty interface stuff
- */
-#include "tty.h"
-#include "el.h"
-
-typedef struct ttymodes_t {
-	const char *m_name;
-	u_int m_value;
-	int m_type;
-}          ttymodes_t;
-
-typedef struct ttymap_t {
-	int nch, och;		/* Internal and termio rep of chars */
-	el_action_t bind[3];	/* emacs, vi, and vi-cmd */
-} ttymap_t;
-
-
-private const ttyperm_t ttyperm = {
-	{
-		{"iflag:", ICRNL, (INLCR | IGNCR)},
-		{"oflag:", (OPOST | ONLCR), ONLRET},
-		{"cflag:", 0, 0},
-		{"lflag:", (ISIG | ICANON | ECHO | ECHOE | ECHOCTL | IEXTEN),
-		(NOFLSH | ECHONL | EXTPROC | FLUSHO)},
-		{"chars:", 0, 0},
-	},
-	{
-		{"iflag:", (INLCR | ICRNL), IGNCR},
-		{"oflag:", (OPOST | ONLCR), ONLRET},
-		{"cflag:", 0, 0},
-		{"lflag:", ISIG,
-		(NOFLSH | ICANON | ECHO | ECHOK | ECHONL | EXTPROC | IEXTEN | FLUSHO)},
-		{"chars:", (C_SH(C_MIN) | C_SH(C_TIME) | C_SH(C_SWTCH) | C_SH(C_DSWTCH) |
-			    C_SH(C_SUSP) | C_SH(C_DSUSP) | C_SH(C_EOL) | C_SH(C_DISCARD) |
-		    C_SH(C_PGOFF) | C_SH(C_PAGE) | C_SH(C_STATUS)), 0}
-	},
-	{
-		{"iflag:", 0, IXON | IXOFF | INLCR | ICRNL},
-		{"oflag:", 0, 0},
-		{"cflag:", 0, 0},
-		{"lflag:", 0, ISIG | IEXTEN},
-		{"chars:", 0, 0},
-	}
-};
-
-private const ttychar_t ttychar = {
-	{
-		CINTR, CQUIT, CERASE, CKILL,
-		CEOF, CEOL, CEOL2, CSWTCH,
-		CDSWTCH, CERASE2, CSTART, CSTOP,
-		CWERASE, CSUSP, CDSUSP, CREPRINT,
-		CDISCARD, CLNEXT, CSTATUS, CPAGE,
-		CPGOFF, CKILL2, CBRK, CMIN,
-		CTIME
-	},
-	{
-		CINTR, CQUIT, CERASE, CKILL,
-		_POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE,
-		_POSIX_VDISABLE, CERASE2, CSTART, CSTOP,
-		_POSIX_VDISABLE, CSUSP, _POSIX_VDISABLE, _POSIX_VDISABLE,
-		CDISCARD, _POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE,
-		_POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE, 1,
-		0
-	},
-	{
-		0, 0, 0, 0,
-		0, 0, 0, 0,
-		0, 0, 0, 0,
-		0, 0, 0, 0,
-		0, 0, 0, 0,
-		0, 0, 0, 0,
-		0
-	}
-};
-
-private const ttymap_t tty_map[] = {
-#ifdef VERASE
-	{C_ERASE, VERASE,
-	{ED_DELETE_PREV_CHAR, VI_DELETE_PREV_CHAR, ED_PREV_CHAR}},
-#endif /* VERASE */
-#ifdef VERASE2
-	{C_ERASE2, VERASE2,
-	{ED_DELETE_PREV_CHAR, VI_DELETE_PREV_CHAR, ED_PREV_CHAR}},
-#endif /* VERASE2 */
-#ifdef VKILL
-	{C_KILL, VKILL,
-	{EM_KILL_LINE, VI_KILL_LINE_PREV, ED_UNASSIGNED}},
-#endif /* VKILL */
-#ifdef VKILL2
-	{C_KILL2, VKILL2,
-	{EM_KILL_LINE, VI_KILL_LINE_PREV, ED_UNASSIGNED}},
-#endif /* VKILL2 */
-#ifdef VEOF
-	{C_EOF, VEOF,
-	{EM_DELETE_OR_LIST, VI_LIST_OR_EOF, ED_UNASSIGNED}},
-#endif /* VEOF */
-#ifdef VWERASE
-	{C_WERASE, VWERASE,
-	{ED_DELETE_PREV_WORD, ED_DELETE_PREV_WORD, ED_PREV_WORD}},
-#endif /* VWERASE */
-#ifdef VREPRINT
-	{C_REPRINT, VREPRINT,
-	{ED_REDISPLAY, ED_INSERT, ED_REDISPLAY}},
-#endif /* VREPRINT */
-#ifdef VLNEXT
-	{C_LNEXT, VLNEXT,
-	{ED_QUOTED_INSERT, ED_QUOTED_INSERT, ED_UNASSIGNED}},
-#endif /* VLNEXT */
-	{-1, -1,
-	{ED_UNASSIGNED, ED_UNASSIGNED, ED_UNASSIGNED}}
-};
-
-private const ttymodes_t ttymodes[] = {
-#ifdef	IGNBRK
-	{"ignbrk", IGNBRK, MD_INP},
-#endif /* IGNBRK */
-#ifdef	BRKINT
-	{"brkint", BRKINT, MD_INP},
-#endif /* BRKINT */
-#ifdef	IGNPAR
-	{"ignpar", IGNPAR, MD_INP},
-#endif /* IGNPAR */
-#ifdef	PARMRK
-	{"parmrk", PARMRK, MD_INP},
-#endif /* PARMRK */
-#ifdef	INPCK
-	{"inpck", INPCK, MD_INP},
-#endif /* INPCK */
-#ifdef	ISTRIP
-	{"istrip", ISTRIP, MD_INP},
-#endif /* ISTRIP */
-#ifdef	INLCR
-	{"inlcr", INLCR, MD_INP},
-#endif /* INLCR */
-#ifdef	IGNCR
-	{"igncr", IGNCR, MD_INP},
-#endif /* IGNCR */
-#ifdef	ICRNL
-	{"icrnl", ICRNL, MD_INP},
-#endif /* ICRNL */
-#ifdef	IUCLC
-	{"iuclc", IUCLC, MD_INP},
-#endif /* IUCLC */
-#ifdef	IXON
-	{"ixon", IXON, MD_INP},
-#endif /* IXON */
-#ifdef	IXANY
-	{"ixany", IXANY, MD_INP},
-#endif /* IXANY */
-#ifdef	IXOFF
-	{"ixoff", IXOFF, MD_INP},
-#endif /* IXOFF */
-#ifdef  IMAXBEL
-	{"imaxbel", IMAXBEL, MD_INP},
-#endif /* IMAXBEL */
-
-#ifdef	OPOST
-	{"opost", OPOST, MD_OUT},
-#endif /* OPOST */
-#ifdef	OLCUC
-	{"olcuc", OLCUC, MD_OUT},
-#endif /* OLCUC */
-#ifdef	ONLCR
-	{"onlcr", ONLCR, MD_OUT},
-#endif /* ONLCR */
-#ifdef	OCRNL
-	{"ocrnl", OCRNL, MD_OUT},
-#endif /* OCRNL */
-#ifdef	ONOCR
-	{"onocr", ONOCR, MD_OUT},
-#endif /* ONOCR */
-#ifdef ONOEOT
-	{"onoeot", ONOEOT, MD_OUT},
-#endif /* ONOEOT */
-#ifdef	ONLRET
-	{"onlret", ONLRET, MD_OUT},
-#endif /* ONLRET */
-#ifdef	OFILL
-	{"ofill", OFILL, MD_OUT},
-#endif /* OFILL */
-#ifdef	OFDEL
-	{"ofdel", OFDEL, MD_OUT},
-#endif /* OFDEL */
-#ifdef	NLDLY
-	{"nldly", NLDLY, MD_OUT},
-#endif /* NLDLY */
-#ifdef	CRDLY
-	{"crdly", CRDLY, MD_OUT},
-#endif /* CRDLY */
-#ifdef	TABDLY
-	{"tabdly", TABDLY, MD_OUT},
-#endif /* TABDLY */
-#ifdef	XTABS
-	{"xtabs", XTABS, MD_OUT},
-#endif /* XTABS */
-#ifdef	BSDLY
-	{"bsdly", BSDLY, MD_OUT},
-#endif /* BSDLY */
-#ifdef	VTDLY
-	{"vtdly", VTDLY, MD_OUT},
-#endif /* VTDLY */
-#ifdef	FFDLY
-	{"ffdly", FFDLY, MD_OUT},
-#endif /* FFDLY */
-#ifdef	PAGEOUT
-	{"pageout", PAGEOUT, MD_OUT},
-#endif /* PAGEOUT */
-#ifdef	WRAP
-	{"wrap", WRAP, MD_OUT},
-#endif /* WRAP */
-
-#ifdef	CIGNORE
-	{"cignore", CIGNORE, MD_CTL},
-#endif /* CBAUD */
-#ifdef	CBAUD
-	{"cbaud", CBAUD, MD_CTL},
-#endif /* CBAUD */
-#ifdef	CSTOPB
-	{"cstopb", CSTOPB, MD_CTL},
-#endif /* CSTOPB */
-#ifdef	CREAD
-	{"cread", CREAD, MD_CTL},
-#endif /* CREAD */
-#ifdef	PARENB
-	{"parenb", PARENB, MD_CTL},
-#endif /* PARENB */
-#ifdef	PARODD
-	{"parodd", PARODD, MD_CTL},
-#endif /* PARODD */
-#ifdef	HUPCL
-	{"hupcl", HUPCL, MD_CTL},
-#endif /* HUPCL */
-#ifdef	CLOCAL
-	{"clocal", CLOCAL, MD_CTL},
-#endif /* CLOCAL */
-#ifdef	LOBLK
-	{"loblk", LOBLK, MD_CTL},
-#endif /* LOBLK */
-#ifdef	CIBAUD
-	{"cibaud", CIBAUD, MD_CTL},
-#endif /* CIBAUD */
-#ifdef CRTSCTS
-#ifdef CCTS_OFLOW
-	{"ccts_oflow", CCTS_OFLOW, MD_CTL},
-#else
-	{"crtscts", CRTSCTS, MD_CTL},
-#endif /* CCTS_OFLOW */
-#endif /* CRTSCTS */
-#ifdef CRTS_IFLOW
-	{"crts_iflow", CRTS_IFLOW, MD_CTL},
-#endif /* CRTS_IFLOW */
-#ifdef CDTRCTS
-	{"cdtrcts", CDTRCTS, MD_CTL},
-#endif /* CDTRCTS */
-#ifdef MDMBUF
-	{"mdmbuf", MDMBUF, MD_CTL},
-#endif /* MDMBUF */
-#ifdef RCV1EN
-	{"rcv1en", RCV1EN, MD_CTL},
-#endif /* RCV1EN */
-#ifdef XMT1EN
-	{"xmt1en", XMT1EN, MD_CTL},
-#endif /* XMT1EN */
-
-#ifdef	ISIG
-	{"isig", ISIG, MD_LIN},
-#endif /* ISIG */
-#ifdef	ICANON
-	{"icanon", ICANON, MD_LIN},
-#endif /* ICANON */
-#ifdef	XCASE
-	{"xcase", XCASE, MD_LIN},
-#endif /* XCASE */
-#ifdef	ECHO
-	{"echo", ECHO, MD_LIN},
-#endif /* ECHO */
-#ifdef	ECHOE
-	{"echoe", ECHOE, MD_LIN},
-#endif /* ECHOE */
-#ifdef	ECHOK
-	{"echok", ECHOK, MD_LIN},
-#endif /* ECHOK */
-#ifdef	ECHONL
-	{"echonl", ECHONL, MD_LIN},
-#endif /* ECHONL */
-#ifdef	NOFLSH
-	{"noflsh", NOFLSH, MD_LIN},
-#endif /* NOFLSH */
-#ifdef	TOSTOP
-	{"tostop", TOSTOP, MD_LIN},
-#endif /* TOSTOP */
-#ifdef	ECHOCTL
-	{"echoctl", ECHOCTL, MD_LIN},
-#endif /* ECHOCTL */
-#ifdef	ECHOPRT
-	{"echoprt", ECHOPRT, MD_LIN},
-#endif /* ECHOPRT */
-#ifdef	ECHOKE
-	{"echoke", ECHOKE, MD_LIN},
-#endif /* ECHOKE */
-#ifdef	DEFECHO
-	{"defecho", DEFECHO, MD_LIN},
-#endif /* DEFECHO */
-#ifdef	FLUSHO
-	{"flusho", FLUSHO, MD_LIN},
-#endif /* FLUSHO */
-#ifdef	PENDIN
-	{"pendin", PENDIN, MD_LIN},
-#endif /* PENDIN */
-#ifdef	IEXTEN
-	{"iexten", IEXTEN, MD_LIN},
-#endif /* IEXTEN */
-#ifdef	NOKERNINFO
-	{"nokerninfo", NOKERNINFO, MD_LIN},
-#endif /* NOKERNINFO */
-#ifdef	ALTWERASE
-	{"altwerase", ALTWERASE, MD_LIN},
-#endif /* ALTWERASE */
-#ifdef	EXTPROC
-	{"extproc", EXTPROC, MD_LIN},
-#endif /* EXTPROC */
-
-#if defined(VINTR)
-	{"intr", C_SH(C_INTR), MD_CHAR},
-#endif /* VINTR */
-#if defined(VQUIT)
-	{"quit", C_SH(C_QUIT), MD_CHAR},
-#endif /* VQUIT */
-#if defined(VERASE)
-	{"erase", C_SH(C_ERASE), MD_CHAR},
-#endif /* VERASE */
-#if defined(VKILL)
-	{"kill", C_SH(C_KILL), MD_CHAR},
-#endif /* VKILL */
-#if defined(VEOF)
-	{"eof", C_SH(C_EOF), MD_CHAR},
-#endif /* VEOF */
-#if defined(VEOL)
-	{"eol", C_SH(C_EOL), MD_CHAR},
-#endif /* VEOL */
-#if defined(VEOL2)
-	{"eol2", C_SH(C_EOL2), MD_CHAR},
-#endif /* VEOL2 */
-#if defined(VSWTCH)
-	{"swtch", C_SH(C_SWTCH), MD_CHAR},
-#endif /* VSWTCH */
-#if defined(VDSWTCH)
-	{"dswtch", C_SH(C_DSWTCH), MD_CHAR},
-#endif /* VDSWTCH */
-#if defined(VERASE2)
-	{"erase2", C_SH(C_ERASE2), MD_CHAR},
-#endif /* VERASE2 */
-#if defined(VSTART)
-	{"start", C_SH(C_START), MD_CHAR},
-#endif /* VSTART */
-#if defined(VSTOP)
-	{"stop", C_SH(C_STOP), MD_CHAR},
-#endif /* VSTOP */
-#if defined(VWERASE)
-	{"werase", C_SH(C_WERASE), MD_CHAR},
-#endif /* VWERASE */
-#if defined(VSUSP)
-	{"susp", C_SH(C_SUSP), MD_CHAR},
-#endif /* VSUSP */
-#if defined(VDSUSP)
-	{"dsusp", C_SH(C_DSUSP), MD_CHAR},
-#endif /* VDSUSP */
-#if defined(VREPRINT)
-	{"reprint", C_SH(C_REPRINT), MD_CHAR},
-#endif /* VREPRINT */
-#if defined(VDISCARD)
-	{"discard", C_SH(C_DISCARD), MD_CHAR},
-#endif /* VDISCARD */
-#if defined(VLNEXT)
-	{"lnext", C_SH(C_LNEXT), MD_CHAR},
-#endif /* VLNEXT */
-#if defined(VSTATUS)
-	{"status", C_SH(C_STATUS), MD_CHAR},
-#endif /* VSTATUS */
-#if defined(VPAGE)
-	{"page", C_SH(C_PAGE), MD_CHAR},
-#endif /* VPAGE */
-#if defined(VPGOFF)
-	{"pgoff", C_SH(C_PGOFF), MD_CHAR},
-#endif /* VPGOFF */
-#if defined(VKILL2)
-	{"kill2", C_SH(C_KILL2), MD_CHAR},
-#endif /* VKILL2 */
-#if defined(VBRK)
-	{"brk", C_SH(C_BRK), MD_CHAR},
-#endif /* VBRK */
-#if defined(VMIN)
-	{"min", C_SH(C_MIN), MD_CHAR},
-#endif /* VMIN */
-#if defined(VTIME)
-	{"time", C_SH(C_TIME), MD_CHAR},
-#endif /* VTIME */
-	{NULL, 0, -1},
-};
-
-
-
-#define	tty_getty(el, td)	tcgetattr((el)->el_infd, (td))
-#define	tty_setty(el, td)	tcsetattr((el)->el_infd, TCSADRAIN, (td))
-
-#define	tty__gettabs(td)	((((td)->c_oflag & TAB3) == TAB3) ? 0 : 1)
-#define	tty__geteightbit(td)	(((td)->c_cflag & CSIZE) == CS8)
-#define	tty__cooked_mode(td)	((td)->c_lflag & ICANON)
-
-private void	tty__getchar(struct termios *, unsigned char *);
-private void	tty__setchar(struct termios *, unsigned char *);
-private speed_t	tty__getspeed(struct termios *);
-private int	tty_setup(EditLine *);
-
-#define	t_qu	t_ts
-
-
-/* tty_setup():
- *	Get the tty parameters and initialize the editing state
- */
-private int
-tty_setup(EditLine *el)
-{
-	int rst = 1;
-
-	if (el->el_flags & EDIT_DISABLED)
-		return (0);
-
-	if (tty_getty(el, &el->el_tty.t_ed) == -1) {
-#ifdef DEBUG_TTY
-		(void) fprintf(el->el_errfile,
-		    "tty_setup: tty_getty: %s\n", strerror(errno));
-#endif /* DEBUG_TTY */
-		return (-1);
-	}
-	el->el_tty.t_ts = el->el_tty.t_ex = el->el_tty.t_ed;
-
-	el->el_tty.t_speed = tty__getspeed(&el->el_tty.t_ex);
-	el->el_tty.t_tabs = tty__gettabs(&el->el_tty.t_ex);
-	el->el_tty.t_eight = tty__geteightbit(&el->el_tty.t_ex);
-
-	el->el_tty.t_ex.c_iflag &= ~el->el_tty.t_t[EX_IO][MD_INP].t_clrmask;
-	el->el_tty.t_ex.c_iflag |= el->el_tty.t_t[EX_IO][MD_INP].t_setmask;
-
-	el->el_tty.t_ex.c_oflag &= ~el->el_tty.t_t[EX_IO][MD_OUT].t_clrmask;
-	el->el_tty.t_ex.c_oflag |= el->el_tty.t_t[EX_IO][MD_OUT].t_setmask;
-
-	el->el_tty.t_ex.c_cflag &= ~el->el_tty.t_t[EX_IO][MD_CTL].t_clrmask;
-	el->el_tty.t_ex.c_cflag |= el->el_tty.t_t[EX_IO][MD_CTL].t_setmask;
-
-	el->el_tty.t_ex.c_lflag &= ~el->el_tty.t_t[EX_IO][MD_LIN].t_clrmask;
-	el->el_tty.t_ex.c_lflag |= el->el_tty.t_t[EX_IO][MD_LIN].t_setmask;
-
-	/*
-         * Reset the tty chars to reasonable defaults
-         * If they are disabled, then enable them.
-         */
-	if (rst) {
-		if (tty__cooked_mode(&el->el_tty.t_ts)) {
-			tty__getchar(&el->el_tty.t_ts, el->el_tty.t_c[TS_IO]);
-			/*
-	                 * Don't affect CMIN and CTIME for the editor mode
-	                 */
-			for (rst = 0; rst < C_NCC - 2; rst++)
-				if (el->el_tty.t_c[TS_IO][rst] !=
-				      el->el_tty.t_vdisable
-				    && el->el_tty.t_c[ED_IO][rst] !=
-				      el->el_tty.t_vdisable)
-					el->el_tty.t_c[ED_IO][rst] =
-					    el->el_tty.t_c[TS_IO][rst];
-			for (rst = 0; rst < C_NCC; rst++)
-				if (el->el_tty.t_c[TS_IO][rst] !=
-				    el->el_tty.t_vdisable)
-					el->el_tty.t_c[EX_IO][rst] =
-					    el->el_tty.t_c[TS_IO][rst];
-		}
-		tty__setchar(&el->el_tty.t_ex, el->el_tty.t_c[EX_IO]);
-		if (tty_setty(el, &el->el_tty.t_ex) == -1) {
-#ifdef DEBUG_TTY
-			(void) fprintf(el->el_errfile,
-			    "tty_setup: tty_setty: %s\n",
-			    strerror(errno));
-#endif /* DEBUG_TTY */
-			return (-1);
-		}
-	} else
-		tty__setchar(&el->el_tty.t_ex, el->el_tty.t_c[EX_IO]);
-
-	el->el_tty.t_ed.c_iflag &= ~el->el_tty.t_t[ED_IO][MD_INP].t_clrmask;
-	el->el_tty.t_ed.c_iflag |= el->el_tty.t_t[ED_IO][MD_INP].t_setmask;
-
-	el->el_tty.t_ed.c_oflag &= ~el->el_tty.t_t[ED_IO][MD_OUT].t_clrmask;
-	el->el_tty.t_ed.c_oflag |= el->el_tty.t_t[ED_IO][MD_OUT].t_setmask;
-
-	el->el_tty.t_ed.c_cflag &= ~el->el_tty.t_t[ED_IO][MD_CTL].t_clrmask;
-	el->el_tty.t_ed.c_cflag |= el->el_tty.t_t[ED_IO][MD_CTL].t_setmask;
-
-	el->el_tty.t_ed.c_lflag &= ~el->el_tty.t_t[ED_IO][MD_LIN].t_clrmask;
-	el->el_tty.t_ed.c_lflag |= el->el_tty.t_t[ED_IO][MD_LIN].t_setmask;
-
-	tty__setchar(&el->el_tty.t_ed, el->el_tty.t_c[ED_IO]);
-	tty_bind_char(el, 1);
-	return (0);
-}
-
-protected int
-tty_init(EditLine *el)
-{
-
-	el->el_tty.t_mode = EX_IO;
-	el->el_tty.t_vdisable = _POSIX_VDISABLE;
-	(void) memcpy(el->el_tty.t_t, ttyperm, sizeof(ttyperm_t));
-	(void) memcpy(el->el_tty.t_c, ttychar, sizeof(ttychar_t));
-	return (tty_setup(el));
-}
-
-
-/* tty_end():
- *	Restore the tty to its original settings
- */
-protected void
-/*ARGSUSED*/
-tty_end(EditLine *el)
-{
-
-	/* XXX: Maybe reset to an initial state? */
-}
-
-
-/* tty__getspeed():
- *	Get the tty speed
- */
-private speed_t
-tty__getspeed(struct termios *td)
-{
-	speed_t spd;
-
-	if ((spd = cfgetispeed(td)) == 0)
-		spd = cfgetospeed(td);
-	return (spd);
-}
-
-
-/* tty__getchar():
- *	Get the tty characters
- */
-private void
-tty__getchar(struct termios *td, unsigned char *s)
-{
-
-#ifdef VINTR
-	s[C_INTR] = td->c_cc[VINTR];
-#endif /* VINTR */
-#ifdef VQUIT
-	s[C_QUIT] = td->c_cc[VQUIT];
-#endif /* VQUIT */
-#ifdef VERASE
-	s[C_ERASE] = td->c_cc[VERASE];
-#endif /* VERASE */
-#ifdef VKILL
-	s[C_KILL] = td->c_cc[VKILL];
-#endif /* VKILL */
-#ifdef VEOF
-	s[C_EOF] = td->c_cc[VEOF];
-#endif /* VEOF */
-#ifdef VEOL
-	s[C_EOL] = td->c_cc[VEOL];
-#endif /* VEOL */
-#ifdef VEOL2
-	s[C_EOL2] = td->c_cc[VEOL2];
-#endif /* VEOL2 */
-#ifdef VSWTCH
-	s[C_SWTCH] = td->c_cc[VSWTCH];
-#endif /* VSWTCH */
-#ifdef VDSWTCH
-	s[C_DSWTCH] = td->c_cc[VDSWTCH];
-#endif /* VDSWTCH */
-#ifdef VERASE2
-	s[C_ERASE2] = td->c_cc[VERASE2];
-#endif /* VERASE2 */
-#ifdef VSTART
-	s[C_START] = td->c_cc[VSTART];
-#endif /* VSTART */
-#ifdef VSTOP
-	s[C_STOP] = td->c_cc[VSTOP];
-#endif /* VSTOP */
-#ifdef VWERASE
-	s[C_WERASE] = td->c_cc[VWERASE];
-#endif /* VWERASE */
-#ifdef VSUSP
-	s[C_SUSP] = td->c_cc[VSUSP];
-#endif /* VSUSP */
-#ifdef VDSUSP
-	s[C_DSUSP] = td->c_cc[VDSUSP];
-#endif /* VDSUSP */
-#ifdef VREPRINT
-	s[C_REPRINT] = td->c_cc[VREPRINT];
-#endif /* VREPRINT */
-#ifdef VDISCARD
-	s[C_DISCARD] = td->c_cc[VDISCARD];
-#endif /* VDISCARD */
-#ifdef VLNEXT
-	s[C_LNEXT] = td->c_cc[VLNEXT];
-#endif /* VLNEXT */
-#ifdef VSTATUS
-	s[C_STATUS] = td->c_cc[VSTATUS];
-#endif /* VSTATUS */
-#ifdef VPAGE
-	s[C_PAGE] = td->c_cc[VPAGE];
-#endif /* VPAGE */
-#ifdef VPGOFF
-	s[C_PGOFF] = td->c_cc[VPGOFF];
-#endif /* VPGOFF */
-#ifdef VKILL2
-	s[C_KILL2] = td->c_cc[VKILL2];
-#endif /* KILL2 */
-#ifdef VMIN
-	s[C_MIN] = td->c_cc[VMIN];
-#endif /* VMIN */
-#ifdef VTIME
-	s[C_TIME] = td->c_cc[VTIME];
-#endif /* VTIME */
-}				/* tty__getchar */
-
-
-/* tty__setchar():
- *	Set the tty characters
- */
-private void
-tty__setchar(struct termios *td, unsigned char *s)
-{
-
-#ifdef VINTR
-	td->c_cc[VINTR] = s[C_INTR];
-#endif /* VINTR */
-#ifdef VQUIT
-	td->c_cc[VQUIT] = s[C_QUIT];
-#endif /* VQUIT */
-#ifdef VERASE
-	td->c_cc[VERASE] = s[C_ERASE];
-#endif /* VERASE */
-#ifdef VKILL
-	td->c_cc[VKILL] = s[C_KILL];
-#endif /* VKILL */
-#ifdef VEOF
-	td->c_cc[VEOF] = s[C_EOF];
-#endif /* VEOF */
-#ifdef VEOL
-	td->c_cc[VEOL] = s[C_EOL];
-#endif /* VEOL */
-#ifdef VEOL2
-	td->c_cc[VEOL2] = s[C_EOL2];
-#endif /* VEOL2 */
-#ifdef VSWTCH
-	td->c_cc[VSWTCH] = s[C_SWTCH];
-#endif /* VSWTCH */
-#ifdef VDSWTCH
-	td->c_cc[VDSWTCH] = s[C_DSWTCH];
-#endif /* VDSWTCH */
-#ifdef VERASE2
-	td->c_cc[VERASE2] = s[C_ERASE2];
-#endif /* VERASE2 */
-#ifdef VSTART
-	td->c_cc[VSTART] = s[C_START];
-#endif /* VSTART */
-#ifdef VSTOP
-	td->c_cc[VSTOP] = s[C_STOP];
-#endif /* VSTOP */
-#ifdef VWERASE
-	td->c_cc[VWERASE] = s[C_WERASE];
-#endif /* VWERASE */
-#ifdef VSUSP
-	td->c_cc[VSUSP] = s[C_SUSP];
-#endif /* VSUSP */
-#ifdef VDSUSP
-	td->c_cc[VDSUSP] = s[C_DSUSP];
-#endif /* VDSUSP */
-#ifdef VREPRINT
-	td->c_cc[VREPRINT] = s[C_REPRINT];
-#endif /* VREPRINT */
-#ifdef VDISCARD
-	td->c_cc[VDISCARD] = s[C_DISCARD];
-#endif /* VDISCARD */
-#ifdef VLNEXT
-	td->c_cc[VLNEXT] = s[C_LNEXT];
-#endif /* VLNEXT */
-#ifdef VSTATUS
-	td->c_cc[VSTATUS] = s[C_STATUS];
-#endif /* VSTATUS */
-#ifdef VPAGE
-	td->c_cc[VPAGE] = s[C_PAGE];
-#endif /* VPAGE */
-#ifdef VPGOFF
-	td->c_cc[VPGOFF] = s[C_PGOFF];
-#endif /* VPGOFF */
-#ifdef VKILL2
-	td->c_cc[VKILL2] = s[C_KILL2];
-#endif /* VKILL2 */
-#ifdef VMIN
-	td->c_cc[VMIN] = s[C_MIN];
-#endif /* VMIN */
-#ifdef VTIME
-	td->c_cc[VTIME] = s[C_TIME];
-#endif /* VTIME */
-}				/* tty__setchar */
-
-
-/* tty_bind_char():
- *	Rebind the editline functions
- */
-protected void
-tty_bind_char(EditLine *el, int force)
-{
-
-	unsigned char *t_n = el->el_tty.t_c[ED_IO];
-	unsigned char *t_o = el->el_tty.t_ed.c_cc;
-	unsigned char new[2], old[2];
-	const ttymap_t *tp;
-	el_action_t *map, *alt;
-	const el_action_t *dmap, *dalt;
-	new[1] = old[1] = '\0';
-
-	map = el->el_map.key;
-	alt = el->el_map.alt;
-	if (el->el_map.type == MAP_VI) {
-		dmap = el->el_map.vii;
-		dalt = el->el_map.vic;
-	} else {
-		dmap = el->el_map.emacs;
-		dalt = NULL;
-	}
-
-	for (tp = tty_map; tp->nch != -1; tp++) {
-		new[0] = t_n[tp->nch];
-		old[0] = t_o[tp->och];
-		if (new[0] == old[0] && !force)
-			continue;
-		/* Put the old default binding back, and set the new binding */
-		key_clear(el, map, (char *)old);
-		map[old[0]] = dmap[old[0]];
-		key_clear(el, map, (char *)new);
-		/* MAP_VI == 1, MAP_EMACS == 0... */
-		map[new[0]] = tp->bind[el->el_map.type];
-		if (dalt) {
-			key_clear(el, alt, (char *)old);
-			alt[old[0]] = dalt[old[0]];
-			key_clear(el, alt, (char *)new);
-			alt[new[0]] = tp->bind[el->el_map.type + 1];
-		}
-	}
-}
-
-
-/* tty_rawmode():
- * 	Set terminal into 1 character at a time mode.
- */
-protected int
-tty_rawmode(EditLine *el)
-{
-
-	if (el->el_tty.t_mode == ED_IO || el->el_tty.t_mode == QU_IO)
-		return (0);
-
-	if (el->el_flags & EDIT_DISABLED)
-		return (0);
-
-	if (tty_getty(el, &el->el_tty.t_ts) == -1) {
-#ifdef DEBUG_TTY
-		(void) fprintf(el->el_errfile, "tty_rawmode: tty_getty: %s\n",
-		    strerror(errno));
-#endif /* DEBUG_TTY */
-		return (-1);
-	}
-	/*
-         * We always keep up with the eight bit setting and the speed of the
-         * tty. But only we only believe changes that are made to cooked mode!
-         */
-	el->el_tty.t_eight = tty__geteightbit(&el->el_tty.t_ts);
-	el->el_tty.t_speed = tty__getspeed(&el->el_tty.t_ts);
-
-	if (tty__getspeed(&el->el_tty.t_ex) != el->el_tty.t_speed ||
-	    tty__getspeed(&el->el_tty.t_ed) != el->el_tty.t_speed) {
-		(void) cfsetispeed(&el->el_tty.t_ex, el->el_tty.t_speed);
-		(void) cfsetospeed(&el->el_tty.t_ex, el->el_tty.t_speed);
-		(void) cfsetispeed(&el->el_tty.t_ed, el->el_tty.t_speed);
-		(void) cfsetospeed(&el->el_tty.t_ed, el->el_tty.t_speed);
-	}
-	if (tty__cooked_mode(&el->el_tty.t_ts)) {
-		if (el->el_tty.t_ts.c_cflag != el->el_tty.t_ex.c_cflag) {
-			el->el_tty.t_ex.c_cflag =
-			    el->el_tty.t_ts.c_cflag;
-			el->el_tty.t_ex.c_cflag &=
-			    ~el->el_tty.t_t[EX_IO][MD_CTL].t_clrmask;
-			el->el_tty.t_ex.c_cflag |=
-			    el->el_tty.t_t[EX_IO][MD_CTL].t_setmask;
-
-			el->el_tty.t_ed.c_cflag =
-			    el->el_tty.t_ts.c_cflag;
-			el->el_tty.t_ed.c_cflag &=
-			    ~el->el_tty.t_t[ED_IO][MD_CTL].t_clrmask;
-			el->el_tty.t_ed.c_cflag |=
-			    el->el_tty.t_t[ED_IO][MD_CTL].t_setmask;
-		}
-		if ((el->el_tty.t_ts.c_lflag != el->el_tty.t_ex.c_lflag) &&
-		    (el->el_tty.t_ts.c_lflag != el->el_tty.t_ed.c_lflag)) {
-			el->el_tty.t_ex.c_lflag =
-			    el->el_tty.t_ts.c_lflag;
-			el->el_tty.t_ex.c_lflag &=
-			    ~el->el_tty.t_t[EX_IO][MD_LIN].t_clrmask;
-			el->el_tty.t_ex.c_lflag |=
-			    el->el_tty.t_t[EX_IO][MD_LIN].t_setmask;
-
-			el->el_tty.t_ed.c_lflag =
-			    el->el_tty.t_ts.c_lflag;
-			el->el_tty.t_ed.c_lflag &=
-			    ~el->el_tty.t_t[ED_IO][MD_LIN].t_clrmask;
-			el->el_tty.t_ed.c_lflag |=
-			    el->el_tty.t_t[ED_IO][MD_LIN].t_setmask;
-		}
-		if ((el->el_tty.t_ts.c_iflag != el->el_tty.t_ex.c_iflag) &&
-		    (el->el_tty.t_ts.c_iflag != el->el_tty.t_ed.c_iflag)) {
-			el->el_tty.t_ex.c_iflag =
-			    el->el_tty.t_ts.c_iflag;
-			el->el_tty.t_ex.c_iflag &=
-			    ~el->el_tty.t_t[EX_IO][MD_INP].t_clrmask;
-			el->el_tty.t_ex.c_iflag |=
-			    el->el_tty.t_t[EX_IO][MD_INP].t_setmask;
-
-			el->el_tty.t_ed.c_iflag =
-			    el->el_tty.t_ts.c_iflag;
-			el->el_tty.t_ed.c_iflag &=
-			    ~el->el_tty.t_t[ED_IO][MD_INP].t_clrmask;
-			el->el_tty.t_ed.c_iflag |=
-			    el->el_tty.t_t[ED_IO][MD_INP].t_setmask;
-		}
-		if ((el->el_tty.t_ts.c_oflag != el->el_tty.t_ex.c_oflag) &&
-		    (el->el_tty.t_ts.c_oflag != el->el_tty.t_ed.c_oflag)) {
-			el->el_tty.t_ex.c_oflag =
-			    el->el_tty.t_ts.c_oflag;
-			el->el_tty.t_ex.c_oflag &=
-			    ~el->el_tty.t_t[EX_IO][MD_OUT].t_clrmask;
-			el->el_tty.t_ex.c_oflag |=
-			    el->el_tty.t_t[EX_IO][MD_OUT].t_setmask;
-
-			el->el_tty.t_ed.c_oflag =
-			    el->el_tty.t_ts.c_oflag;
-			el->el_tty.t_ed.c_oflag &=
-			    ~el->el_tty.t_t[ED_IO][MD_OUT].t_clrmask;
-			el->el_tty.t_ed.c_oflag |=
-			    el->el_tty.t_t[ED_IO][MD_OUT].t_setmask;
-		}
-		if (tty__gettabs(&el->el_tty.t_ex) == 0)
-			el->el_tty.t_tabs = 0;
-		else
-			el->el_tty.t_tabs = EL_CAN_TAB ? 1 : 0;
-
-		{
-			int i;
-
-			tty__getchar(&el->el_tty.t_ts, el->el_tty.t_c[TS_IO]);
-			/*
-		         * Check if the user made any changes.
-		         * If he did, then propagate the changes to the
-		         * edit and execute data structures.
-		         */
-			for (i = 0; i < C_NCC; i++)
-				if (el->el_tty.t_c[TS_IO][i] !=
-				    el->el_tty.t_c[EX_IO][i])
-					break;
-
-			if (i != C_NCC) {
-				/*
-				 * Propagate changes only to the unprotected
-				 * chars that have been modified just now.
-				 */
-				for (i = 0; i < C_NCC; i++) {
-					if (!((el->el_tty.t_t[ED_IO][MD_CHAR].t_setmask & C_SH(i)))
-					    && (el->el_tty.t_c[TS_IO][i] != el->el_tty.t_c[EX_IO][i]))
-						el->el_tty.t_c[ED_IO][i] = el->el_tty.t_c[TS_IO][i];
-					if (el->el_tty.t_t[ED_IO][MD_CHAR].t_clrmask & C_SH(i))
-						el->el_tty.t_c[ED_IO][i] = el->el_tty.t_vdisable;
-				}
-				tty_bind_char(el, 0);
-				tty__setchar(&el->el_tty.t_ed, el->el_tty.t_c[ED_IO]);
-
-				for (i = 0; i < C_NCC; i++) {
-					if (!((el->el_tty.t_t[EX_IO][MD_CHAR].t_setmask & C_SH(i)))
-					    && (el->el_tty.t_c[TS_IO][i] != el->el_tty.t_c[EX_IO][i]))
-						el->el_tty.t_c[EX_IO][i] = el->el_tty.t_c[TS_IO][i];
-					if (el->el_tty.t_t[EX_IO][MD_CHAR].t_clrmask & C_SH(i))
-						el->el_tty.t_c[EX_IO][i] = el->el_tty.t_vdisable;
-				}
-				tty__setchar(&el->el_tty.t_ex, el->el_tty.t_c[EX_IO]);
-			}
-		}
-	}
-	if (tty_setty(el, &el->el_tty.t_ed) == -1) {
-#ifdef DEBUG_TTY
-		(void) fprintf(el->el_errfile, "tty_rawmode: tty_setty: %s\n",
-		    strerror(errno));
-#endif /* DEBUG_TTY */
-		return (-1);
-	}
-	el->el_tty.t_mode = ED_IO;
-	return (0);
-}
-
-
-/* tty_cookedmode():
- *	Set the tty back to normal mode
- */
-protected int
-tty_cookedmode(EditLine *el)
-{				/* set tty in normal setup */
-
-	if (el->el_tty.t_mode == EX_IO)
-		return (0);
-
-	if (el->el_flags & EDIT_DISABLED)
-		return (0);
-
-	if (tty_setty(el, &el->el_tty.t_ex) == -1) {
-#ifdef DEBUG_TTY
-		(void) fprintf(el->el_errfile,
-		    "tty_cookedmode: tty_setty: %s\n",
-		    strerror(errno));
-#endif /* DEBUG_TTY */
-		return (-1);
-	}
-	el->el_tty.t_mode = EX_IO;
-	return (0);
-}
-
-
-/* tty_quotemode():
- *	Turn on quote mode
- */
-protected int
-tty_quotemode(EditLine *el)
-{
-	if (el->el_tty.t_mode == QU_IO)
-		return (0);
-
-	el->el_tty.t_qu = el->el_tty.t_ed;
-
-	el->el_tty.t_qu.c_iflag &= ~el->el_tty.t_t[QU_IO][MD_INP].t_clrmask;
-	el->el_tty.t_qu.c_iflag |= el->el_tty.t_t[QU_IO][MD_INP].t_setmask;
-
-	el->el_tty.t_qu.c_oflag &= ~el->el_tty.t_t[QU_IO][MD_OUT].t_clrmask;
-	el->el_tty.t_qu.c_oflag |= el->el_tty.t_t[QU_IO][MD_OUT].t_setmask;
-
-	el->el_tty.t_qu.c_cflag &= ~el->el_tty.t_t[QU_IO][MD_CTL].t_clrmask;
-	el->el_tty.t_qu.c_cflag |= el->el_tty.t_t[QU_IO][MD_CTL].t_setmask;
-
-	el->el_tty.t_qu.c_lflag &= ~el->el_tty.t_t[QU_IO][MD_LIN].t_clrmask;
-	el->el_tty.t_qu.c_lflag |= el->el_tty.t_t[QU_IO][MD_LIN].t_setmask;
-
-	if (tty_setty(el, &el->el_tty.t_qu) == -1) {
-#ifdef DEBUG_TTY
-		(void) fprintf(el->el_errfile, "QuoteModeOn: tty_setty: %s\n",
-		    strerror(errno));
-#endif /* DEBUG_TTY */
-		return (-1);
-	}
-	el->el_tty.t_mode = QU_IO;
-	return (0);
-}
-
-
-/* tty_noquotemode():
- *	Turn off quote mode
- */
-protected int
-tty_noquotemode(EditLine *el)
-{
-
-	if (el->el_tty.t_mode != QU_IO)
-		return (0);
-	if (tty_setty(el, &el->el_tty.t_ed) == -1) {
-#ifdef DEBUG_TTY
-		(void) fprintf(el->el_errfile, "QuoteModeOff: tty_setty: %s\n",
-		    strerror(errno));
-#endif /* DEBUG_TTY */
-		return (-1);
-	}
-	el->el_tty.t_mode = ED_IO;
-	return (0);
-}
-
-
-/* tty_stty():
- *	Stty builtin
- */
-protected int
-/*ARGSUSED*/
-tty_stty(EditLine *el, int argc, const char **argv)
-{
-	const ttymodes_t *m;
-	char x;
-	int aflag = 0;
-	const char *s, *d;
-	const char *name;
-	int z = EX_IO;
-
-	if (argv == NULL)
-		return (-1);
-	name = *argv++;
-
-	while (argv && *argv && argv[0][0] == '-' && argv[0][2] == '\0')
-		switch (argv[0][1]) {
-		case 'a':
-			aflag++;
-			argv++;
-			break;
-		case 'd':
-			argv++;
-			z = ED_IO;
-			break;
-		case 'x':
-			argv++;
-			z = EX_IO;
-			break;
-		case 'q':
-			argv++;
-			z = QU_IO;
-			break;
-		default:
-			(void) fprintf(el->el_errfile,
-			    "%s: Unknown switch `%c'.\n",
-			    name, argv[0][1]);
-			return (-1);
-		}
-
-	if (!argv || !*argv) {
-		int i = -1;
-		int len = 0, st = 0, cu;
-		for (m = ttymodes; m->m_name; m++) {
-			if (m->m_type != i) {
-				(void) fprintf(el->el_outfile, "%s%s",
-				    i != -1 ? "\n" : "",
-				    el->el_tty.t_t[z][m->m_type].t_name);
-				i = m->m_type;
-				st = len =
-				    strlen(el->el_tty.t_t[z][m->m_type].t_name);
-			}
-			x = (el->el_tty.t_t[z][i].t_setmask & m->m_value)
-			    ?  '+' : '\0';
-			x = (el->el_tty.t_t[z][i].t_clrmask & m->m_value)
-			    ? '-' : x;
-
-			if (x != '\0' || aflag) {
-
-				cu = strlen(m->m_name) + (x != '\0') + 1;
-
-				if (len + cu >= el->el_term.t_size.h) {
-					(void) fprintf(el->el_outfile, "\n%*s",
-					    st, "");
-					len = st + cu;
-				} else
-					len += cu;
-
-				if (x != '\0')
-					(void) fprintf(el->el_outfile, "%c%s ",
-					    x, m->m_name);
-				else
-					(void) fprintf(el->el_outfile, "%s ",
-					    m->m_name);
-			}
-		}
-		(void) fprintf(el->el_outfile, "\n");
-		return (0);
-	}
-	while (argv && (s = *argv++)) {
-		switch (*s) {
-		case '+':
-		case '-':
-			x = *s++;
-			break;
-		default:
-			x = '\0';
-			break;
-		}
-		d = s;
-		for (m = ttymodes; m->m_name; m++)
-			if (strcmp(m->m_name, d) == 0)
-				break;
-
-		if (!m->m_name) {
-			(void) fprintf(el->el_errfile,
-			    "%s: Invalid argument `%s'.\n", name, d);
-			return (-1);
-		}
-		switch (x) {
-		case '+':
-			el->el_tty.t_t[z][m->m_type].t_setmask |= m->m_value;
-			el->el_tty.t_t[z][m->m_type].t_clrmask &= ~m->m_value;
-			break;
-		case '-':
-			el->el_tty.t_t[z][m->m_type].t_setmask &= ~m->m_value;
-			el->el_tty.t_t[z][m->m_type].t_clrmask |= m->m_value;
-			break;
-		default:
-			el->el_tty.t_t[z][m->m_type].t_setmask &= ~m->m_value;
-			el->el_tty.t_t[z][m->m_type].t_clrmask &= ~m->m_value;
-			break;
-		}
-	}
-	return (0);
-}
-
-
-#ifdef notyet
-/* tty_printchar():
- *	DEbugging routine to print the tty characters
- */
-private void
-tty_printchar(EditLine *el, unsigned char *s)
-{
-	ttyperm_t *m;
-	int i;
-
-	for (i = 0; i < C_NCC; i++) {
-		for (m = el->el_tty.t_t; m->m_name; m++)
-			if (m->m_type == MD_CHAR && C_SH(i) == m->m_value)
-				break;
-		if (m->m_name)
-			(void) fprintf(el->el_errfile, "%s ^%c ",
-			    m->m_name, s[i] + 'A' - 1);
-		if (i % 5 == 0)
-			(void) fprintf(el->el_errfile, "\n");
-	}
-	(void) fprintf(el->el_errfile, "\n");
-}
-#endif /* notyet */
diff --git a/main/editline/tty.h b/main/editline/tty.h
deleted file mode 100644
index e9597fc..0000000
--- a/main/editline/tty.h
+++ /dev/null
@@ -1,484 +0,0 @@
-/*	$NetBSD: tty.h,v 1.9 2002/03/18 16:01:01 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)tty.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.tty.h: Local terminal header
- */
-#ifndef _h_el_tty
-#define	_h_el_tty
-
-#include "histedit.h"
-#include <termios.h>
-#include <unistd.h>
-
-/* Define our own since everyone gets it wrong! */
-#define	CONTROL(A)	((A) & 037)
-
-/*
- * Aix compatible names
- */
-# if defined(VWERSE) && !defined(VWERASE)
-#  define VWERASE VWERSE
-# endif /* VWERSE && !VWERASE */
-
-# if defined(VDISCRD) && !defined(VDISCARD)
-#  define VDISCARD VDISCRD
-# endif /* VDISCRD && !VDISCARD */
-
-# if defined(VFLUSHO) && !defined(VDISCARD)
-#  define VDISCARD VFLUSHO
-# endif  /* VFLUSHO && VDISCARD */
-
-# if defined(VSTRT) && !defined(VSTART)
-#  define VSTART VSTRT
-# endif /* VSTRT && ! VSTART */
-
-# if defined(VSTAT) && !defined(VSTATUS)
-#  define VSTATUS VSTAT
-# endif /* VSTAT && ! VSTATUS */
-
-# ifndef ONLRET
-#  define ONLRET 0
-# endif /* ONLRET */
-
-# ifndef TAB3
-#  ifdef OXTABS
-#   define TAB3 OXTABS
-#  else
-#   define TAB3 0
-#  endif /* OXTABS */
-# endif /* !TAB3 */
-
-# if defined(OXTABS) && !defined(XTABS)
-#  define XTABS OXTABS
-# endif /* OXTABS && !XTABS */
-
-# ifndef ONLCR
-#  define ONLCR 0
-# endif /* ONLCR */
-
-# ifndef IEXTEN
-#  define IEXTEN 0
-# endif /* IEXTEN */
-
-# ifndef ECHOCTL
-#  define ECHOCTL 0
-# endif /* ECHOCTL */
-
-# ifndef PARENB
-#  define PARENB 0
-# endif /* PARENB */
-
-# ifndef EXTPROC
-#  define EXTPROC 0
-# endif /* EXTPROC */
-
-# ifndef FLUSHO
-#  define FLUSHO  0
-# endif /* FLUSHO */
-
-
-# if defined(VDISABLE) && !defined(_POSIX_VDISABLE)
-#  define _POSIX_VDISABLE VDISABLE
-# endif /* VDISABLE && ! _POSIX_VDISABLE */
-
-/*
- * Work around ISC's definition of IEXTEN which is
- * XCASE!
- */
-# ifdef ISC
-#  if defined(IEXTEN) && defined(XCASE)
-#   if IEXTEN == XCASE
-#    undef IEXTEN
-#    define IEXTEN 0
-#   endif /* IEXTEN == XCASE */
-#  endif /* IEXTEN && XCASE */
-#  if defined(IEXTEN) && !defined(XCASE)
-#   define XCASE IEXTEN
-#   undef IEXTEN
-#   define IEXTEN 0
-#  endif /* IEXTEN && !XCASE */
-# endif /* ISC */
-
-/*
- * Work around convex weirdness where turning off IEXTEN makes us
- * lose all postprocessing!
- */
-#if defined(convex) || defined(__convex__)
-# if defined(IEXTEN) && IEXTEN != 0
-#  undef IEXTEN
-#  define IEXTEN 0
-# endif /* IEXTEN != 0 */
-#endif /* convex || __convex__ */
-
-/*
- * So that we don't lose job control.
- */
-#ifdef __SVR4
-# undef CSWTCH
-#endif
-
-#ifndef _POSIX_VDISABLE
-# define _POSIX_VDISABLE ((unsigned char) -1)
-#endif /* _POSIX_VDISABLE */
-
-#if !defined(CREPRINT) && defined(CRPRNT)
-# define CREPRINT CRPRNT
-#endif /* !CREPRINT && CRPRNT */
-#if !defined(CDISCARD) && defined(CFLUSH)
-# define CDISCARD CFLUSH
-#endif /* !CDISCARD && CFLUSH */
-
-#ifndef CINTR
-# define CINTR		CONTROL('c')
-#endif /* CINTR */
-#ifndef CQUIT
-# define CQUIT		034	/* ^\ */
-#endif /* CQUIT */
-#ifndef CERASE
-# define CERASE		0177	/* ^? */
-#endif /* CERASE */
-#ifndef CKILL
-# define CKILL		CONTROL('u')
-#endif /* CKILL */
-#ifndef CEOF
-# define CEOF		CONTROL('d')
-#endif /* CEOF */
-#ifndef CEOL
-# define CEOL		_POSIX_VDISABLE
-#endif /* CEOL */
-#ifndef CEOL2
-# define CEOL2		_POSIX_VDISABLE
-#endif /* CEOL2 */
-#ifndef CSWTCH
-# define CSWTCH		_POSIX_VDISABLE
-#endif /* CSWTCH */
-#ifndef CDSWTCH
-# define CDSWTCH	_POSIX_VDISABLE
-#endif /* CDSWTCH */
-#ifndef CERASE2
-# define CERASE2	_POSIX_VDISABLE
-#endif /* CERASE2 */
-#ifndef CSTART
-# define CSTART		CONTROL('q')
-#endif /* CSTART */
-#ifndef CSTOP
-# define CSTOP		CONTROL('s')
-#endif /* CSTOP */
-#ifndef CSUSP
-# define CSUSP		CONTROL('z')
-#endif /* CSUSP */
-#ifndef CDSUSP
-# define CDSUSP		CONTROL('y')
-#endif /* CDSUSP */
-
-#ifdef hpux
-
-# ifndef CREPRINT
-#  define CREPRINT	_POSIX_VDISABLE
-# endif /* CREPRINT */
-# ifndef CDISCARD
-#  define CDISCARD	_POSIX_VDISABLE
-# endif /* CDISCARD */
-# ifndef CLNEXT
-#  define CLNEXT	_POSIX_VDISABLE
-# endif /* CLNEXT */
-# ifndef CWERASE
-#  define CWERASE	_POSIX_VDISABLE
-# endif /* CWERASE */
-
-#else /* !hpux */
-
-# ifndef CREPRINT
-#  define CREPRINT	CONTROL('r')
-# endif /* CREPRINT */
-# ifndef CDISCARD
-#  define CDISCARD	CONTROL('o')
-# endif /* CDISCARD */
-# ifndef CLNEXT
-#  define CLNEXT	CONTROL('v')
-# endif /* CLNEXT */
-# ifndef CWERASE
-#  define CWERASE	CONTROL('w')
-# endif /* CWERASE */
-
-#endif /* hpux */
-
-#ifndef CSTATUS
-# define CSTATUS	CONTROL('t')
-#endif /* CSTATUS */
-#ifndef CPAGE
-# define CPAGE		' '
-#endif /* CPAGE */
-#ifndef CPGOFF
-# define CPGOFF		CONTROL('m')
-#endif /* CPGOFF */
-#ifndef CKILL2
-# define CKILL2		_POSIX_VDISABLE
-#endif /* CKILL2 */
-#ifndef CBRK
-# ifndef masscomp
-#  define CBRK		0377
-# else
-#  define CBRK		'\0'
-# endif /* masscomp */
-#endif /* CBRK */
-#ifndef CMIN
-# define CMIN		CEOF
-#endif /* CMIN */
-#ifndef CTIME
-# define CTIME		CEOL
-#endif /* CTIME */
-
-/*
- * Fix for sun inconsistency. On termio VSUSP and the rest of the
- * ttychars > NCC are defined. So we undefine them.
- */
-#if defined(TERMIO) || defined(POSIX)
-# if defined(POSIX) && defined(NCCS)
-#  define NUMCC		NCCS
-# else
-#  ifdef NCC
-#   define NUMCC	NCC
-#  endif /* NCC */
-# endif /* POSIX && NCCS */
-# ifdef NUMCC
-#  ifdef VINTR
-#   if NUMCC <= VINTR
-#    undef VINTR
-#   endif /* NUMCC <= VINTR */
-#  endif /* VINTR */
-#  ifdef VQUIT
-#   if NUMCC <= VQUIT
-#    undef VQUIT
-#   endif /* NUMCC <= VQUIT */
-#  endif /* VQUIT */
-#  ifdef VERASE
-#   if NUMCC <= VERASE
-#    undef VERASE
-#   endif /* NUMCC <= VERASE */
-#  endif /* VERASE */
-#  ifdef VKILL
-#   if NUMCC <= VKILL
-#    undef VKILL
-#   endif /* NUMCC <= VKILL */
-#  endif /* VKILL */
-#  ifdef VEOF
-#   if NUMCC <= VEOF
-#    undef VEOF
-#   endif /* NUMCC <= VEOF */
-#  endif /* VEOF */
-#  ifdef VEOL
-#   if NUMCC <= VEOL
-#    undef VEOL
-#   endif /* NUMCC <= VEOL */
-#  endif /* VEOL */
-#  ifdef VEOL2
-#   if NUMCC <= VEOL2
-#    undef VEOL2
-#   endif /* NUMCC <= VEOL2 */
-#  endif /* VEOL2 */
-#  ifdef VSWTCH
-#   if NUMCC <= VSWTCH
-#    undef VSWTCH
-#   endif /* NUMCC <= VSWTCH */
-#  endif /* VSWTCH */
-#  ifdef VDSWTCH
-#   if NUMCC <= VDSWTCH
-#    undef VDSWTCH
-#   endif /* NUMCC <= VDSWTCH */
-#  endif /* VDSWTCH */
-#  ifdef VERASE2
-#   if NUMCC <= VERASE2
-#    undef VERASE2
-#   endif /* NUMCC <= VERASE2 */
-#  endif /* VERASE2 */
-#  ifdef VSTART
-#   if NUMCC <= VSTART
-#    undef VSTART
-#   endif /* NUMCC <= VSTART */
-#  endif /* VSTART */
-#  ifdef VSTOP
-#   if NUMCC <= VSTOP
-#    undef VSTOP
-#   endif /* NUMCC <= VSTOP */
-#  endif /* VSTOP */
-#  ifdef VWERASE
-#   if NUMCC <= VWERASE
-#    undef VWERASE
-#   endif /* NUMCC <= VWERASE */
-#  endif /* VWERASE */
-#  ifdef VSUSP
-#   if NUMCC <= VSUSP
-#    undef VSUSP
-#   endif /* NUMCC <= VSUSP */
-#  endif /* VSUSP */
-#  ifdef VDSUSP
-#   if NUMCC <= VDSUSP
-#    undef VDSUSP
-#   endif /* NUMCC <= VDSUSP */
-#  endif /* VDSUSP */
-#  ifdef VREPRINT
-#   if NUMCC <= VREPRINT
-#    undef VREPRINT
-#   endif /* NUMCC <= VREPRINT */
-#  endif /* VREPRINT */
-#  ifdef VDISCARD
-#   if NUMCC <= VDISCARD
-#    undef VDISCARD
-#   endif /* NUMCC <= VDISCARD */
-#  endif /* VDISCARD */
-#  ifdef VLNEXT
-#   if NUMCC <= VLNEXT
-#    undef VLNEXT
-#   endif /* NUMCC <= VLNEXT */
-#  endif /* VLNEXT */
-#  ifdef VSTATUS
-#   if NUMCC <= VSTATUS
-#    undef VSTATUS
-#   endif /* NUMCC <= VSTATUS */
-#  endif /* VSTATUS */
-#  ifdef VPAGE
-#   if NUMCC <= VPAGE
-#    undef VPAGE
-#   endif /* NUMCC <= VPAGE */
-#  endif /* VPAGE */
-#  ifdef VPGOFF
-#   if NUMCC <= VPGOFF
-#    undef VPGOFF
-#   endif /* NUMCC <= VPGOFF */
-#  endif /* VPGOFF */
-#  ifdef VKILL2
-#   if NUMCC <= VKILL2
-#    undef VKILL2
-#   endif /* NUMCC <= VKILL2 */
-#  endif /* VKILL2 */
-#  ifdef VBRK
-#   if NUMCC <= VBRK
-#    undef VBRK
-#   endif /* NUMCC <= VBRK */
-#  endif /* VBRK */
-#  ifdef VMIN
-#   if NUMCC <= VMIN
-#    undef VMIN
-#   endif /* NUMCC <= VMIN */
-#  endif /* VMIN */
-#  ifdef VTIME
-#   if NUMCC <= VTIME
-#    undef VTIME
-#   endif /* NUMCC <= VTIME */
-#  endif /* VTIME */
-# endif /* NUMCC */
-#endif /* !POSIX */
-
-#define	C_INTR		 0
-#define	C_QUIT		 1
-#define	C_ERASE		 2
-#define	C_KILL		 3
-#define	C_EOF		 4
-#define	C_EOL		 5
-#define	C_EOL2		 6
-#define	C_SWTCH		 7
-#define	C_DSWTCH	 8
-#define	C_ERASE2	 9
-#define	C_START		10
-#define	C_STOP		11
-#define	C_WERASE	12
-#define	C_SUSP		13
-#define	C_DSUSP		14
-#define	C_REPRINT	15
-#define	C_DISCARD	16
-#define	C_LNEXT		17
-#define	C_STATUS	18
-#define	C_PAGE		19
-#define	C_PGOFF		20
-#define	C_KILL2		21
-#define	C_BRK		22
-#define	C_MIN		23
-#define	C_TIME		24
-#define	C_NCC		25
-#define	C_SH(A)		(1 << (A))
-
-/*
- * Terminal dependend data structures
- */
-#define	EX_IO	0	/* while we are executing	*/
-#define	ED_IO	1	/* while we are editing		*/
-#define	TS_IO	2	/* new mode from terminal	*/
-#define	QU_IO	2	/* used only for quoted chars	*/
-#define	NN_IO	3	/* The number of entries	*/
-
-#define	MD_INP	0
-#define	MD_OUT	1
-#define	MD_CTL	2
-#define	MD_LIN	3
-#define	MD_CHAR	4
-#define	MD_NN	5
-
-typedef struct {
-	const char	*t_name;
-	u_int	 t_setmask;
-	u_int	 t_clrmask;
-} ttyperm_t[NN_IO][MD_NN];
-
-typedef unsigned char ttychar_t[NN_IO][C_NCC];
-
-protected int	tty_init(EditLine *);
-protected void	tty_end(EditLine *);
-protected int	tty_stty(EditLine *, int, const char **);
-protected int	tty_rawmode(EditLine *);
-protected int	tty_cookedmode(EditLine *);
-protected int	tty_quotemode(EditLine *);
-protected int	tty_noquotemode(EditLine *);
-protected void	tty_bind_char(EditLine *, int);
-
-typedef struct {
-    ttyperm_t t_t;
-    ttychar_t t_c;
-    struct termios t_ex, t_ed, t_ts;
-    int t_tabs;
-    int t_eight;
-    speed_t t_speed;
-    int t_mode;
-    unsigned char t_vdisable;
-} el_tty_t;
-
-
-#endif /* _h_el_tty */
diff --git a/main/editline/vi.c b/main/editline/vi.c
deleted file mode 100644
index 5683c7d..0000000
--- a/main/editline/vi.c
+++ /dev/null
@@ -1,941 +0,0 @@
-/*	$NetBSD: vi.c,v 1.9 2002/03/18 16:01:01 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "config.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)vi.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: vi.c,v 1.9 2002/03/18 16:01:01 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * vi.c: Vi mode commands.
- */
-#include "el.h"
-
-private el_action_t	cv_action(EditLine *, int);
-private el_action_t	cv_paste(EditLine *, int);
-
-/* cv_action():
- *	Handle vi actions.
- */
-private el_action_t
-cv_action(EditLine *el, int c)
-{
-	char *cp, *kp;
-
-	if (el->el_chared.c_vcmd.action & DELETE) {
-		el->el_chared.c_vcmd.action = NOP;
-		el->el_chared.c_vcmd.pos = 0;
-
-		el->el_chared.c_undo.isize = 0;
-		el->el_chared.c_undo.dsize = 0;
-		kp = el->el_chared.c_undo.buf;
-		for (cp = el->el_line.buffer; cp < el->el_line.lastchar; cp++) {
-			*kp++ = *cp;
-			el->el_chared.c_undo.dsize++;
-		}
-
-		el->el_chared.c_undo.action = INSERT;
-		el->el_chared.c_undo.ptr = el->el_line.buffer;
-		el->el_line.lastchar = el->el_line.buffer;
-		el->el_line.cursor = el->el_line.buffer;
-		if (c & INSERT)
-			el->el_map.current = el->el_map.key;
-
-		return (CC_REFRESH);
-	}
-	el->el_chared.c_vcmd.pos = el->el_line.cursor;
-	el->el_chared.c_vcmd.action = c;
-	return (CC_ARGHACK);
-
-#ifdef notdef
-	/*
-         * I don't think that this is needed. But we keep it for now
-         */
-	else
-	if (el_chared.c_vcmd.action == NOP) {
-		el->el_chared.c_vcmd.pos = el->el_line.cursor;
-		el->el_chared.c_vcmd.action = c;
-		return (CC_ARGHACK);
-	} else {
-		el->el_chared.c_vcmd.action = 0;
-		el->el_chared.c_vcmd.pos = 0;
-		return (CC_ERROR);
-	}
-#endif
-}
-
-
-/* cv_paste():
- *	Paste previous deletion before or after the cursor
- */
-private el_action_t
-cv_paste(EditLine *el, int c)
-{
-	char *ptr;
-	c_undo_t *un = &el->el_chared.c_undo;
-
-#ifdef DEBUG_PASTE
-	(void) fprintf(el->el_errfile, "Paste: %x \"%s\" +%d -%d\n",
-	    un->action, un->buf, un->isize, un->dsize);
-#endif
-	if (un->isize == 0)
-		return (CC_ERROR);
-
-	if (!c && el->el_line.cursor < el->el_line.lastchar)
-		el->el_line.cursor++;
-	ptr = el->el_line.cursor;
-
-	c_insert(el, (int) un->isize);
-	if (el->el_line.cursor + un->isize > el->el_line.lastchar)
-		return (CC_ERROR);
-	(void) memcpy(ptr, un->buf, un->isize);
-	return (CC_REFRESH);
-}
-
-
-/* vi_paste_next():
- *	Vi paste previous deletion to the right of the cursor
- *	[p]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_paste_next(EditLine *el, int c)
-{
-
-	return (cv_paste(el, 0));
-}
-
-
-/* vi_paste_prev():
- *	Vi paste previous deletion to the left of the cursor
- *	[P]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_paste_prev(EditLine *el, int c)
-{
-
-	return (cv_paste(el, 1));
-}
-
-
-/* vi_prev_space_word():
- *	Vi move to the previous space delimited word
- *	[B]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_prev_space_word(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor == el->el_line.buffer)
-		return (CC_ERROR);
-
-	el->el_line.cursor = cv_prev_word(el, el->el_line.cursor,
-	    el->el_line.buffer,
-	    el->el_state.argument,
-	    cv__isword);
-
-	if (el->el_chared.c_vcmd.action & DELETE) {
-		cv_delfini(el);
-		return (CC_REFRESH);
-	}
-	return (CC_CURSOR);
-}
-
-
-/* vi_prev_word():
- *	Vi move to the previous word
- *	[B]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_prev_word(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor == el->el_line.buffer)
-		return (CC_ERROR);
-
-	el->el_line.cursor = cv_prev_word(el, el->el_line.cursor,
-	    el->el_line.buffer,
-	    el->el_state.argument,
-	    ce__isword);
-
-	if (el->el_chared.c_vcmd.action & DELETE) {
-		cv_delfini(el);
-		return (CC_REFRESH);
-	}
-	return (CC_CURSOR);
-}
-
-
-/* vi_next_space_word():
- *	Vi move to the next space delimited word
- *	[W]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_next_space_word(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor == el->el_line.lastchar)
-		return (CC_ERROR);
-
-	el->el_line.cursor = cv_next_word(el, el->el_line.cursor,
-	    el->el_line.lastchar,
-	    el->el_state.argument,
-	    cv__isword);
-
-	if (el->el_map.type == MAP_VI)
-		if (el->el_chared.c_vcmd.action & DELETE) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-	return (CC_CURSOR);
-}
-
-
-/* vi_next_word():
- *	Vi move to the next word
- *	[w]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_next_word(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor == el->el_line.lastchar)
-		return (CC_ERROR);
-
-	el->el_line.cursor = cv_next_word(el, el->el_line.cursor,
-	    el->el_line.lastchar,
-	    el->el_state.argument,
-	    ce__isword);
-
-	if (el->el_map.type == MAP_VI)
-		if (el->el_chared.c_vcmd.action & DELETE) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-	return (CC_CURSOR);
-}
-
-
-/* vi_change_case():
- *	Vi change case of character under the cursor and advance one character
- *	[~]
- */
-protected el_action_t
-vi_change_case(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor < el->el_line.lastchar) {
-		c = *el->el_line.cursor;
-		if (isupper(c))
-			*el->el_line.cursor++ = tolower(c);
-		else if (islower(c))
-			*el->el_line.cursor++ = toupper(c);
-		else
-			el->el_line.cursor++;
-		re_fastaddc(el);
-		return (CC_NORM);
-	}
-	return (CC_ERROR);
-}
-
-
-/* vi_change_meta():
- *	Vi change prefix command
- *	[c]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_change_meta(EditLine *el, int c)
-{
-
-	/*
-         * Delete with insert == change: first we delete and then we leave in
-         * insert mode.
-         */
-	return (cv_action(el, DELETE | INSERT));
-}
-
-
-/* vi_insert_at_bol():
- *	Vi enter insert mode at the beginning of line
- *	[I]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_insert_at_bol(EditLine *el, int c)
-{
-
-	el->el_line.cursor = el->el_line.buffer;
-	el->el_chared.c_vcmd.ins = el->el_line.cursor;
-
-	el->el_chared.c_undo.ptr = el->el_line.cursor;
-	el->el_chared.c_undo.action = DELETE;
-
-	el->el_map.current = el->el_map.key;
-	return (CC_CURSOR);
-}
-
-
-/* vi_replace_char():
- *	Vi replace character under the cursor with the next character typed
- *	[r]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_replace_char(EditLine *el, int c)
-{
-
-	el->el_map.current = el->el_map.key;
-	el->el_state.inputmode = MODE_REPLACE_1;
-	el->el_chared.c_undo.action = CHANGE;
-	el->el_chared.c_undo.ptr = el->el_line.cursor;
-	el->el_chared.c_undo.isize = 0;
-	el->el_chared.c_undo.dsize = 0;
-	return (CC_NORM);
-}
-
-
-/* vi_replace_mode():
- *	Vi enter replace mode
- *	[R]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_replace_mode(EditLine *el, int c)
-{
-
-	el->el_map.current = el->el_map.key;
-	el->el_state.inputmode = MODE_REPLACE;
-	el->el_chared.c_undo.action = CHANGE;
-	el->el_chared.c_undo.ptr = el->el_line.cursor;
-	el->el_chared.c_undo.isize = 0;
-	el->el_chared.c_undo.dsize = 0;
-	return (CC_NORM);
-}
-
-
-/* vi_substitute_char():
- *	Vi replace character under the cursor and enter insert mode
- *	[r]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_substitute_char(EditLine *el, int c)
-{
-
-	c_delafter(el, el->el_state.argument);
-	el->el_map.current = el->el_map.key;
-	return (CC_REFRESH);
-}
-
-
-/* vi_substitute_line():
- *	Vi substitute entire line
- *	[S]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_substitute_line(EditLine *el, int c)
-{
-
-	(void) em_kill_line(el, 0);
-	el->el_map.current = el->el_map.key;
-	return (CC_REFRESH);
-}
-
-
-/* vi_change_to_eol():
- *	Vi change to end of line
- *	[C]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_change_to_eol(EditLine *el, int c)
-{
-
-	(void) ed_kill_line(el, 0);
-	el->el_map.current = el->el_map.key;
-	return (CC_REFRESH);
-}
-
-
-/* vi_insert():
- *	Vi enter insert mode
- *	[i]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_insert(EditLine *el, int c)
-{
-
-	el->el_map.current = el->el_map.key;
-
-	el->el_chared.c_vcmd.ins = el->el_line.cursor;
-	el->el_chared.c_undo.ptr = el->el_line.cursor;
-	el->el_chared.c_undo.action = DELETE;
-
-	return (CC_NORM);
-}
-
-
-/* vi_add():
- *	Vi enter insert mode after the cursor
- *	[a]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_add(EditLine *el, int c)
-{
-	int ret;
-
-	el->el_map.current = el->el_map.key;
-	if (el->el_line.cursor < el->el_line.lastchar) {
-		el->el_line.cursor++;
-		if (el->el_line.cursor > el->el_line.lastchar)
-			el->el_line.cursor = el->el_line.lastchar;
-		ret = CC_CURSOR;
-	} else
-		ret = CC_NORM;
-
-	el->el_chared.c_vcmd.ins = el->el_line.cursor;
-	el->el_chared.c_undo.ptr = el->el_line.cursor;
-	el->el_chared.c_undo.action = DELETE;
-
-	return (ret);
-}
-
-
-/* vi_add_at_eol():
- *	Vi enter insert mode at end of line
- *	[A]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_add_at_eol(EditLine *el, int c)
-{
-
-	el->el_map.current = el->el_map.key;
-	el->el_line.cursor = el->el_line.lastchar;
-
-	/* Mark where insertion begins */
-	el->el_chared.c_vcmd.ins = el->el_line.lastchar;
-	el->el_chared.c_undo.ptr = el->el_line.lastchar;
-	el->el_chared.c_undo.action = DELETE;
-	return (CC_CURSOR);
-}
-
-
-/* vi_delete_meta():
- *	Vi delete prefix command
- *	[d]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_delete_meta(EditLine *el, int c)
-{
-
-	return (cv_action(el, DELETE));
-}
-
-
-/* vi_end_word():
- *	Vi move to the end of the current space delimited word
- *	[E]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_end_word(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor == el->el_line.lastchar)
-		return (CC_ERROR);
-
-	el->el_line.cursor = cv__endword(el->el_line.cursor,
-	    el->el_line.lastchar, el->el_state.argument);
-
-	if (el->el_chared.c_vcmd.action & DELETE) {
-		el->el_line.cursor++;
-		cv_delfini(el);
-		return (CC_REFRESH);
-	}
-	return (CC_CURSOR);
-}
-
-
-/* vi_to_end_word():
- *	Vi move to the end of the current word
- *	[e]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_to_end_word(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor == el->el_line.lastchar)
-		return (CC_ERROR);
-
-	el->el_line.cursor = cv__endword(el->el_line.cursor,
-	    el->el_line.lastchar, el->el_state.argument);
-
-	if (el->el_chared.c_vcmd.action & DELETE) {
-		el->el_line.cursor++;
-		cv_delfini(el);
-		return (CC_REFRESH);
-	}
-	return (CC_CURSOR);
-}
-
-
-/* vi_undo():
- *	Vi undo last change
- *	[u]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_undo(EditLine *el, int c)
-{
-	char *cp, *kp;
-	char temp;
-	int i, size;
-	c_undo_t *un = &el->el_chared.c_undo;
-
-#ifdef DEBUG_UNDO
-	(void) fprintf(el->el_errfile, "Undo: %x \"%s\" +%d -%d\n",
-	    un->action, un->buf, un->isize, un->dsize);
-#endif
-	switch (un->action) {
-	case DELETE:
-		if (un->dsize == 0)
-			return (CC_NORM);
-
-		(void) memcpy(un->buf, un->ptr, un->dsize);
-		for (cp = un->ptr; cp <= el->el_line.lastchar; cp++)
-			*cp = cp[un->dsize];
-
-		el->el_line.lastchar -= un->dsize;
-		el->el_line.cursor = un->ptr;
-
-		un->action = INSERT;
-		un->isize = un->dsize;
-		un->dsize = 0;
-		break;
-
-	case DELETE | INSERT:
-		size = un->isize - un->dsize;
-		if (size > 0)
-			i = un->dsize;
-		else
-			i = un->isize;
-		cp = un->ptr;
-		kp = un->buf;
-		while (i-- > 0) {
-			temp = *kp;
-			*kp++ = *cp;
-			*cp++ = temp;
-		}
-		if (size > 0) {
-			el->el_line.cursor = cp;
-			c_insert(el, size);
-			while (size-- > 0 && cp < el->el_line.lastchar) {
-				temp = *kp;
-				*kp++ = *cp;
-				*cp++ = temp;
-			}
-		} else if (size < 0) {
-			size = -size;
-			for (; cp <= el->el_line.lastchar; cp++) {
-				*kp++ = *cp;
-				*cp = cp[size];
-			}
-			el->el_line.lastchar -= size;
-		}
-		el->el_line.cursor = un->ptr;
-		i = un->dsize;
-		un->dsize = un->isize;
-		un->isize = i;
-		break;
-
-	case INSERT:
-		if (un->isize == 0)
-			return (CC_NORM);
-
-		el->el_line.cursor = un->ptr;
-		c_insert(el, (int) un->isize);
-		(void) memcpy(un->ptr, un->buf, un->isize);
-		un->action = DELETE;
-		un->dsize = un->isize;
-		un->isize = 0;
-		break;
-
-	case CHANGE:
-		if (un->isize == 0)
-			return (CC_NORM);
-
-		el->el_line.cursor = un->ptr;
-		size = (int) (el->el_line.cursor - el->el_line.lastchar);
-		if (size < un->isize)
-			size = un->isize;
-		cp = un->ptr;
-		kp = un->buf;
-		for (i = 0; i < size; i++) {
-			temp = *kp;
-			*kp++ = *cp;
-			*cp++ = temp;
-		}
-		un->dsize = 0;
-		break;
-
-	default:
-		return (CC_ERROR);
-	}
-
-	return (CC_REFRESH);
-}
-
-
-/* vi_command_mode():
- *	Vi enter command mode (use alternative key bindings)
- *	[<ESC>]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_command_mode(EditLine *el, int c)
-{
-	int size;
-
-	/* [Esc] cancels pending action */
-	el->el_chared.c_vcmd.ins = 0;
-	el->el_chared.c_vcmd.action = NOP;
-	el->el_chared.c_vcmd.pos = 0;
-
-	el->el_state.doingarg = 0;
-	size = el->el_chared.c_undo.ptr - el->el_line.cursor;
-	if (size < 0)
-		size = -size;
-	if (el->el_chared.c_undo.action == (INSERT | DELETE) ||
-	    el->el_chared.c_undo.action == DELETE)
-		el->el_chared.c_undo.dsize = size;
-	else
-		el->el_chared.c_undo.isize = size;
-
-	el->el_state.inputmode = MODE_INSERT;
-	el->el_map.current = el->el_map.alt;
-#ifdef VI_MOVE
-	if (el->el_line.cursor > el->el_line.buffer)
-		el->el_line.cursor--;
-#endif
-	return (CC_CURSOR);
-}
-
-
-/* vi_zero():
- *	Vi move to the beginning of line
- *	[0]
- */
-protected el_action_t
-vi_zero(EditLine *el, int c)
-{
-
-	if (el->el_state.doingarg) {
-		if (el->el_state.argument > 1000000)
-			return (CC_ERROR);
-		el->el_state.argument =
-		    (el->el_state.argument * 10) + (c - '0');
-		return (CC_ARGHACK);
-	} else {
-		el->el_line.cursor = el->el_line.buffer;
-		if (el->el_chared.c_vcmd.action & DELETE) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-		return (CC_CURSOR);
-	}
-}
-
-
-/* vi_delete_prev_char():
- * 	Vi move to previous character (backspace)
- *	[^H]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_delete_prev_char(EditLine *el, int c)
-{
-
-	if (el->el_chared.c_vcmd.ins == 0)
-		return (CC_ERROR);
-
-	if (el->el_chared.c_vcmd.ins >
-	    el->el_line.cursor - el->el_state.argument)
-		return (CC_ERROR);
-
-	c_delbefore(el, el->el_state.argument);
-	el->el_line.cursor -= el->el_state.argument;
-
-	return (CC_REFRESH);
-}
-
-
-/* vi_list_or_eof():
- *	Vi list choices for completion or indicate end of file if empty line
- *	[^D]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_list_or_eof(EditLine *el, int c)
-{
-
-#ifdef notyet
-	if (el->el_line.cursor == el->el_line.lastchar &&
-	    el->el_line.cursor == el->el_line.buffer) {
-#endif
-		term_overwrite(el, STReof, 4);	/* then do a EOF */
-		term__flush();
-		return (CC_EOF);
-#ifdef notyet
-	} else {
-		re_goto_bottom(el);
-		*el->el_line.lastchar = '\0';	/* just in case */
-		return (CC_LIST_CHOICES);
-	}
-#endif
-}
-
-
-/* vi_kill_line_prev():
- *	Vi cut from beginning of line to cursor
- *	[^U]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_kill_line_prev(EditLine *el, int c)
-{
-	char *kp, *cp;
-
-	cp = el->el_line.buffer;
-	kp = el->el_chared.c_kill.buf;
-	while (cp < el->el_line.cursor)
-		*kp++ = *cp++;	/* copy it */
-	el->el_chared.c_kill.last = kp;
-	c_delbefore(el, el->el_line.cursor - el->el_line.buffer);
-	el->el_line.cursor = el->el_line.buffer;	/* zap! */
-	return (CC_REFRESH);
-}
-
-
-/* vi_search_prev():
- *	Vi search history previous
- *	[?]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_search_prev(EditLine *el, int c)
-{
-
-	return (cv_search(el, ED_SEARCH_PREV_HISTORY));
-}
-
-
-/* vi_search_next():
- *	Vi search history next
- *	[/]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_search_next(EditLine *el, int c)
-{
-
-	return (cv_search(el, ED_SEARCH_NEXT_HISTORY));
-}
-
-
-/* vi_repeat_search_next():
- *	Vi repeat current search in the same search direction
- *	[n]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_repeat_search_next(EditLine *el, int c)
-{
-
-	if (el->el_search.patlen == 0)
-		return (CC_ERROR);
-	else
-		return (cv_repeat_srch(el, el->el_search.patdir));
-}
-
-
-/* vi_repeat_search_prev():
- *	Vi repeat current search in the opposite search direction
- *	[N]
- */
-/*ARGSUSED*/
-protected el_action_t
-vi_repeat_search_prev(EditLine *el, int c)
-{
-
-	if (el->el_search.patlen == 0)
-		return (CC_ERROR);
-	else
-		return (cv_repeat_srch(el,
-		    el->el_search.patdir == ED_SEARCH_PREV_HISTORY ?
-		    ED_SEARCH_NEXT_HISTORY : ED_SEARCH_PREV_HISTORY));
-}
-
-
-/* vi_next_char():
- *	Vi move to the character specified next
- *	[f]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_next_char(EditLine *el, int c)
-{
-	char ch;
-
-	if (el_getc(el, &ch) != 1)
-		return (ed_end_of_file(el, 0));
-
-	el->el_search.chadir = CHAR_FWD;
-	el->el_search.chacha = ch;
-
-	return (cv_csearch_fwd(el, ch, el->el_state.argument, 0));
-
-}
-
-
-/* vi_prev_char():
- *	Vi move to the character specified previous
- *	[F]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_prev_char(EditLine *el, int c)
-{
-	char ch;
-
-	if (el_getc(el, &ch) != 1)
-		return (ed_end_of_file(el, 0));
-
-	el->el_search.chadir = CHAR_BACK;
-	el->el_search.chacha = ch;
-
-	return (cv_csearch_back(el, ch, el->el_state.argument, 0));
-}
-
-
-/* vi_to_next_char():
- *	Vi move up to the character specified next
- *	[t]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_to_next_char(EditLine *el, int c)
-{
-	char ch;
-
-	if (el_getc(el, &ch) != 1)
-		return (ed_end_of_file(el, 0));
-
-	return (cv_csearch_fwd(el, ch, el->el_state.argument, 1));
-
-}
-
-
-/* vi_to_prev_char():
- *	Vi move up to the character specified previous
- *	[T]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_to_prev_char(EditLine *el, int c)
-{
-	char ch;
-
-	if (el_getc(el, &ch) != 1)
-		return (ed_end_of_file(el, 0));
-
-	return (cv_csearch_back(el, ch, el->el_state.argument, 1));
-}
-
-
-/* vi_repeat_next_char():
- *	Vi repeat current character search in the same search direction
- *	[;]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_repeat_next_char(EditLine *el, int c)
-{
-
-	if (el->el_search.chacha == 0)
-		return (CC_ERROR);
-
-	return (el->el_search.chadir == CHAR_FWD
-	    ? cv_csearch_fwd(el, el->el_search.chacha,
-		el->el_state.argument, 0)
-	    : cv_csearch_back(el, el->el_search.chacha,
-		el->el_state.argument, 0));
-}
-
-
-/* vi_repeat_prev_char():
- *	Vi repeat current character search in the opposite search direction
- *	[,]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_repeat_prev_char(EditLine *el, int c)
-{
-
-	if (el->el_search.chacha == 0)
-		return (CC_ERROR);
-
-	return el->el_search.chadir == CHAR_BACK ?
-	    cv_csearch_fwd(el, el->el_search.chacha, el->el_state.argument, 0) :
-	    cv_csearch_back(el, el->el_search.chacha, el->el_state.argument, 0);
-}
diff --git a/makeopts.in b/makeopts.in
index c7a5eaf..a47f858 100644
--- a/makeopts.in
+++ b/makeopts.in
@@ -118,8 +118,6 @@ CURSES_INCLUDE=@CURSES_INCLUDE@
 CURSES_LIB=@CURSES_LIB@
 CURSES_DIR=@CURSES_DIR@
 
-EDITLINE_LIB=@EDITLINE_LIB@
-
 FREETDS_INCLUDE=@FREETDS_INCLUDE@
 FREETDS_LIB=@FREETDS_LIB@
 
@@ -309,3 +307,7 @@ TINFO_DIR=@TINFO_DIR@
 # if poll is not present, let the makefile know.
 POLL_AVAILABLE=@HAS_POLL@
 TIMERFD_INCLUDE=@TIMERFD_INCLUDE@
+
+LIBEDIT_INCLUDE=@LIBEDIT_INCLUDE@
+LIBEDIT_LIB=@LIBEDIT_LIB@
+LIBEDIT_OBJ=@LIBEDIT_OBJ@
-- 
1.7.6.4

