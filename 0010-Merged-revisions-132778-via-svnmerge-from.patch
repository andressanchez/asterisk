From 56da7591f2d9b11f5f5d2ed2b7e4785d955d172b Mon Sep 17 00:00:00 2001
From: tilghman <tilghman@614ede4d-c843-0410-af14-a771ab80d22e>
Date: Tue, 22 Jul 2008 21:55:06 +0000
Subject: [PATCH] Merged revisions 132778 via svnmerge from
 https://origsvn.digium.com/svn/asterisk/trunk

................
r132778 | tilghman | 2008-07-22 16:53:40 -0500 (Tue, 22 Jul 2008) | 18 lines

Merged revisions 132713 via svnmerge from
https://origsvn.digium.com/svn/asterisk/branches/1.4

................
r132713 | tilghman | 2008-07-22 16:19:39 -0500 (Tue, 22 Jul 2008) | 10 lines

Merged revisions 132711 via svnmerge from
https://origsvn.digium.com/svn/asterisk/branches/1.2

........
r132711 | tilghman | 2008-07-22 16:14:10 -0500 (Tue, 22 Jul 2008) | 2 lines

Fixes for AST-2008-010 and AST-2008-011

........

................

................

git-svn-id: http://svn.digium.com/svn/asterisk/branches/1.6.0@132780 614ede4d-c843-0410-af14-a771ab80d22e
---
 channels/chan_iax2.c    |   31 +++++++++++++++++++++++++++++--
 configs/iax.conf.sample |   10 ++++++++++
 2 files changed, 39 insertions(+), 2 deletions(-)

diff --git a/channels/chan_iax2.c b/channels/chan_iax2.c
index abdad2d..125e087 100644
--- a/channels/chan_iax2.c
+++ b/channels/chan_iax2.c
@@ -275,6 +275,7 @@ enum iax2_flags {
 	IAX_DELAYPBXSTART =	(1 << 25),	/*!< Don't start a PBX on the channel until the peer sends us a
 						     response, so that we've achieved a three-way handshake with
 						     them before sending voice or anything else*/
+	IAX_ALLOWFWDOWNLOAD = (1 << 26),	/*!< Allow the FWDOWNL command? */
 };
 
 static int global_rtautoclear = 120;
@@ -1647,10 +1648,10 @@ static int __find_callno(unsigned short callno, unsigned short dcallno, struct s
 			snprintf(host, sizeof(host), "%s:%d", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));
 
 		now = ast_tvnow();
-		start = 1 + (ast_random() % (TRUNK_CALL_START - 1));
+		start = 2 + (ast_random() % (TRUNK_CALL_START - 1));
 		for (x = start; 1; x++) {
 			if (x == TRUNK_CALL_START) {
-				x = 0;
+				x = 1;
 				continue;
 			}
 
@@ -3389,6 +3390,15 @@ struct parsed_dial_string {
 	char *options;
 };
 
+static int send_apathetic_reply(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int command, int ts, unsigned char seqno)
+{
+	struct ast_iax2_full_hdr f = { .scallno = htons(0x8000 | callno), .dcallno = htons(dcallno),
+		.ts = htonl(ts), .iseqno = seqno, .oseqno = seqno, .type = AST_FRAME_IAX,
+		.csub = compress_subclass(command) };
+
+	return sendto(defaultsockfd, &f, sizeof(f), 0, (struct sockaddr *)sin, sizeof(*sin));
+}
+
 /*!
  * \brief Parses an IAX dial string into its component parts.
  * \param data the string to be parsed
@@ -7935,6 +7945,17 @@ static int socket_process(struct iax2_thread *thread)
 		} else {
 			f.subclass = uncompress_subclass(fh->csub);
 		}
+
+		/* Deal with POKE/PONG without allocating a callno */
+		if (f.frametype == AST_FRAME_IAX && f.subclass == IAX_COMMAND_POKE) {
+			/* Reply back with a PONG, but don't care about the result. */
+			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohs(fh->ts), fh->oseqno);
+			return 1;
+		} else if (f.frametype == AST_FRAME_IAX && f.subclass == IAX_COMMAND_ACK && dcallno == 1) {
+			/* Ignore */
+			return 1;
+		}
+
 		if ((f.frametype == AST_FRAME_IAX) && ((f.subclass == IAX_COMMAND_NEW) || (f.subclass == IAX_COMMAND_REGREQ) ||
 						       (f.subclass == IAX_COMMAND_POKE) || (f.subclass == IAX_COMMAND_FWDOWNL) ||
 						       (f.subclass == IAX_COMMAND_REGREL)))
@@ -9235,6 +9256,10 @@ retryowner2:
 				break;
 			case IAX_COMMAND_FWDOWNL:
 				/* Firmware download */
+				if (!ast_test_flag(&globalflags, IAX_ALLOWFWDOWNLOAD)) {
+					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);
+					break;
+				}
 				memset(&ied0, 0, sizeof(ied0));
 				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);
 				if (res < 0)
@@ -10878,6 +10903,8 @@ static int set_config(char *config_file, int reload)
 			ast_set2_flag((&globalflags), ast_true(v->value), IAX_FORCEJITTERBUF);	
 		else if (!strcasecmp(v->name, "delayreject"))
 			delayreject = ast_true(v->value);
+		else if (!strcasecmp(v->name, "allowfwdownload"))
+			ast_set2_flag((&globalflags), ast_true(v->value), IAX_ALLOWFWDOWNLOAD);
 		else if (!strcasecmp(v->name, "rtcachefriends"))
 			ast_set2_flag((&globalflags), ast_true(v->value), IAX_RTCACHEFRIENDS);	
 		else if (!strcasecmp(v->name, "rtignoreregexpire"))
diff --git a/configs/iax.conf.sample b/configs/iax.conf.sample
index 2441f2c..854a243 100644
--- a/configs/iax.conf.sample
+++ b/configs/iax.conf.sample
@@ -264,6 +264,16 @@ autokill=yes
 ; The default value is 'host'
 ;
 ;codecpriority=host
+;
+; allowfwdownload controls whether this host will serve out firmware to
+; IAX clients which request it.  This has only been used for the IAXy,
+; and it has been recently proven that this firmware distribution method
+; can be used as a source of traffic amplification attacks.  Also, the
+; IAXy firmware has not been updated for at least 18 months, so unless
+; you are provisioning IAXys in a secure network, we recommend that you
+; leave this option to the default, off.
+;
+;allowfwdownload=yes
 
 ;rtcachefriends=yes	; Cache realtime friends by adding them to the internal list
 			; just like friends added from the config file only on a
-- 
1.5.5.2

